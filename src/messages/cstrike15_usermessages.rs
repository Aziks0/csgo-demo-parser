// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.21.12
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `cstrike15_usermessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_VGUIMenu)
pub struct CUSRMsg_VGUIMenu {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_VGUIMenu.name)
    pub name: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CUSRMsg_VGUIMenu.show)
    pub show: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUSRMsg_VGUIMenu.subkeys)
    pub subkeys: ::std::vec::Vec<cusrmsg_vguimenu::Subkey>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_VGUIMenu.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_VGUIMenu {
    fn default() -> &'a CUSRMsg_VGUIMenu {
        <CUSRMsg_VGUIMenu as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_VGUIMenu {
    pub fn new() -> CUSRMsg_VGUIMenu {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::protobuf::Chars) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::protobuf::Chars {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::protobuf::Chars {
        self.name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional bool show = 2;

    pub fn show(&self) -> bool {
        self.show.unwrap_or(false)
    }

    pub fn clear_show(&mut self) {
        self.show = ::std::option::Option::None;
    }

    pub fn has_show(&self) -> bool {
        self.show.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show(&mut self, v: bool) {
        self.show = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CUSRMsg_VGUIMenu| { &m.name },
            |m: &mut CUSRMsg_VGUIMenu| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show",
            |m: &CUSRMsg_VGUIMenu| { &m.show },
            |m: &mut CUSRMsg_VGUIMenu| { &mut m.show },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "subkeys",
            |m: &CUSRMsg_VGUIMenu| { &m.subkeys },
            |m: &mut CUSRMsg_VGUIMenu| { &mut m.subkeys },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_VGUIMenu>(
            "CUSRMsg_VGUIMenu",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_VGUIMenu {
    const NAME: &'static str = "CUSRMsg_VGUIMenu";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                16 => {
                    self.show = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.subkeys.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.show {
            my_size += 1 + 1;
        }
        for value in &self.subkeys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.show {
            os.write_bool(2, v)?;
        }
        for v in &self.subkeys {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_VGUIMenu {
        CUSRMsg_VGUIMenu::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.show = ::std::option::Option::None;
        self.subkeys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_VGUIMenu {
        static instance: CUSRMsg_VGUIMenu = CUSRMsg_VGUIMenu {
            name: ::std::option::Option::None,
            show: ::std::option::Option::None,
            subkeys: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_VGUIMenu {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_VGUIMenu").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_VGUIMenu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_VGUIMenu {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CUSRMsg_VGUIMenu`
pub mod cusrmsg_vguimenu {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CUSRMsg_VGUIMenu.Subkey)
    pub struct Subkey {
        // message fields
        // @@protoc_insertion_point(field:CUSRMsg_VGUIMenu.Subkey.name)
        pub name: ::std::option::Option<::protobuf::Chars>,
        // @@protoc_insertion_point(field:CUSRMsg_VGUIMenu.Subkey.str)
        pub str: ::std::option::Option<::protobuf::Chars>,
        // special fields
        // @@protoc_insertion_point(special_field:CUSRMsg_VGUIMenu.Subkey.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Subkey {
        fn default() -> &'a Subkey {
            <Subkey as ::protobuf::Message>::default_instance()
        }
    }

    impl Subkey {
        pub fn new() -> Subkey {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::protobuf::Chars) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::protobuf::Chars {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::protobuf::Chars::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::protobuf::Chars {
            self.name.take().unwrap_or_else(|| ::protobuf::Chars::new())
        }

        // optional string str = 2;

        pub fn str(&self) -> &str {
            match self.str.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_str(&mut self) {
            self.str = ::std::option::Option::None;
        }

        pub fn has_str(&self) -> bool {
            self.str.is_some()
        }

        // Param is passed by value, moved
        pub fn set_str(&mut self, v: ::protobuf::Chars) {
            self.str = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_str(&mut self) -> &mut ::protobuf::Chars {
            if self.str.is_none() {
                self.str = ::std::option::Option::Some(::protobuf::Chars::new());
            }
            self.str.as_mut().unwrap()
        }

        // Take field
        pub fn take_str(&mut self) -> ::protobuf::Chars {
            self.str.take().unwrap_or_else(|| ::protobuf::Chars::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Subkey| { &m.name },
                |m: &mut Subkey| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "str",
                |m: &Subkey| { &m.str },
                |m: &mut Subkey| { &mut m.str },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Subkey>(
                "CUSRMsg_VGUIMenu.Subkey",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Subkey {
        const NAME: &'static str = "Subkey";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_tokio_chars()?);
                    },
                    18 => {
                        self.str = ::std::option::Option::Some(is.read_tokio_chars()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.str.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.str.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Subkey {
            Subkey::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.str = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Subkey {
            static instance: Subkey = Subkey {
                name: ::std::option::Option::None,
                str: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Subkey {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUSRMsg_VGUIMenu.Subkey").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Subkey {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Subkey {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_Geiger)
pub struct CUSRMsg_Geiger {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_Geiger.range)
    pub range: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_Geiger.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_Geiger {
    fn default() -> &'a CUSRMsg_Geiger {
        <CUSRMsg_Geiger as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_Geiger {
    pub fn new() -> CUSRMsg_Geiger {
        ::std::default::Default::default()
    }

    // optional int32 range = 1;

    pub fn range(&self) -> i32 {
        self.range.unwrap_or(0)
    }

    pub fn clear_range(&mut self) {
        self.range = ::std::option::Option::None;
    }

    pub fn has_range(&self) -> bool {
        self.range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: i32) {
        self.range = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "range",
            |m: &CUSRMsg_Geiger| { &m.range },
            |m: &mut CUSRMsg_Geiger| { &mut m.range },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_Geiger>(
            "CUSRMsg_Geiger",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_Geiger {
    const NAME: &'static str = "CUSRMsg_Geiger";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.range = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.range {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.range {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_Geiger {
        CUSRMsg_Geiger::new()
    }

    fn clear(&mut self) {
        self.range = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_Geiger {
        static instance: CUSRMsg_Geiger = CUSRMsg_Geiger {
            range: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_Geiger {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_Geiger").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_Geiger {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_Geiger {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_Train)
pub struct CUSRMsg_Train {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_Train.train)
    pub train: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_Train.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_Train {
    fn default() -> &'a CUSRMsg_Train {
        <CUSRMsg_Train as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_Train {
    pub fn new() -> CUSRMsg_Train {
        ::std::default::Default::default()
    }

    // optional int32 train = 1;

    pub fn train(&self) -> i32 {
        self.train.unwrap_or(0)
    }

    pub fn clear_train(&mut self) {
        self.train = ::std::option::Option::None;
    }

    pub fn has_train(&self) -> bool {
        self.train.is_some()
    }

    // Param is passed by value, moved
    pub fn set_train(&mut self, v: i32) {
        self.train = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "train",
            |m: &CUSRMsg_Train| { &m.train },
            |m: &mut CUSRMsg_Train| { &mut m.train },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_Train>(
            "CUSRMsg_Train",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_Train {
    const NAME: &'static str = "CUSRMsg_Train";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.train = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.train {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.train {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_Train {
        CUSRMsg_Train::new()
    }

    fn clear(&mut self) {
        self.train = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_Train {
        static instance: CUSRMsg_Train = CUSRMsg_Train {
            train: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_Train {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_Train").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_Train {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_Train {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_HudText)
pub struct CUSRMsg_HudText {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_HudText.text)
    pub text: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_HudText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_HudText {
    fn default() -> &'a CUSRMsg_HudText {
        <CUSRMsg_HudText as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_HudText {
    pub fn new() -> CUSRMsg_HudText {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::protobuf::Chars) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::protobuf::Chars {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::protobuf::Chars {
        self.text.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CUSRMsg_HudText| { &m.text },
            |m: &mut CUSRMsg_HudText| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_HudText>(
            "CUSRMsg_HudText",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_HudText {
    const NAME: &'static str = "CUSRMsg_HudText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_HudText {
        CUSRMsg_HudText::new()
    }

    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_HudText {
        static instance: CUSRMsg_HudText = CUSRMsg_HudText {
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_HudText {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_HudText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_HudText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_HudText {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_SayText)
pub struct CUSRMsg_SayText {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_SayText.ent_idx)
    pub ent_idx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_SayText.text)
    pub text: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CUSRMsg_SayText.chat)
    pub chat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUSRMsg_SayText.textallchat)
    pub textallchat: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_SayText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_SayText {
    fn default() -> &'a CUSRMsg_SayText {
        <CUSRMsg_SayText as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_SayText {
    pub fn new() -> CUSRMsg_SayText {
        ::std::default::Default::default()
    }

    // optional int32 ent_idx = 1;

    pub fn ent_idx(&self) -> i32 {
        self.ent_idx.unwrap_or(0)
    }

    pub fn clear_ent_idx(&mut self) {
        self.ent_idx = ::std::option::Option::None;
    }

    pub fn has_ent_idx(&self) -> bool {
        self.ent_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_idx(&mut self, v: i32) {
        self.ent_idx = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::protobuf::Chars) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::protobuf::Chars {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::protobuf::Chars {
        self.text.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional bool chat = 3;

    pub fn chat(&self) -> bool {
        self.chat.unwrap_or(false)
    }

    pub fn clear_chat(&mut self) {
        self.chat = ::std::option::Option::None;
    }

    pub fn has_chat(&self) -> bool {
        self.chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat(&mut self, v: bool) {
        self.chat = ::std::option::Option::Some(v);
    }

    // optional bool textallchat = 4;

    pub fn textallchat(&self) -> bool {
        self.textallchat.unwrap_or(false)
    }

    pub fn clear_textallchat(&mut self) {
        self.textallchat = ::std::option::Option::None;
    }

    pub fn has_textallchat(&self) -> bool {
        self.textallchat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_textallchat(&mut self, v: bool) {
        self.textallchat = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ent_idx",
            |m: &CUSRMsg_SayText| { &m.ent_idx },
            |m: &mut CUSRMsg_SayText| { &mut m.ent_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CUSRMsg_SayText| { &m.text },
            |m: &mut CUSRMsg_SayText| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat",
            |m: &CUSRMsg_SayText| { &m.chat },
            |m: &mut CUSRMsg_SayText| { &mut m.chat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "textallchat",
            |m: &CUSRMsg_SayText| { &m.textallchat },
            |m: &mut CUSRMsg_SayText| { &mut m.textallchat },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_SayText>(
            "CUSRMsg_SayText",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_SayText {
    const NAME: &'static str = "CUSRMsg_SayText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ent_idx = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                24 => {
                    self.chat = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.textallchat = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ent_idx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.chat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.textallchat {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ent_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.chat {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.textallchat {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_SayText {
        CUSRMsg_SayText::new()
    }

    fn clear(&mut self) {
        self.ent_idx = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.chat = ::std::option::Option::None;
        self.textallchat = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_SayText {
        static instance: CUSRMsg_SayText = CUSRMsg_SayText {
            ent_idx: ::std::option::Option::None,
            text: ::std::option::Option::None,
            chat: ::std::option::Option::None,
            textallchat: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_SayText {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_SayText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_SayText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_SayText {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_SayText2)
pub struct CUSRMsg_SayText2 {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_SayText2.ent_idx)
    pub ent_idx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_SayText2.chat)
    pub chat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUSRMsg_SayText2.msg_name)
    pub msg_name: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CUSRMsg_SayText2.params)
    pub params: ::std::vec::Vec<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CUSRMsg_SayText2.textallchat)
    pub textallchat: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_SayText2.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_SayText2 {
    fn default() -> &'a CUSRMsg_SayText2 {
        <CUSRMsg_SayText2 as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_SayText2 {
    pub fn new() -> CUSRMsg_SayText2 {
        ::std::default::Default::default()
    }

    // optional int32 ent_idx = 1;

    pub fn ent_idx(&self) -> i32 {
        self.ent_idx.unwrap_or(0)
    }

    pub fn clear_ent_idx(&mut self) {
        self.ent_idx = ::std::option::Option::None;
    }

    pub fn has_ent_idx(&self) -> bool {
        self.ent_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_idx(&mut self, v: i32) {
        self.ent_idx = ::std::option::Option::Some(v);
    }

    // optional bool chat = 2;

    pub fn chat(&self) -> bool {
        self.chat.unwrap_or(false)
    }

    pub fn clear_chat(&mut self) {
        self.chat = ::std::option::Option::None;
    }

    pub fn has_chat(&self) -> bool {
        self.chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat(&mut self, v: bool) {
        self.chat = ::std::option::Option::Some(v);
    }

    // optional string msg_name = 3;

    pub fn msg_name(&self) -> &str {
        match self.msg_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_msg_name(&mut self) {
        self.msg_name = ::std::option::Option::None;
    }

    pub fn has_msg_name(&self) -> bool {
        self.msg_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_name(&mut self, v: ::protobuf::Chars) {
        self.msg_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_name(&mut self) -> &mut ::protobuf::Chars {
        if self.msg_name.is_none() {
            self.msg_name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.msg_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg_name(&mut self) -> ::protobuf::Chars {
        self.msg_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional bool textallchat = 5;

    pub fn textallchat(&self) -> bool {
        self.textallchat.unwrap_or(false)
    }

    pub fn clear_textallchat(&mut self) {
        self.textallchat = ::std::option::Option::None;
    }

    pub fn has_textallchat(&self) -> bool {
        self.textallchat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_textallchat(&mut self, v: bool) {
        self.textallchat = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ent_idx",
            |m: &CUSRMsg_SayText2| { &m.ent_idx },
            |m: &mut CUSRMsg_SayText2| { &mut m.ent_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chat",
            |m: &CUSRMsg_SayText2| { &m.chat },
            |m: &mut CUSRMsg_SayText2| { &mut m.chat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_name",
            |m: &CUSRMsg_SayText2| { &m.msg_name },
            |m: &mut CUSRMsg_SayText2| { &mut m.msg_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "params",
            |m: &CUSRMsg_SayText2| { &m.params },
            |m: &mut CUSRMsg_SayText2| { &mut m.params },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "textallchat",
            |m: &CUSRMsg_SayText2| { &m.textallchat },
            |m: &mut CUSRMsg_SayText2| { &mut m.textallchat },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_SayText2>(
            "CUSRMsg_SayText2",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_SayText2 {
    const NAME: &'static str = "CUSRMsg_SayText2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ent_idx = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.chat = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.msg_name = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                34 => {
                    self.params.push(is.read_tokio_chars()?);
                },
                40 => {
                    self.textallchat = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ent_idx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.chat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.msg_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.params {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.textallchat {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ent_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.chat {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.msg_name.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.params {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.textallchat {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_SayText2 {
        CUSRMsg_SayText2::new()
    }

    fn clear(&mut self) {
        self.ent_idx = ::std::option::Option::None;
        self.chat = ::std::option::Option::None;
        self.msg_name = ::std::option::Option::None;
        self.params.clear();
        self.textallchat = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_SayText2 {
        static instance: CUSRMsg_SayText2 = CUSRMsg_SayText2 {
            ent_idx: ::std::option::Option::None,
            chat: ::std::option::Option::None,
            msg_name: ::std::option::Option::None,
            params: ::std::vec::Vec::new(),
            textallchat: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_SayText2 {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_SayText2").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_SayText2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_SayText2 {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_TextMsg)
pub struct CUSRMsg_TextMsg {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_TextMsg.msg_dst)
    pub msg_dst: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_TextMsg.params)
    pub params: ::std::vec::Vec<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_TextMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_TextMsg {
    fn default() -> &'a CUSRMsg_TextMsg {
        <CUSRMsg_TextMsg as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_TextMsg {
    pub fn new() -> CUSRMsg_TextMsg {
        ::std::default::Default::default()
    }

    // optional int32 msg_dst = 1;

    pub fn msg_dst(&self) -> i32 {
        self.msg_dst.unwrap_or(0)
    }

    pub fn clear_msg_dst(&mut self) {
        self.msg_dst = ::std::option::Option::None;
    }

    pub fn has_msg_dst(&self) -> bool {
        self.msg_dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_dst(&mut self, v: i32) {
        self.msg_dst = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_dst",
            |m: &CUSRMsg_TextMsg| { &m.msg_dst },
            |m: &mut CUSRMsg_TextMsg| { &mut m.msg_dst },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "params",
            |m: &CUSRMsg_TextMsg| { &m.params },
            |m: &mut CUSRMsg_TextMsg| { &mut m.params },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_TextMsg>(
            "CUSRMsg_TextMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_TextMsg {
    const NAME: &'static str = "CUSRMsg_TextMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_dst = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.params.push(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_dst {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.params {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_dst {
            os.write_int32(1, v)?;
        }
        for v in &self.params {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_TextMsg {
        CUSRMsg_TextMsg::new()
    }

    fn clear(&mut self) {
        self.msg_dst = ::std::option::Option::None;
        self.params.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_TextMsg {
        static instance: CUSRMsg_TextMsg = CUSRMsg_TextMsg {
            msg_dst: ::std::option::Option::None,
            params: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_TextMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_TextMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_TextMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_TextMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_HudMsg)
pub struct CUSRMsg_HudMsg {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_HudMsg.channel)
    pub channel: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_HudMsg.pos)
    pub pos: ::protobuf::MessageField<super::netmessages::CMsgVector2D>,
    // @@protoc_insertion_point(field:CUSRMsg_HudMsg.clr1)
    pub clr1: ::protobuf::MessageField<super::netmessages::CMsgRGBA>,
    // @@protoc_insertion_point(field:CUSRMsg_HudMsg.clr2)
    pub clr2: ::protobuf::MessageField<super::netmessages::CMsgRGBA>,
    // @@protoc_insertion_point(field:CUSRMsg_HudMsg.effect)
    pub effect: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_HudMsg.fade_in_time)
    pub fade_in_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_HudMsg.fade_out_time)
    pub fade_out_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_HudMsg.hold_time)
    pub hold_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_HudMsg.fx_time)
    pub fx_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_HudMsg.text)
    pub text: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_HudMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_HudMsg {
    fn default() -> &'a CUSRMsg_HudMsg {
        <CUSRMsg_HudMsg as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_HudMsg {
    pub fn new() -> CUSRMsg_HudMsg {
        ::std::default::Default::default()
    }

    // optional int32 channel = 1;

    pub fn channel(&self) -> i32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: i32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional int32 effect = 5;

    pub fn effect(&self) -> i32 {
        self.effect.unwrap_or(0)
    }

    pub fn clear_effect(&mut self) {
        self.effect = ::std::option::Option::None;
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: i32) {
        self.effect = ::std::option::Option::Some(v);
    }

    // optional float fade_in_time = 6;

    pub fn fade_in_time(&self) -> f32 {
        self.fade_in_time.unwrap_or(0.)
    }

    pub fn clear_fade_in_time(&mut self) {
        self.fade_in_time = ::std::option::Option::None;
    }

    pub fn has_fade_in_time(&self) -> bool {
        self.fade_in_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fade_in_time(&mut self, v: f32) {
        self.fade_in_time = ::std::option::Option::Some(v);
    }

    // optional float fade_out_time = 7;

    pub fn fade_out_time(&self) -> f32 {
        self.fade_out_time.unwrap_or(0.)
    }

    pub fn clear_fade_out_time(&mut self) {
        self.fade_out_time = ::std::option::Option::None;
    }

    pub fn has_fade_out_time(&self) -> bool {
        self.fade_out_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fade_out_time(&mut self, v: f32) {
        self.fade_out_time = ::std::option::Option::Some(v);
    }

    // optional float hold_time = 9;

    pub fn hold_time(&self) -> f32 {
        self.hold_time.unwrap_or(0.)
    }

    pub fn clear_hold_time(&mut self) {
        self.hold_time = ::std::option::Option::None;
    }

    pub fn has_hold_time(&self) -> bool {
        self.hold_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hold_time(&mut self, v: f32) {
        self.hold_time = ::std::option::Option::Some(v);
    }

    // optional float fx_time = 10;

    pub fn fx_time(&self) -> f32 {
        self.fx_time.unwrap_or(0.)
    }

    pub fn clear_fx_time(&mut self) {
        self.fx_time = ::std::option::Option::None;
    }

    pub fn has_fx_time(&self) -> bool {
        self.fx_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fx_time(&mut self, v: f32) {
        self.fx_time = ::std::option::Option::Some(v);
    }

    // optional string text = 11;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::protobuf::Chars) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::protobuf::Chars {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::protobuf::Chars {
        self.text.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "channel",
            |m: &CUSRMsg_HudMsg| { &m.channel },
            |m: &mut CUSRMsg_HudMsg| { &mut m.channel },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::netmessages::CMsgVector2D>(
            "pos",
            |m: &CUSRMsg_HudMsg| { &m.pos },
            |m: &mut CUSRMsg_HudMsg| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::netmessages::CMsgRGBA>(
            "clr1",
            |m: &CUSRMsg_HudMsg| { &m.clr1 },
            |m: &mut CUSRMsg_HudMsg| { &mut m.clr1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::netmessages::CMsgRGBA>(
            "clr2",
            |m: &CUSRMsg_HudMsg| { &m.clr2 },
            |m: &mut CUSRMsg_HudMsg| { &mut m.clr2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "effect",
            |m: &CUSRMsg_HudMsg| { &m.effect },
            |m: &mut CUSRMsg_HudMsg| { &mut m.effect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fade_in_time",
            |m: &CUSRMsg_HudMsg| { &m.fade_in_time },
            |m: &mut CUSRMsg_HudMsg| { &mut m.fade_in_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fade_out_time",
            |m: &CUSRMsg_HudMsg| { &m.fade_out_time },
            |m: &mut CUSRMsg_HudMsg| { &mut m.fade_out_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hold_time",
            |m: &CUSRMsg_HudMsg| { &m.hold_time },
            |m: &mut CUSRMsg_HudMsg| { &mut m.hold_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fx_time",
            |m: &CUSRMsg_HudMsg| { &m.fx_time },
            |m: &mut CUSRMsg_HudMsg| { &mut m.fx_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CUSRMsg_HudMsg| { &m.text },
            |m: &mut CUSRMsg_HudMsg| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_HudMsg>(
            "CUSRMsg_HudMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_HudMsg {
    const NAME: &'static str = "CUSRMsg_HudMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clr1)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clr2)?;
                },
                40 => {
                    self.effect = ::std::option::Option::Some(is.read_int32()?);
                },
                53 => {
                    self.fade_in_time = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.fade_out_time = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.hold_time = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.fx_time = ::std::option::Option::Some(is.read_float()?);
                },
                90 => {
                    self.text = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.clr1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.clr2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.effect {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.fade_in_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.fade_out_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.hold_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.fx_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.channel {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.clr1.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.clr2.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.effect {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.fade_in_time {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.fade_out_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.hold_time {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.fx_time {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_HudMsg {
        CUSRMsg_HudMsg::new()
    }

    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.pos.clear();
        self.clr1.clear();
        self.clr2.clear();
        self.effect = ::std::option::Option::None;
        self.fade_in_time = ::std::option::Option::None;
        self.fade_out_time = ::std::option::Option::None;
        self.hold_time = ::std::option::Option::None;
        self.fx_time = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_HudMsg {
        static instance: CUSRMsg_HudMsg = CUSRMsg_HudMsg {
            channel: ::std::option::Option::None,
            pos: ::protobuf::MessageField::none(),
            clr1: ::protobuf::MessageField::none(),
            clr2: ::protobuf::MessageField::none(),
            effect: ::std::option::Option::None,
            fade_in_time: ::std::option::Option::None,
            fade_out_time: ::std::option::Option::None,
            hold_time: ::std::option::Option::None,
            fx_time: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_HudMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_HudMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_HudMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_HudMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_Shake)
pub struct CUSRMsg_Shake {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_Shake.command)
    pub command: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_Shake.local_amplitude)
    pub local_amplitude: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_Shake.frequency)
    pub frequency: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_Shake.duration)
    pub duration: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_Shake.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_Shake {
    fn default() -> &'a CUSRMsg_Shake {
        <CUSRMsg_Shake as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_Shake {
    pub fn new() -> CUSRMsg_Shake {
        ::std::default::Default::default()
    }

    // optional int32 command = 1;

    pub fn command(&self) -> i32 {
        self.command.unwrap_or(0)
    }

    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: i32) {
        self.command = ::std::option::Option::Some(v);
    }

    // optional float local_amplitude = 2;

    pub fn local_amplitude(&self) -> f32 {
        self.local_amplitude.unwrap_or(0.)
    }

    pub fn clear_local_amplitude(&mut self) {
        self.local_amplitude = ::std::option::Option::None;
    }

    pub fn has_local_amplitude(&self) -> bool {
        self.local_amplitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_amplitude(&mut self, v: f32) {
        self.local_amplitude = ::std::option::Option::Some(v);
    }

    // optional float frequency = 3;

    pub fn frequency(&self) -> f32 {
        self.frequency.unwrap_or(0.)
    }

    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: f32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    // optional float duration = 4;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "command",
            |m: &CUSRMsg_Shake| { &m.command },
            |m: &mut CUSRMsg_Shake| { &mut m.command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "local_amplitude",
            |m: &CUSRMsg_Shake| { &m.local_amplitude },
            |m: &mut CUSRMsg_Shake| { &mut m.local_amplitude },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "frequency",
            |m: &CUSRMsg_Shake| { &m.frequency },
            |m: &mut CUSRMsg_Shake| { &mut m.frequency },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CUSRMsg_Shake| { &m.duration },
            |m: &mut CUSRMsg_Shake| { &mut m.duration },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_Shake>(
            "CUSRMsg_Shake",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_Shake {
    const NAME: &'static str = "CUSRMsg_Shake";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.command = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.local_amplitude = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.frequency = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.command {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.local_amplitude {
            my_size += 1 + 4;
        }
        if let Some(v) = self.frequency {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.command {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.local_amplitude {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.frequency {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_Shake {
        CUSRMsg_Shake::new()
    }

    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.local_amplitude = ::std::option::Option::None;
        self.frequency = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_Shake {
        static instance: CUSRMsg_Shake = CUSRMsg_Shake {
            command: ::std::option::Option::None,
            local_amplitude: ::std::option::Option::None,
            frequency: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_Shake {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_Shake").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_Shake {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_Shake {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_Fade)
pub struct CUSRMsg_Fade {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_Fade.duration)
    pub duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_Fade.hold_time)
    pub hold_time: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_Fade.flags)
    pub flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_Fade.clr)
    pub clr: ::protobuf::MessageField<super::netmessages::CMsgRGBA>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_Fade.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_Fade {
    fn default() -> &'a CUSRMsg_Fade {
        <CUSRMsg_Fade as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_Fade {
    pub fn new() -> CUSRMsg_Fade {
        ::std::default::Default::default()
    }

    // optional int32 duration = 1;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional int32 hold_time = 2;

    pub fn hold_time(&self) -> i32 {
        self.hold_time.unwrap_or(0)
    }

    pub fn clear_hold_time(&mut self) {
        self.hold_time = ::std::option::Option::None;
    }

    pub fn has_hold_time(&self) -> bool {
        self.hold_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hold_time(&mut self, v: i32) {
        self.hold_time = ::std::option::Option::Some(v);
    }

    // optional int32 flags = 3;

    pub fn flags(&self) -> i32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CUSRMsg_Fade| { &m.duration },
            |m: &mut CUSRMsg_Fade| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hold_time",
            |m: &CUSRMsg_Fade| { &m.hold_time },
            |m: &mut CUSRMsg_Fade| { &mut m.hold_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CUSRMsg_Fade| { &m.flags },
            |m: &mut CUSRMsg_Fade| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::netmessages::CMsgRGBA>(
            "clr",
            |m: &CUSRMsg_Fade| { &m.clr },
            |m: &mut CUSRMsg_Fade| { &mut m.clr },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_Fade>(
            "CUSRMsg_Fade",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_Fade {
    const NAME: &'static str = "CUSRMsg_Fade";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.duration = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.hold_time = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.flags = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.clr)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.hold_time {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.clr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.duration {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hold_time {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.clr.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_Fade {
        CUSRMsg_Fade::new()
    }

    fn clear(&mut self) {
        self.duration = ::std::option::Option::None;
        self.hold_time = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.clr.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_Fade {
        static instance: CUSRMsg_Fade = CUSRMsg_Fade {
            duration: ::std::option::Option::None,
            hold_time: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            clr: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_Fade {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_Fade").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_Fade {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_Fade {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_Rumble)
pub struct CUSRMsg_Rumble {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_Rumble.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_Rumble.data)
    pub data: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_Rumble.flags)
    pub flags: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_Rumble.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_Rumble {
    fn default() -> &'a CUSRMsg_Rumble {
        <CUSRMsg_Rumble as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_Rumble {
    pub fn new() -> CUSRMsg_Rumble {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional int32 data = 2;

    pub fn data(&self) -> i32 {
        self.data.unwrap_or(0)
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: i32) {
        self.data = ::std::option::Option::Some(v);
    }

    // optional int32 flags = 3;

    pub fn flags(&self) -> i32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &CUSRMsg_Rumble| { &m.index },
            |m: &mut CUSRMsg_Rumble| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CUSRMsg_Rumble| { &m.data },
            |m: &mut CUSRMsg_Rumble| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CUSRMsg_Rumble| { &m.flags },
            |m: &mut CUSRMsg_Rumble| { &mut m.flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_Rumble>(
            "CUSRMsg_Rumble",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_Rumble {
    const NAME: &'static str = "CUSRMsg_Rumble";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.data = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.flags = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.data {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.data {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_Rumble {
        CUSRMsg_Rumble::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_Rumble {
        static instance: CUSRMsg_Rumble = CUSRMsg_Rumble {
            index: ::std::option::Option::None,
            data: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_Rumble {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_Rumble").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_Rumble {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_Rumble {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_CloseCaption)
pub struct CUSRMsg_CloseCaption {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_CloseCaption.hash)
    pub hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUSRMsg_CloseCaption.duration)
    pub duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_CloseCaption.from_player)
    pub from_player: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUSRMsg_CloseCaption.cctoken)
    pub cctoken: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_CloseCaption.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_CloseCaption {
    fn default() -> &'a CUSRMsg_CloseCaption {
        <CUSRMsg_CloseCaption as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_CloseCaption {
    pub fn new() -> CUSRMsg_CloseCaption {
        ::std::default::Default::default()
    }

    // optional uint32 hash = 1;

    pub fn hash(&self) -> u32 {
        self.hash.unwrap_or(0)
    }

    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = ::std::option::Option::Some(v);
    }

    // optional int32 duration = 2;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool from_player = 3;

    pub fn from_player(&self) -> bool {
        self.from_player.unwrap_or(false)
    }

    pub fn clear_from_player(&mut self) {
        self.from_player = ::std::option::Option::None;
    }

    pub fn has_from_player(&self) -> bool {
        self.from_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_player(&mut self, v: bool) {
        self.from_player = ::std::option::Option::Some(v);
    }

    // optional string cctoken = 4;

    pub fn cctoken(&self) -> &str {
        match self.cctoken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cctoken(&mut self) {
        self.cctoken = ::std::option::Option::None;
    }

    pub fn has_cctoken(&self) -> bool {
        self.cctoken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cctoken(&mut self, v: ::protobuf::Chars) {
        self.cctoken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cctoken(&mut self) -> &mut ::protobuf::Chars {
        if self.cctoken.is_none() {
            self.cctoken = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.cctoken.as_mut().unwrap()
    }

    // Take field
    pub fn take_cctoken(&mut self) -> ::protobuf::Chars {
        self.cctoken.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash",
            |m: &CUSRMsg_CloseCaption| { &m.hash },
            |m: &mut CUSRMsg_CloseCaption| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CUSRMsg_CloseCaption| { &m.duration },
            |m: &mut CUSRMsg_CloseCaption| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_player",
            |m: &CUSRMsg_CloseCaption| { &m.from_player },
            |m: &mut CUSRMsg_CloseCaption| { &mut m.from_player },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cctoken",
            |m: &CUSRMsg_CloseCaption| { &m.cctoken },
            |m: &mut CUSRMsg_CloseCaption| { &mut m.cctoken },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_CloseCaption>(
            "CUSRMsg_CloseCaption",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_CloseCaption {
    const NAME: &'static str = "CUSRMsg_CloseCaption";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hash = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.duration = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.from_player = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.cctoken = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hash {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.from_player {
            my_size += 1 + 1;
        }
        if let Some(v) = self.cctoken.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hash {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.from_player {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.cctoken.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_CloseCaption {
        CUSRMsg_CloseCaption::new()
    }

    fn clear(&mut self) {
        self.hash = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.from_player = ::std::option::Option::None;
        self.cctoken = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_CloseCaption {
        static instance: CUSRMsg_CloseCaption = CUSRMsg_CloseCaption {
            hash: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            from_player: ::std::option::Option::None,
            cctoken: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_CloseCaption {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_CloseCaption").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_CloseCaption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_CloseCaption {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_CloseCaptionDirect)
pub struct CUSRMsg_CloseCaptionDirect {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_CloseCaptionDirect.hash)
    pub hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUSRMsg_CloseCaptionDirect.duration)
    pub duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_CloseCaptionDirect.from_player)
    pub from_player: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_CloseCaptionDirect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_CloseCaptionDirect {
    fn default() -> &'a CUSRMsg_CloseCaptionDirect {
        <CUSRMsg_CloseCaptionDirect as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_CloseCaptionDirect {
    pub fn new() -> CUSRMsg_CloseCaptionDirect {
        ::std::default::Default::default()
    }

    // optional uint32 hash = 1;

    pub fn hash(&self) -> u32 {
        self.hash.unwrap_or(0)
    }

    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = ::std::option::Option::Some(v);
    }

    // optional int32 duration = 2;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool from_player = 3;

    pub fn from_player(&self) -> bool {
        self.from_player.unwrap_or(false)
    }

    pub fn clear_from_player(&mut self) {
        self.from_player = ::std::option::Option::None;
    }

    pub fn has_from_player(&self) -> bool {
        self.from_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_player(&mut self, v: bool) {
        self.from_player = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash",
            |m: &CUSRMsg_CloseCaptionDirect| { &m.hash },
            |m: &mut CUSRMsg_CloseCaptionDirect| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CUSRMsg_CloseCaptionDirect| { &m.duration },
            |m: &mut CUSRMsg_CloseCaptionDirect| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "from_player",
            |m: &CUSRMsg_CloseCaptionDirect| { &m.from_player },
            |m: &mut CUSRMsg_CloseCaptionDirect| { &mut m.from_player },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_CloseCaptionDirect>(
            "CUSRMsg_CloseCaptionDirect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_CloseCaptionDirect {
    const NAME: &'static str = "CUSRMsg_CloseCaptionDirect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hash = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.duration = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.from_player = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hash {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.from_player {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.hash {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.from_player {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_CloseCaptionDirect {
        CUSRMsg_CloseCaptionDirect::new()
    }

    fn clear(&mut self) {
        self.hash = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.from_player = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_CloseCaptionDirect {
        static instance: CUSRMsg_CloseCaptionDirect = CUSRMsg_CloseCaptionDirect {
            hash: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            from_player: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_CloseCaptionDirect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_CloseCaptionDirect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_CloseCaptionDirect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_CloseCaptionDirect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_SendAudio)
pub struct CUSRMsg_SendAudio {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_SendAudio.radio_sound)
    pub radio_sound: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_SendAudio.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_SendAudio {
    fn default() -> &'a CUSRMsg_SendAudio {
        <CUSRMsg_SendAudio as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_SendAudio {
    pub fn new() -> CUSRMsg_SendAudio {
        ::std::default::Default::default()
    }

    // optional string radio_sound = 1;

    pub fn radio_sound(&self) -> &str {
        match self.radio_sound.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_radio_sound(&mut self) {
        self.radio_sound = ::std::option::Option::None;
    }

    pub fn has_radio_sound(&self) -> bool {
        self.radio_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_sound(&mut self, v: ::protobuf::Chars) {
        self.radio_sound = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_radio_sound(&mut self) -> &mut ::protobuf::Chars {
        if self.radio_sound.is_none() {
            self.radio_sound = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.radio_sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_radio_sound(&mut self) -> ::protobuf::Chars {
        self.radio_sound.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "radio_sound",
            |m: &CUSRMsg_SendAudio| { &m.radio_sound },
            |m: &mut CUSRMsg_SendAudio| { &mut m.radio_sound },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_SendAudio>(
            "CUSRMsg_SendAudio",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_SendAudio {
    const NAME: &'static str = "CUSRMsg_SendAudio";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.radio_sound = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radio_sound.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.radio_sound.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_SendAudio {
        CUSRMsg_SendAudio::new()
    }

    fn clear(&mut self) {
        self.radio_sound = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_SendAudio {
        static instance: CUSRMsg_SendAudio = CUSRMsg_SendAudio {
            radio_sound: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_SendAudio {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_SendAudio").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_SendAudio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_SendAudio {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_RawAudio)
pub struct CUSRMsg_RawAudio {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_RawAudio.pitch)
    pub pitch: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_RawAudio.entidx)
    pub entidx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_RawAudio.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_RawAudio.voice_filename)
    pub voice_filename: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_RawAudio.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_RawAudio {
    fn default() -> &'a CUSRMsg_RawAudio {
        <CUSRMsg_RawAudio as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_RawAudio {
    pub fn new() -> CUSRMsg_RawAudio {
        ::std::default::Default::default()
    }

    // optional int32 pitch = 1;

    pub fn pitch(&self) -> i32 {
        self.pitch.unwrap_or(0)
    }

    pub fn clear_pitch(&mut self) {
        self.pitch = ::std::option::Option::None;
    }

    pub fn has_pitch(&self) -> bool {
        self.pitch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pitch(&mut self, v: i32) {
        self.pitch = ::std::option::Option::Some(v);
    }

    // optional int32 entidx = 2;

    pub fn entidx(&self) -> i32 {
        self.entidx.unwrap_or(0)
    }

    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional float duration = 3;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional string voice_filename = 4;

    pub fn voice_filename(&self) -> &str {
        match self.voice_filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_voice_filename(&mut self) {
        self.voice_filename = ::std::option::Option::None;
    }

    pub fn has_voice_filename(&self) -> bool {
        self.voice_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_filename(&mut self, v: ::protobuf::Chars) {
        self.voice_filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voice_filename(&mut self) -> &mut ::protobuf::Chars {
        if self.voice_filename.is_none() {
            self.voice_filename = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.voice_filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_voice_filename(&mut self) -> ::protobuf::Chars {
        self.voice_filename.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pitch",
            |m: &CUSRMsg_RawAudio| { &m.pitch },
            |m: &mut CUSRMsg_RawAudio| { &mut m.pitch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entidx",
            |m: &CUSRMsg_RawAudio| { &m.entidx },
            |m: &mut CUSRMsg_RawAudio| { &mut m.entidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration",
            |m: &CUSRMsg_RawAudio| { &m.duration },
            |m: &mut CUSRMsg_RawAudio| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voice_filename",
            |m: &CUSRMsg_RawAudio| { &m.voice_filename },
            |m: &mut CUSRMsg_RawAudio| { &mut m.voice_filename },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_RawAudio>(
            "CUSRMsg_RawAudio",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_RawAudio {
    const NAME: &'static str = "CUSRMsg_RawAudio";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pitch = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.entidx = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                34 => {
                    self.voice_filename = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pitch {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.voice_filename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pitch {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.entidx {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.voice_filename.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_RawAudio {
        CUSRMsg_RawAudio::new()
    }

    fn clear(&mut self) {
        self.pitch = ::std::option::Option::None;
        self.entidx = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.voice_filename = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_RawAudio {
        static instance: CUSRMsg_RawAudio = CUSRMsg_RawAudio {
            pitch: ::std::option::Option::None,
            entidx: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            voice_filename: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_RawAudio {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_RawAudio").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_RawAudio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_RawAudio {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_VoiceMask)
pub struct CUSRMsg_VoiceMask {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_VoiceMask.player_masks)
    pub player_masks: ::std::vec::Vec<cusrmsg_voice_mask::PlayerMask>,
    // @@protoc_insertion_point(field:CUSRMsg_VoiceMask.player_mod_enable)
    pub player_mod_enable: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_VoiceMask.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_VoiceMask {
    fn default() -> &'a CUSRMsg_VoiceMask {
        <CUSRMsg_VoiceMask as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_VoiceMask {
    pub fn new() -> CUSRMsg_VoiceMask {
        ::std::default::Default::default()
    }

    // optional bool player_mod_enable = 2;

    pub fn player_mod_enable(&self) -> bool {
        self.player_mod_enable.unwrap_or(false)
    }

    pub fn clear_player_mod_enable(&mut self) {
        self.player_mod_enable = ::std::option::Option::None;
    }

    pub fn has_player_mod_enable(&self) -> bool {
        self.player_mod_enable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_mod_enable(&mut self, v: bool) {
        self.player_mod_enable = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_masks",
            |m: &CUSRMsg_VoiceMask| { &m.player_masks },
            |m: &mut CUSRMsg_VoiceMask| { &mut m.player_masks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_mod_enable",
            |m: &CUSRMsg_VoiceMask| { &m.player_mod_enable },
            |m: &mut CUSRMsg_VoiceMask| { &mut m.player_mod_enable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_VoiceMask>(
            "CUSRMsg_VoiceMask",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_VoiceMask {
    const NAME: &'static str = "CUSRMsg_VoiceMask";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_masks.push(is.read_message()?);
                },
                16 => {
                    self.player_mod_enable = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_masks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.player_mod_enable {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.player_masks {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.player_mod_enable {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_VoiceMask {
        CUSRMsg_VoiceMask::new()
    }

    fn clear(&mut self) {
        self.player_masks.clear();
        self.player_mod_enable = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_VoiceMask {
        static instance: CUSRMsg_VoiceMask = CUSRMsg_VoiceMask {
            player_masks: ::std::vec::Vec::new(),
            player_mod_enable: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_VoiceMask {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_VoiceMask").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_VoiceMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_VoiceMask {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CUSRMsg_VoiceMask`
pub mod cusrmsg_voice_mask {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CUSRMsg_VoiceMask.PlayerMask)
    pub struct PlayerMask {
        // message fields
        // @@protoc_insertion_point(field:CUSRMsg_VoiceMask.PlayerMask.game_rules_mask)
        pub game_rules_mask: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_VoiceMask.PlayerMask.ban_masks)
        pub ban_masks: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUSRMsg_VoiceMask.PlayerMask.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerMask {
        fn default() -> &'a PlayerMask {
            <PlayerMask as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerMask {
        pub fn new() -> PlayerMask {
            ::std::default::Default::default()
        }

        // optional int32 game_rules_mask = 1;

        pub fn game_rules_mask(&self) -> i32 {
            self.game_rules_mask.unwrap_or(0)
        }

        pub fn clear_game_rules_mask(&mut self) {
            self.game_rules_mask = ::std::option::Option::None;
        }

        pub fn has_game_rules_mask(&self) -> bool {
            self.game_rules_mask.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_rules_mask(&mut self, v: i32) {
            self.game_rules_mask = ::std::option::Option::Some(v);
        }

        // optional int32 ban_masks = 2;

        pub fn ban_masks(&self) -> i32 {
            self.ban_masks.unwrap_or(0)
        }

        pub fn clear_ban_masks(&mut self) {
            self.ban_masks = ::std::option::Option::None;
        }

        pub fn has_ban_masks(&self) -> bool {
            self.ban_masks.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ban_masks(&mut self, v: i32) {
            self.ban_masks = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_rules_mask",
                |m: &PlayerMask| { &m.game_rules_mask },
                |m: &mut PlayerMask| { &mut m.game_rules_mask },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ban_masks",
                |m: &PlayerMask| { &m.ban_masks },
                |m: &mut PlayerMask| { &mut m.ban_masks },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerMask>(
                "CUSRMsg_VoiceMask.PlayerMask",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerMask {
        const NAME: &'static str = "PlayerMask";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.game_rules_mask = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.ban_masks = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.game_rules_mask {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.ban_masks {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.game_rules_mask {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.ban_masks {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerMask {
            PlayerMask::new()
        }

        fn clear(&mut self) {
            self.game_rules_mask = ::std::option::Option::None;
            self.ban_masks = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerMask {
            static instance: PlayerMask = PlayerMask {
                game_rules_mask: ::std::option::Option::None,
                ban_masks: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerMask {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUSRMsg_VoiceMask.PlayerMask").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerMask {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerMask {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_Damage)
pub struct CUSRMsg_Damage {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_Damage.amount)
    pub amount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_Damage.inflictor_world_pos)
    pub inflictor_world_pos: ::protobuf::MessageField<super::netmessages::CMsgVector>,
    // @@protoc_insertion_point(field:CUSRMsg_Damage.victim_entindex)
    pub victim_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_Damage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_Damage {
    fn default() -> &'a CUSRMsg_Damage {
        <CUSRMsg_Damage as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_Damage {
    pub fn new() -> CUSRMsg_Damage {
        ::std::default::Default::default()
    }

    // optional int32 amount = 1;

    pub fn amount(&self) -> i32 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i32) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional int32 victim_entindex = 3;

    pub fn victim_entindex(&self) -> i32 {
        self.victim_entindex.unwrap_or(0)
    }

    pub fn clear_victim_entindex(&mut self) {
        self.victim_entindex = ::std::option::Option::None;
    }

    pub fn has_victim_entindex(&self) -> bool {
        self.victim_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_entindex(&mut self, v: i32) {
        self.victim_entindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount",
            |m: &CUSRMsg_Damage| { &m.amount },
            |m: &mut CUSRMsg_Damage| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::netmessages::CMsgVector>(
            "inflictor_world_pos",
            |m: &CUSRMsg_Damage| { &m.inflictor_world_pos },
            |m: &mut CUSRMsg_Damage| { &mut m.inflictor_world_pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "victim_entindex",
            |m: &CUSRMsg_Damage| { &m.victim_entindex },
            |m: &mut CUSRMsg_Damage| { &mut m.victim_entindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_Damage>(
            "CUSRMsg_Damage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_Damage {
    const NAME: &'static str = "CUSRMsg_Damage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.amount = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.inflictor_world_pos)?;
                },
                24 => {
                    self.victim_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.inflictor_world_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.victim_entindex {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.amount {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.inflictor_world_pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.victim_entindex {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_Damage {
        CUSRMsg_Damage::new()
    }

    fn clear(&mut self) {
        self.amount = ::std::option::Option::None;
        self.inflictor_world_pos.clear();
        self.victim_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_Damage {
        static instance: CUSRMsg_Damage = CUSRMsg_Damage {
            amount: ::std::option::Option::None,
            inflictor_world_pos: ::protobuf::MessageField::none(),
            victim_entindex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_Damage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_Damage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_Damage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_Damage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_RadioText)
pub struct CUSRMsg_RadioText {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_RadioText.msg_dst)
    pub msg_dst: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_RadioText.client)
    pub client: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_RadioText.msg_name)
    pub msg_name: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CUSRMsg_RadioText.params)
    pub params: ::std::vec::Vec<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_RadioText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_RadioText {
    fn default() -> &'a CUSRMsg_RadioText {
        <CUSRMsg_RadioText as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_RadioText {
    pub fn new() -> CUSRMsg_RadioText {
        ::std::default::Default::default()
    }

    // optional int32 msg_dst = 1;

    pub fn msg_dst(&self) -> i32 {
        self.msg_dst.unwrap_or(0)
    }

    pub fn clear_msg_dst(&mut self) {
        self.msg_dst = ::std::option::Option::None;
    }

    pub fn has_msg_dst(&self) -> bool {
        self.msg_dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_dst(&mut self, v: i32) {
        self.msg_dst = ::std::option::Option::Some(v);
    }

    // optional int32 client = 2;

    pub fn client(&self) -> i32 {
        self.client.unwrap_or(0)
    }

    pub fn clear_client(&mut self) {
        self.client = ::std::option::Option::None;
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: i32) {
        self.client = ::std::option::Option::Some(v);
    }

    // optional string msg_name = 3;

    pub fn msg_name(&self) -> &str {
        match self.msg_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_msg_name(&mut self) {
        self.msg_name = ::std::option::Option::None;
    }

    pub fn has_msg_name(&self) -> bool {
        self.msg_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_name(&mut self, v: ::protobuf::Chars) {
        self.msg_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_name(&mut self) -> &mut ::protobuf::Chars {
        if self.msg_name.is_none() {
            self.msg_name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.msg_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg_name(&mut self) -> ::protobuf::Chars {
        self.msg_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_dst",
            |m: &CUSRMsg_RadioText| { &m.msg_dst },
            |m: &mut CUSRMsg_RadioText| { &mut m.msg_dst },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client",
            |m: &CUSRMsg_RadioText| { &m.client },
            |m: &mut CUSRMsg_RadioText| { &mut m.client },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_name",
            |m: &CUSRMsg_RadioText| { &m.msg_name },
            |m: &mut CUSRMsg_RadioText| { &mut m.msg_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "params",
            |m: &CUSRMsg_RadioText| { &m.params },
            |m: &mut CUSRMsg_RadioText| { &mut m.params },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_RadioText>(
            "CUSRMsg_RadioText",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_RadioText {
    const NAME: &'static str = "CUSRMsg_RadioText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_dst = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.client = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.msg_name = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                34 => {
                    self.params.push(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_dst {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.client {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.msg_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.params {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_dst {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.client {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.msg_name.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.params {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_RadioText {
        CUSRMsg_RadioText::new()
    }

    fn clear(&mut self) {
        self.msg_dst = ::std::option::Option::None;
        self.client = ::std::option::Option::None;
        self.msg_name = ::std::option::Option::None;
        self.params.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_RadioText {
        static instance: CUSRMsg_RadioText = CUSRMsg_RadioText {
            msg_dst: ::std::option::Option::None,
            client: ::std::option::Option::None,
            msg_name: ::std::option::Option::None,
            params: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_RadioText {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_RadioText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_RadioText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_RadioText {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_HintText)
pub struct CUSRMsg_HintText {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_HintText.text)
    pub text: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_HintText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_HintText {
    fn default() -> &'a CUSRMsg_HintText {
        <CUSRMsg_HintText as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_HintText {
    pub fn new() -> CUSRMsg_HintText {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::protobuf::Chars) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::protobuf::Chars {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::protobuf::Chars {
        self.text.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CUSRMsg_HintText| { &m.text },
            |m: &mut CUSRMsg_HintText| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_HintText>(
            "CUSRMsg_HintText",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_HintText {
    const NAME: &'static str = "CUSRMsg_HintText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_HintText {
        CUSRMsg_HintText::new()
    }

    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_HintText {
        static instance: CUSRMsg_HintText = CUSRMsg_HintText {
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_HintText {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_HintText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_HintText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_HintText {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_KeyHintText)
pub struct CUSRMsg_KeyHintText {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_KeyHintText.hints)
    pub hints: ::std::vec::Vec<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_KeyHintText.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_KeyHintText {
    fn default() -> &'a CUSRMsg_KeyHintText {
        <CUSRMsg_KeyHintText as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_KeyHintText {
    pub fn new() -> CUSRMsg_KeyHintText {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "hints",
            |m: &CUSRMsg_KeyHintText| { &m.hints },
            |m: &mut CUSRMsg_KeyHintText| { &mut m.hints },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_KeyHintText>(
            "CUSRMsg_KeyHintText",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_KeyHintText {
    const NAME: &'static str = "CUSRMsg_KeyHintText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.hints.push(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hints {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.hints {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_KeyHintText {
        CUSRMsg_KeyHintText::new()
    }

    fn clear(&mut self) {
        self.hints.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_KeyHintText {
        static instance: CUSRMsg_KeyHintText = CUSRMsg_KeyHintText {
            hints: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_KeyHintText {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_KeyHintText").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_KeyHintText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_KeyHintText {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_ProcessSpottedEntityUpdate)
pub struct CUSRMsg_ProcessSpottedEntityUpdate {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_ProcessSpottedEntityUpdate.new_update)
    pub new_update: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUSRMsg_ProcessSpottedEntityUpdate.entity_updates)
    pub entity_updates: ::std::vec::Vec<cusrmsg_process_spotted_entity_update::SpottedEntityUpdate>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_ProcessSpottedEntityUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_ProcessSpottedEntityUpdate {
    fn default() -> &'a CUSRMsg_ProcessSpottedEntityUpdate {
        <CUSRMsg_ProcessSpottedEntityUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_ProcessSpottedEntityUpdate {
    pub fn new() -> CUSRMsg_ProcessSpottedEntityUpdate {
        ::std::default::Default::default()
    }

    // optional bool new_update = 1;

    pub fn new_update(&self) -> bool {
        self.new_update.unwrap_or(false)
    }

    pub fn clear_new_update(&mut self) {
        self.new_update = ::std::option::Option::None;
    }

    pub fn has_new_update(&self) -> bool {
        self.new_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_update(&mut self, v: bool) {
        self.new_update = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "new_update",
            |m: &CUSRMsg_ProcessSpottedEntityUpdate| { &m.new_update },
            |m: &mut CUSRMsg_ProcessSpottedEntityUpdate| { &mut m.new_update },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entity_updates",
            |m: &CUSRMsg_ProcessSpottedEntityUpdate| { &m.entity_updates },
            |m: &mut CUSRMsg_ProcessSpottedEntityUpdate| { &mut m.entity_updates },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_ProcessSpottedEntityUpdate>(
            "CUSRMsg_ProcessSpottedEntityUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_ProcessSpottedEntityUpdate {
    const NAME: &'static str = "CUSRMsg_ProcessSpottedEntityUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.new_update = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.entity_updates.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_update {
            my_size += 1 + 1;
        }
        for value in &self.entity_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.new_update {
            os.write_bool(1, v)?;
        }
        for v in &self.entity_updates {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_ProcessSpottedEntityUpdate {
        CUSRMsg_ProcessSpottedEntityUpdate::new()
    }

    fn clear(&mut self) {
        self.new_update = ::std::option::Option::None;
        self.entity_updates.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_ProcessSpottedEntityUpdate {
        static instance: CUSRMsg_ProcessSpottedEntityUpdate = CUSRMsg_ProcessSpottedEntityUpdate {
            new_update: ::std::option::Option::None,
            entity_updates: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_ProcessSpottedEntityUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_ProcessSpottedEntityUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_ProcessSpottedEntityUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_ProcessSpottedEntityUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CUSRMsg_ProcessSpottedEntityUpdate`
pub mod cusrmsg_process_spotted_entity_update {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CUSRMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate)
    pub struct SpottedEntityUpdate {
        // message fields
        // @@protoc_insertion_point(field:CUSRMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.entity_idx)
        pub entity_idx: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.class_id)
        pub class_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.origin_x)
        pub origin_x: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.origin_y)
        pub origin_y: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.origin_z)
        pub origin_z: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.angle_y)
        pub angle_y: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.defusr)
        pub defusr: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CUSRMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.player_has_defusr)
        pub player_has_defusr: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CUSRMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.player_has_c4)
        pub player_has_c4: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CUSRMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SpottedEntityUpdate {
        fn default() -> &'a SpottedEntityUpdate {
            <SpottedEntityUpdate as ::protobuf::Message>::default_instance()
        }
    }

    impl SpottedEntityUpdate {
        pub fn new() -> SpottedEntityUpdate {
            ::std::default::Default::default()
        }

        // optional int32 entity_idx = 1;

        pub fn entity_idx(&self) -> i32 {
            self.entity_idx.unwrap_or(0)
        }

        pub fn clear_entity_idx(&mut self) {
            self.entity_idx = ::std::option::Option::None;
        }

        pub fn has_entity_idx(&self) -> bool {
            self.entity_idx.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_idx(&mut self, v: i32) {
            self.entity_idx = ::std::option::Option::Some(v);
        }

        // optional int32 class_id = 2;

        pub fn class_id(&self) -> i32 {
            self.class_id.unwrap_or(0)
        }

        pub fn clear_class_id(&mut self) {
            self.class_id = ::std::option::Option::None;
        }

        pub fn has_class_id(&self) -> bool {
            self.class_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_class_id(&mut self, v: i32) {
            self.class_id = ::std::option::Option::Some(v);
        }

        // optional int32 origin_x = 3;

        pub fn origin_x(&self) -> i32 {
            self.origin_x.unwrap_or(0)
        }

        pub fn clear_origin_x(&mut self) {
            self.origin_x = ::std::option::Option::None;
        }

        pub fn has_origin_x(&self) -> bool {
            self.origin_x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_x(&mut self, v: i32) {
            self.origin_x = ::std::option::Option::Some(v);
        }

        // optional int32 origin_y = 4;

        pub fn origin_y(&self) -> i32 {
            self.origin_y.unwrap_or(0)
        }

        pub fn clear_origin_y(&mut self) {
            self.origin_y = ::std::option::Option::None;
        }

        pub fn has_origin_y(&self) -> bool {
            self.origin_y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_y(&mut self, v: i32) {
            self.origin_y = ::std::option::Option::Some(v);
        }

        // optional int32 origin_z = 5;

        pub fn origin_z(&self) -> i32 {
            self.origin_z.unwrap_or(0)
        }

        pub fn clear_origin_z(&mut self) {
            self.origin_z = ::std::option::Option::None;
        }

        pub fn has_origin_z(&self) -> bool {
            self.origin_z.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_z(&mut self, v: i32) {
            self.origin_z = ::std::option::Option::Some(v);
        }

        // optional int32 angle_y = 6;

        pub fn angle_y(&self) -> i32 {
            self.angle_y.unwrap_or(0)
        }

        pub fn clear_angle_y(&mut self) {
            self.angle_y = ::std::option::Option::None;
        }

        pub fn has_angle_y(&self) -> bool {
            self.angle_y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_angle_y(&mut self, v: i32) {
            self.angle_y = ::std::option::Option::Some(v);
        }

        // optional bool defusr = 7;

        pub fn defusr(&self) -> bool {
            self.defusr.unwrap_or(false)
        }

        pub fn clear_defusr(&mut self) {
            self.defusr = ::std::option::Option::None;
        }

        pub fn has_defusr(&self) -> bool {
            self.defusr.is_some()
        }

        // Param is passed by value, moved
        pub fn set_defusr(&mut self, v: bool) {
            self.defusr = ::std::option::Option::Some(v);
        }

        // optional bool player_has_defusr = 8;

        pub fn player_has_defusr(&self) -> bool {
            self.player_has_defusr.unwrap_or(false)
        }

        pub fn clear_player_has_defusr(&mut self) {
            self.player_has_defusr = ::std::option::Option::None;
        }

        pub fn has_player_has_defusr(&self) -> bool {
            self.player_has_defusr.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_has_defusr(&mut self, v: bool) {
            self.player_has_defusr = ::std::option::Option::Some(v);
        }

        // optional bool player_has_c4 = 9;

        pub fn player_has_c4(&self) -> bool {
            self.player_has_c4.unwrap_or(false)
        }

        pub fn clear_player_has_c4(&mut self) {
            self.player_has_c4 = ::std::option::Option::None;
        }

        pub fn has_player_has_c4(&self) -> bool {
            self.player_has_c4.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_has_c4(&mut self, v: bool) {
            self.player_has_c4 = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entity_idx",
                |m: &SpottedEntityUpdate| { &m.entity_idx },
                |m: &mut SpottedEntityUpdate| { &mut m.entity_idx },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "class_id",
                |m: &SpottedEntityUpdate| { &m.class_id },
                |m: &mut SpottedEntityUpdate| { &mut m.class_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "origin_x",
                |m: &SpottedEntityUpdate| { &m.origin_x },
                |m: &mut SpottedEntityUpdate| { &mut m.origin_x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "origin_y",
                |m: &SpottedEntityUpdate| { &m.origin_y },
                |m: &mut SpottedEntityUpdate| { &mut m.origin_y },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "origin_z",
                |m: &SpottedEntityUpdate| { &m.origin_z },
                |m: &mut SpottedEntityUpdate| { &mut m.origin_z },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "angle_y",
                |m: &SpottedEntityUpdate| { &m.angle_y },
                |m: &mut SpottedEntityUpdate| { &mut m.angle_y },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "defusr",
                |m: &SpottedEntityUpdate| { &m.defusr },
                |m: &mut SpottedEntityUpdate| { &mut m.defusr },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_has_defusr",
                |m: &SpottedEntityUpdate| { &m.player_has_defusr },
                |m: &mut SpottedEntityUpdate| { &mut m.player_has_defusr },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_has_c4",
                |m: &SpottedEntityUpdate| { &m.player_has_c4 },
                |m: &mut SpottedEntityUpdate| { &mut m.player_has_c4 },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SpottedEntityUpdate>(
                "CUSRMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SpottedEntityUpdate {
        const NAME: &'static str = "SpottedEntityUpdate";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.entity_idx = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.class_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.origin_x = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.origin_y = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.origin_z = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.angle_y = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.defusr = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.player_has_defusr = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.player_has_c4 = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.entity_idx {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.class_id {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.origin_x {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.origin_y {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.origin_z {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.angle_y {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.defusr {
                my_size += 1 + 1;
            }
            if let Some(v) = self.player_has_defusr {
                my_size += 1 + 1;
            }
            if let Some(v) = self.player_has_c4 {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.entity_idx {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.class_id {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.origin_x {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.origin_y {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.origin_z {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.angle_y {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.defusr {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.player_has_defusr {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.player_has_c4 {
                os.write_bool(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SpottedEntityUpdate {
            SpottedEntityUpdate::new()
        }

        fn clear(&mut self) {
            self.entity_idx = ::std::option::Option::None;
            self.class_id = ::std::option::Option::None;
            self.origin_x = ::std::option::Option::None;
            self.origin_y = ::std::option::Option::None;
            self.origin_z = ::std::option::Option::None;
            self.angle_y = ::std::option::Option::None;
            self.defusr = ::std::option::Option::None;
            self.player_has_defusr = ::std::option::Option::None;
            self.player_has_c4 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SpottedEntityUpdate {
            static instance: SpottedEntityUpdate = SpottedEntityUpdate {
                entity_idx: ::std::option::Option::None,
                class_id: ::std::option::Option::None,
                origin_x: ::std::option::Option::None,
                origin_y: ::std::option::Option::None,
                origin_z: ::std::option::Option::None,
                angle_y: ::std::option::Option::None,
                defusr: ::std::option::Option::None,
                player_has_defusr: ::std::option::Option::None,
                player_has_c4: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SpottedEntityUpdate {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUSRMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SpottedEntityUpdate {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SpottedEntityUpdate {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_SendPlayerItemDrops)
pub struct CUSRMsg_SendPlayerItemDrops {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_SendPlayerItemDrops.entity_updates)
    pub entity_updates: ::std::vec::Vec<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_SendPlayerItemDrops.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_SendPlayerItemDrops {
    fn default() -> &'a CUSRMsg_SendPlayerItemDrops {
        <CUSRMsg_SendPlayerItemDrops as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_SendPlayerItemDrops {
    pub fn new() -> CUSRMsg_SendPlayerItemDrops {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entity_updates",
            |m: &CUSRMsg_SendPlayerItemDrops| { &m.entity_updates },
            |m: &mut CUSRMsg_SendPlayerItemDrops| { &mut m.entity_updates },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_SendPlayerItemDrops>(
            "CUSRMsg_SendPlayerItemDrops",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_SendPlayerItemDrops {
    const NAME: &'static str = "CUSRMsg_SendPlayerItemDrops";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entity_updates.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entity_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.entity_updates {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_SendPlayerItemDrops {
        CUSRMsg_SendPlayerItemDrops::new()
    }

    fn clear(&mut self) {
        self.entity_updates.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_SendPlayerItemDrops {
        static instance: CUSRMsg_SendPlayerItemDrops = CUSRMsg_SendPlayerItemDrops {
            entity_updates: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_SendPlayerItemDrops {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_SendPlayerItemDrops").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_SendPlayerItemDrops {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_SendPlayerItemDrops {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_SendPlayerItemFound)
pub struct CUSRMsg_SendPlayerItemFound {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_SendPlayerItemFound.iteminfo)
    pub iteminfo: ::protobuf::MessageField<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>,
    // @@protoc_insertion_point(field:CUSRMsg_SendPlayerItemFound.entindex)
    pub entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_SendPlayerItemFound.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_SendPlayerItemFound {
    fn default() -> &'a CUSRMsg_SendPlayerItemFound {
        <CUSRMsg_SendPlayerItemFound as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_SendPlayerItemFound {
    pub fn new() -> CUSRMsg_SendPlayerItemFound {
        ::std::default::Default::default()
    }

    // optional int32 entindex = 2;

    pub fn entindex(&self) -> i32 {
        self.entindex.unwrap_or(0)
    }

    pub fn clear_entindex(&mut self) {
        self.entindex = ::std::option::Option::None;
    }

    pub fn has_entindex(&self) -> bool {
        self.entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entindex(&mut self, v: i32) {
        self.entindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::cstrike15_gcmessages::CEconItemPreviewDataBlock>(
            "iteminfo",
            |m: &CUSRMsg_SendPlayerItemFound| { &m.iteminfo },
            |m: &mut CUSRMsg_SendPlayerItemFound| { &mut m.iteminfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entindex",
            |m: &CUSRMsg_SendPlayerItemFound| { &m.entindex },
            |m: &mut CUSRMsg_SendPlayerItemFound| { &mut m.entindex },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_SendPlayerItemFound>(
            "CUSRMsg_SendPlayerItemFound",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_SendPlayerItemFound {
    const NAME: &'static str = "CUSRMsg_SendPlayerItemFound";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.iteminfo)?;
                },
                16 => {
                    self.entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.entindex {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.iteminfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.entindex {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_SendPlayerItemFound {
        CUSRMsg_SendPlayerItemFound::new()
    }

    fn clear(&mut self) {
        self.iteminfo.clear();
        self.entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_SendPlayerItemFound {
        static instance: CUSRMsg_SendPlayerItemFound = CUSRMsg_SendPlayerItemFound {
            iteminfo: ::protobuf::MessageField::none(),
            entindex: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_SendPlayerItemFound {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_SendPlayerItemFound").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_SendPlayerItemFound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_SendPlayerItemFound {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_ReloadEffect)
pub struct CUSRMsg_ReloadEffect {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_ReloadEffect.entidx)
    pub entidx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_ReloadEffect.actanim)
    pub actanim: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_ReloadEffect.origin_x)
    pub origin_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_ReloadEffect.origin_y)
    pub origin_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_ReloadEffect.origin_z)
    pub origin_z: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_ReloadEffect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_ReloadEffect {
    fn default() -> &'a CUSRMsg_ReloadEffect {
        <CUSRMsg_ReloadEffect as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_ReloadEffect {
    pub fn new() -> CUSRMsg_ReloadEffect {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;

    pub fn entidx(&self) -> i32 {
        self.entidx.unwrap_or(0)
    }

    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional int32 actanim = 2;

    pub fn actanim(&self) -> i32 {
        self.actanim.unwrap_or(0)
    }

    pub fn clear_actanim(&mut self) {
        self.actanim = ::std::option::Option::None;
    }

    pub fn has_actanim(&self) -> bool {
        self.actanim.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actanim(&mut self, v: i32) {
        self.actanim = ::std::option::Option::Some(v);
    }

    // optional float origin_x = 3;

    pub fn origin_x(&self) -> f32 {
        self.origin_x.unwrap_or(0.)
    }

    pub fn clear_origin_x(&mut self) {
        self.origin_x = ::std::option::Option::None;
    }

    pub fn has_origin_x(&self) -> bool {
        self.origin_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_x(&mut self, v: f32) {
        self.origin_x = ::std::option::Option::Some(v);
    }

    // optional float origin_y = 4;

    pub fn origin_y(&self) -> f32 {
        self.origin_y.unwrap_or(0.)
    }

    pub fn clear_origin_y(&mut self) {
        self.origin_y = ::std::option::Option::None;
    }

    pub fn has_origin_y(&self) -> bool {
        self.origin_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_y(&mut self, v: f32) {
        self.origin_y = ::std::option::Option::Some(v);
    }

    // optional float origin_z = 5;

    pub fn origin_z(&self) -> f32 {
        self.origin_z.unwrap_or(0.)
    }

    pub fn clear_origin_z(&mut self) {
        self.origin_z = ::std::option::Option::None;
    }

    pub fn has_origin_z(&self) -> bool {
        self.origin_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_z(&mut self, v: f32) {
        self.origin_z = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entidx",
            |m: &CUSRMsg_ReloadEffect| { &m.entidx },
            |m: &mut CUSRMsg_ReloadEffect| { &mut m.entidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "actanim",
            |m: &CUSRMsg_ReloadEffect| { &m.actanim },
            |m: &mut CUSRMsg_ReloadEffect| { &mut m.actanim },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin_x",
            |m: &CUSRMsg_ReloadEffect| { &m.origin_x },
            |m: &mut CUSRMsg_ReloadEffect| { &mut m.origin_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin_y",
            |m: &CUSRMsg_ReloadEffect| { &m.origin_y },
            |m: &mut CUSRMsg_ReloadEffect| { &mut m.origin_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin_z",
            |m: &CUSRMsg_ReloadEffect| { &m.origin_z },
            |m: &mut CUSRMsg_ReloadEffect| { &mut m.origin_z },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_ReloadEffect>(
            "CUSRMsg_ReloadEffect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_ReloadEffect {
    const NAME: &'static str = "CUSRMsg_ReloadEffect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entidx = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.actanim = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.origin_x = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.origin_y = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.origin_z = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.actanim {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.origin_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.origin_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.origin_z {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.actanim {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.origin_x {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.origin_y {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.origin_z {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_ReloadEffect {
        CUSRMsg_ReloadEffect::new()
    }

    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.actanim = ::std::option::Option::None;
        self.origin_x = ::std::option::Option::None;
        self.origin_y = ::std::option::Option::None;
        self.origin_z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_ReloadEffect {
        static instance: CUSRMsg_ReloadEffect = CUSRMsg_ReloadEffect {
            entidx: ::std::option::Option::None,
            actanim: ::std::option::Option::None,
            origin_x: ::std::option::Option::None,
            origin_y: ::std::option::Option::None,
            origin_z: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_ReloadEffect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_ReloadEffect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_ReloadEffect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_ReloadEffect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_WeaponSound)
pub struct CUSRMsg_WeaponSound {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_WeaponSound.entidx)
    pub entidx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_WeaponSound.origin_x)
    pub origin_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_WeaponSound.origin_y)
    pub origin_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_WeaponSound.origin_z)
    pub origin_z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_WeaponSound.sound)
    pub sound: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CUSRMsg_WeaponSound.timestamp)
    pub timestamp: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_WeaponSound.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_WeaponSound {
    fn default() -> &'a CUSRMsg_WeaponSound {
        <CUSRMsg_WeaponSound as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_WeaponSound {
    pub fn new() -> CUSRMsg_WeaponSound {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;

    pub fn entidx(&self) -> i32 {
        self.entidx.unwrap_or(0)
    }

    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional float origin_x = 2;

    pub fn origin_x(&self) -> f32 {
        self.origin_x.unwrap_or(0.)
    }

    pub fn clear_origin_x(&mut self) {
        self.origin_x = ::std::option::Option::None;
    }

    pub fn has_origin_x(&self) -> bool {
        self.origin_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_x(&mut self, v: f32) {
        self.origin_x = ::std::option::Option::Some(v);
    }

    // optional float origin_y = 3;

    pub fn origin_y(&self) -> f32 {
        self.origin_y.unwrap_or(0.)
    }

    pub fn clear_origin_y(&mut self) {
        self.origin_y = ::std::option::Option::None;
    }

    pub fn has_origin_y(&self) -> bool {
        self.origin_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_y(&mut self, v: f32) {
        self.origin_y = ::std::option::Option::Some(v);
    }

    // optional float origin_z = 4;

    pub fn origin_z(&self) -> f32 {
        self.origin_z.unwrap_or(0.)
    }

    pub fn clear_origin_z(&mut self) {
        self.origin_z = ::std::option::Option::None;
    }

    pub fn has_origin_z(&self) -> bool {
        self.origin_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_z(&mut self, v: f32) {
        self.origin_z = ::std::option::Option::Some(v);
    }

    // optional string sound = 5;

    pub fn sound(&self) -> &str {
        match self.sound.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sound(&mut self) {
        self.sound = ::std::option::Option::None;
    }

    pub fn has_sound(&self) -> bool {
        self.sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sound(&mut self, v: ::protobuf::Chars) {
        self.sound = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sound(&mut self) -> &mut ::protobuf::Chars {
        if self.sound.is_none() {
            self.sound = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_sound(&mut self) -> ::protobuf::Chars {
        self.sound.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional float timestamp = 6;

    pub fn timestamp(&self) -> f32 {
        self.timestamp.unwrap_or(0.)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entidx",
            |m: &CUSRMsg_WeaponSound| { &m.entidx },
            |m: &mut CUSRMsg_WeaponSound| { &mut m.entidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin_x",
            |m: &CUSRMsg_WeaponSound| { &m.origin_x },
            |m: &mut CUSRMsg_WeaponSound| { &mut m.origin_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin_y",
            |m: &CUSRMsg_WeaponSound| { &m.origin_y },
            |m: &mut CUSRMsg_WeaponSound| { &mut m.origin_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin_z",
            |m: &CUSRMsg_WeaponSound| { &m.origin_z },
            |m: &mut CUSRMsg_WeaponSound| { &mut m.origin_z },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sound",
            |m: &CUSRMsg_WeaponSound| { &m.sound },
            |m: &mut CUSRMsg_WeaponSound| { &mut m.sound },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CUSRMsg_WeaponSound| { &m.timestamp },
            |m: &mut CUSRMsg_WeaponSound| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_WeaponSound>(
            "CUSRMsg_WeaponSound",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_WeaponSound {
    const NAME: &'static str = "CUSRMsg_WeaponSound";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entidx = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.origin_x = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.origin_y = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.origin_z = ::std::option::Option::Some(is.read_float()?);
                },
                42 => {
                    self.sound = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                53 => {
                    self.timestamp = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.origin_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.origin_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.origin_z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.sound.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.timestamp {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.origin_x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.origin_y {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.origin_z {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.sound.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_float(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_WeaponSound {
        CUSRMsg_WeaponSound::new()
    }

    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.origin_x = ::std::option::Option::None;
        self.origin_y = ::std::option::Option::None;
        self.origin_z = ::std::option::Option::None;
        self.sound = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_WeaponSound {
        static instance: CUSRMsg_WeaponSound = CUSRMsg_WeaponSound {
            entidx: ::std::option::Option::None,
            origin_x: ::std::option::Option::None,
            origin_y: ::std::option::Option::None,
            origin_z: ::std::option::Option::None,
            sound: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_WeaponSound {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_WeaponSound").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_WeaponSound {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_WeaponSound {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_UpdateScreenHealthBar)
pub struct CUSRMsg_UpdateScreenHealthBar {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_UpdateScreenHealthBar.entidx)
    pub entidx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_UpdateScreenHealthBar.healthratio_old)
    pub healthratio_old: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_UpdateScreenHealthBar.healthratio_new)
    pub healthratio_new: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_UpdateScreenHealthBar.style)
    pub style: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_UpdateScreenHealthBar.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_UpdateScreenHealthBar {
    fn default() -> &'a CUSRMsg_UpdateScreenHealthBar {
        <CUSRMsg_UpdateScreenHealthBar as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_UpdateScreenHealthBar {
    pub fn new() -> CUSRMsg_UpdateScreenHealthBar {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;

    pub fn entidx(&self) -> i32 {
        self.entidx.unwrap_or(0)
    }

    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional float healthratio_old = 2;

    pub fn healthratio_old(&self) -> f32 {
        self.healthratio_old.unwrap_or(0.)
    }

    pub fn clear_healthratio_old(&mut self) {
        self.healthratio_old = ::std::option::Option::None;
    }

    pub fn has_healthratio_old(&self) -> bool {
        self.healthratio_old.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthratio_old(&mut self, v: f32) {
        self.healthratio_old = ::std::option::Option::Some(v);
    }

    // optional float healthratio_new = 3;

    pub fn healthratio_new(&self) -> f32 {
        self.healthratio_new.unwrap_or(0.)
    }

    pub fn clear_healthratio_new(&mut self) {
        self.healthratio_new = ::std::option::Option::None;
    }

    pub fn has_healthratio_new(&self) -> bool {
        self.healthratio_new.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthratio_new(&mut self, v: f32) {
        self.healthratio_new = ::std::option::Option::Some(v);
    }

    // optional int32 style = 4;

    pub fn style(&self) -> i32 {
        self.style.unwrap_or(0)
    }

    pub fn clear_style(&mut self) {
        self.style = ::std::option::Option::None;
    }

    pub fn has_style(&self) -> bool {
        self.style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style(&mut self, v: i32) {
        self.style = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entidx",
            |m: &CUSRMsg_UpdateScreenHealthBar| { &m.entidx },
            |m: &mut CUSRMsg_UpdateScreenHealthBar| { &mut m.entidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "healthratio_old",
            |m: &CUSRMsg_UpdateScreenHealthBar| { &m.healthratio_old },
            |m: &mut CUSRMsg_UpdateScreenHealthBar| { &mut m.healthratio_old },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "healthratio_new",
            |m: &CUSRMsg_UpdateScreenHealthBar| { &m.healthratio_new },
            |m: &mut CUSRMsg_UpdateScreenHealthBar| { &mut m.healthratio_new },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "style",
            |m: &CUSRMsg_UpdateScreenHealthBar| { &m.style },
            |m: &mut CUSRMsg_UpdateScreenHealthBar| { &mut m.style },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_UpdateScreenHealthBar>(
            "CUSRMsg_UpdateScreenHealthBar",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_UpdateScreenHealthBar {
    const NAME: &'static str = "CUSRMsg_UpdateScreenHealthBar";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entidx = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.healthratio_old = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.healthratio_new = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.style = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.healthratio_old {
            my_size += 1 + 4;
        }
        if let Some(v) = self.healthratio_new {
            my_size += 1 + 4;
        }
        if let Some(v) = self.style {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.healthratio_old {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.healthratio_new {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.style {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_UpdateScreenHealthBar {
        CUSRMsg_UpdateScreenHealthBar::new()
    }

    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.healthratio_old = ::std::option::Option::None;
        self.healthratio_new = ::std::option::Option::None;
        self.style = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_UpdateScreenHealthBar {
        static instance: CUSRMsg_UpdateScreenHealthBar = CUSRMsg_UpdateScreenHealthBar {
            entidx: ::std::option::Option::None,
            healthratio_old: ::std::option::Option::None,
            healthratio_new: ::std::option::Option::None,
            style: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_UpdateScreenHealthBar {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_UpdateScreenHealthBar").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_UpdateScreenHealthBar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_UpdateScreenHealthBar {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_EntityOutlineHighlight)
pub struct CUSRMsg_EntityOutlineHighlight {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_EntityOutlineHighlight.entidx)
    pub entidx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_EntityOutlineHighlight.removehighlight)
    pub removehighlight: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_EntityOutlineHighlight.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_EntityOutlineHighlight {
    fn default() -> &'a CUSRMsg_EntityOutlineHighlight {
        <CUSRMsg_EntityOutlineHighlight as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_EntityOutlineHighlight {
    pub fn new() -> CUSRMsg_EntityOutlineHighlight {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;

    pub fn entidx(&self) -> i32 {
        self.entidx.unwrap_or(0)
    }

    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional bool removehighlight = 2;

    pub fn removehighlight(&self) -> bool {
        self.removehighlight.unwrap_or(false)
    }

    pub fn clear_removehighlight(&mut self) {
        self.removehighlight = ::std::option::Option::None;
    }

    pub fn has_removehighlight(&self) -> bool {
        self.removehighlight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_removehighlight(&mut self, v: bool) {
        self.removehighlight = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entidx",
            |m: &CUSRMsg_EntityOutlineHighlight| { &m.entidx },
            |m: &mut CUSRMsg_EntityOutlineHighlight| { &mut m.entidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "removehighlight",
            |m: &CUSRMsg_EntityOutlineHighlight| { &m.removehighlight },
            |m: &mut CUSRMsg_EntityOutlineHighlight| { &mut m.removehighlight },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_EntityOutlineHighlight>(
            "CUSRMsg_EntityOutlineHighlight",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_EntityOutlineHighlight {
    const NAME: &'static str = "CUSRMsg_EntityOutlineHighlight";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entidx = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.removehighlight = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.removehighlight {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.removehighlight {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_EntityOutlineHighlight {
        CUSRMsg_EntityOutlineHighlight::new()
    }

    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.removehighlight = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_EntityOutlineHighlight {
        static instance: CUSRMsg_EntityOutlineHighlight = CUSRMsg_EntityOutlineHighlight {
            entidx: ::std::option::Option::None,
            removehighlight: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_EntityOutlineHighlight {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_EntityOutlineHighlight").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_EntityOutlineHighlight {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_EntityOutlineHighlight {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_AdjustMoney)
pub struct CUSRMsg_AdjustMoney {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_AdjustMoney.amount)
    pub amount: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_AdjustMoney.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_AdjustMoney {
    fn default() -> &'a CUSRMsg_AdjustMoney {
        <CUSRMsg_AdjustMoney as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_AdjustMoney {
    pub fn new() -> CUSRMsg_AdjustMoney {
        ::std::default::Default::default()
    }

    // optional int32 amount = 1;

    pub fn amount(&self) -> i32 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i32) {
        self.amount = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "amount",
            |m: &CUSRMsg_AdjustMoney| { &m.amount },
            |m: &mut CUSRMsg_AdjustMoney| { &mut m.amount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_AdjustMoney>(
            "CUSRMsg_AdjustMoney",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_AdjustMoney {
    const NAME: &'static str = "CUSRMsg_AdjustMoney";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.amount = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.amount {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.amount {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_AdjustMoney {
        CUSRMsg_AdjustMoney::new()
    }

    fn clear(&mut self) {
        self.amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_AdjustMoney {
        static instance: CUSRMsg_AdjustMoney = CUSRMsg_AdjustMoney {
            amount: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_AdjustMoney {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_AdjustMoney").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_AdjustMoney {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_AdjustMoney {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_ReportHit)
pub struct CUSRMsg_ReportHit {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_ReportHit.pos_x)
    pub pos_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_ReportHit.pos_y)
    pub pos_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_ReportHit.timestamp)
    pub timestamp: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_ReportHit.pos_z)
    pub pos_z: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_ReportHit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_ReportHit {
    fn default() -> &'a CUSRMsg_ReportHit {
        <CUSRMsg_ReportHit as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_ReportHit {
    pub fn new() -> CUSRMsg_ReportHit {
        ::std::default::Default::default()
    }

    // optional float pos_x = 1;

    pub fn pos_x(&self) -> f32 {
        self.pos_x.unwrap_or(0.)
    }

    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: f32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // optional float pos_y = 2;

    pub fn pos_y(&self) -> f32 {
        self.pos_y.unwrap_or(0.)
    }

    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: f32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // optional float timestamp = 4;

    pub fn timestamp(&self) -> f32 {
        self.timestamp.unwrap_or(0.)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional float pos_z = 3;

    pub fn pos_z(&self) -> f32 {
        self.pos_z.unwrap_or(0.)
    }

    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: f32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_x",
            |m: &CUSRMsg_ReportHit| { &m.pos_x },
            |m: &mut CUSRMsg_ReportHit| { &mut m.pos_x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_y",
            |m: &CUSRMsg_ReportHit| { &m.pos_y },
            |m: &mut CUSRMsg_ReportHit| { &mut m.pos_y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CUSRMsg_ReportHit| { &m.timestamp },
            |m: &mut CUSRMsg_ReportHit| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pos_z",
            |m: &CUSRMsg_ReportHit| { &m.pos_z },
            |m: &mut CUSRMsg_ReportHit| { &mut m.pos_z },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_ReportHit>(
            "CUSRMsg_ReportHit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_ReportHit {
    const NAME: &'static str = "CUSRMsg_ReportHit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.pos_x = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.pos_y = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.timestamp = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.pos_z = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_z {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pos_x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_ReportHit {
        CUSRMsg_ReportHit::new()
    }

    fn clear(&mut self) {
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_ReportHit {
        static instance: CUSRMsg_ReportHit = CUSRMsg_ReportHit {
            pos_x: ::std::option::Option::None,
            pos_y: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            pos_z: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_ReportHit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_ReportHit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_ReportHit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_ReportHit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_KillCam)
pub struct CUSRMsg_KillCam {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_KillCam.obs_mode)
    pub obs_mode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_KillCam.first_target)
    pub first_target: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_KillCam.second_target)
    pub second_target: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_KillCam.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_KillCam {
    fn default() -> &'a CUSRMsg_KillCam {
        <CUSRMsg_KillCam as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_KillCam {
    pub fn new() -> CUSRMsg_KillCam {
        ::std::default::Default::default()
    }

    // optional int32 obs_mode = 1;

    pub fn obs_mode(&self) -> i32 {
        self.obs_mode.unwrap_or(0)
    }

    pub fn clear_obs_mode(&mut self) {
        self.obs_mode = ::std::option::Option::None;
    }

    pub fn has_obs_mode(&self) -> bool {
        self.obs_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_obs_mode(&mut self, v: i32) {
        self.obs_mode = ::std::option::Option::Some(v);
    }

    // optional int32 first_target = 2;

    pub fn first_target(&self) -> i32 {
        self.first_target.unwrap_or(0)
    }

    pub fn clear_first_target(&mut self) {
        self.first_target = ::std::option::Option::None;
    }

    pub fn has_first_target(&self) -> bool {
        self.first_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_target(&mut self, v: i32) {
        self.first_target = ::std::option::Option::Some(v);
    }

    // optional int32 second_target = 3;

    pub fn second_target(&self) -> i32 {
        self.second_target.unwrap_or(0)
    }

    pub fn clear_second_target(&mut self) {
        self.second_target = ::std::option::Option::None;
    }

    pub fn has_second_target(&self) -> bool {
        self.second_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_second_target(&mut self, v: i32) {
        self.second_target = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "obs_mode",
            |m: &CUSRMsg_KillCam| { &m.obs_mode },
            |m: &mut CUSRMsg_KillCam| { &mut m.obs_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "first_target",
            |m: &CUSRMsg_KillCam| { &m.first_target },
            |m: &mut CUSRMsg_KillCam| { &mut m.first_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "second_target",
            |m: &CUSRMsg_KillCam| { &m.second_target },
            |m: &mut CUSRMsg_KillCam| { &mut m.second_target },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_KillCam>(
            "CUSRMsg_KillCam",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_KillCam {
    const NAME: &'static str = "CUSRMsg_KillCam";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.obs_mode = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.first_target = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.second_target = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.obs_mode {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.first_target {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.second_target {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.obs_mode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.first_target {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.second_target {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_KillCam {
        CUSRMsg_KillCam::new()
    }

    fn clear(&mut self) {
        self.obs_mode = ::std::option::Option::None;
        self.first_target = ::std::option::Option::None;
        self.second_target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_KillCam {
        static instance: CUSRMsg_KillCam = CUSRMsg_KillCam {
            obs_mode: ::std::option::Option::None,
            first_target: ::std::option::Option::None,
            second_target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_KillCam {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_KillCam").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_KillCam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_KillCam {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_DesiredTimescale)
pub struct CUSRMsg_DesiredTimescale {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_DesiredTimescale.desired_timescale)
    pub desired_timescale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_DesiredTimescale.duration_realtime_sec)
    pub duration_realtime_sec: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_DesiredTimescale.interpolator_type)
    pub interpolator_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_DesiredTimescale.start_blend_time)
    pub start_blend_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_DesiredTimescale.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_DesiredTimescale {
    fn default() -> &'a CUSRMsg_DesiredTimescale {
        <CUSRMsg_DesiredTimescale as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_DesiredTimescale {
    pub fn new() -> CUSRMsg_DesiredTimescale {
        ::std::default::Default::default()
    }

    // optional float desired_timescale = 1;

    pub fn desired_timescale(&self) -> f32 {
        self.desired_timescale.unwrap_or(0.)
    }

    pub fn clear_desired_timescale(&mut self) {
        self.desired_timescale = ::std::option::Option::None;
    }

    pub fn has_desired_timescale(&self) -> bool {
        self.desired_timescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_timescale(&mut self, v: f32) {
        self.desired_timescale = ::std::option::Option::Some(v);
    }

    // optional float duration_realtime_sec = 2;

    pub fn duration_realtime_sec(&self) -> f32 {
        self.duration_realtime_sec.unwrap_or(0.)
    }

    pub fn clear_duration_realtime_sec(&mut self) {
        self.duration_realtime_sec = ::std::option::Option::None;
    }

    pub fn has_duration_realtime_sec(&self) -> bool {
        self.duration_realtime_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_realtime_sec(&mut self, v: f32) {
        self.duration_realtime_sec = ::std::option::Option::Some(v);
    }

    // optional int32 interpolator_type = 3;

    pub fn interpolator_type(&self) -> i32 {
        self.interpolator_type.unwrap_or(0)
    }

    pub fn clear_interpolator_type(&mut self) {
        self.interpolator_type = ::std::option::Option::None;
    }

    pub fn has_interpolator_type(&self) -> bool {
        self.interpolator_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interpolator_type(&mut self, v: i32) {
        self.interpolator_type = ::std::option::Option::Some(v);
    }

    // optional float start_blend_time = 4;

    pub fn start_blend_time(&self) -> f32 {
        self.start_blend_time.unwrap_or(0.)
    }

    pub fn clear_start_blend_time(&mut self) {
        self.start_blend_time = ::std::option::Option::None;
    }

    pub fn has_start_blend_time(&self) -> bool {
        self.start_blend_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_blend_time(&mut self, v: f32) {
        self.start_blend_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desired_timescale",
            |m: &CUSRMsg_DesiredTimescale| { &m.desired_timescale },
            |m: &mut CUSRMsg_DesiredTimescale| { &mut m.desired_timescale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "duration_realtime_sec",
            |m: &CUSRMsg_DesiredTimescale| { &m.duration_realtime_sec },
            |m: &mut CUSRMsg_DesiredTimescale| { &mut m.duration_realtime_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "interpolator_type",
            |m: &CUSRMsg_DesiredTimescale| { &m.interpolator_type },
            |m: &mut CUSRMsg_DesiredTimescale| { &mut m.interpolator_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_blend_time",
            |m: &CUSRMsg_DesiredTimescale| { &m.start_blend_time },
            |m: &mut CUSRMsg_DesiredTimescale| { &mut m.start_blend_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_DesiredTimescale>(
            "CUSRMsg_DesiredTimescale",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_DesiredTimescale {
    const NAME: &'static str = "CUSRMsg_DesiredTimescale";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.desired_timescale = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.duration_realtime_sec = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.interpolator_type = ::std::option::Option::Some(is.read_int32()?);
                },
                37 => {
                    self.start_blend_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.desired_timescale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration_realtime_sec {
            my_size += 1 + 4;
        }
        if let Some(v) = self.interpolator_type {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.start_blend_time {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.desired_timescale {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.duration_realtime_sec {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.interpolator_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.start_blend_time {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_DesiredTimescale {
        CUSRMsg_DesiredTimescale::new()
    }

    fn clear(&mut self) {
        self.desired_timescale = ::std::option::Option::None;
        self.duration_realtime_sec = ::std::option::Option::None;
        self.interpolator_type = ::std::option::Option::None;
        self.start_blend_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_DesiredTimescale {
        static instance: CUSRMsg_DesiredTimescale = CUSRMsg_DesiredTimescale {
            desired_timescale: ::std::option::Option::None,
            duration_realtime_sec: ::std::option::Option::None,
            interpolator_type: ::std::option::Option::None,
            start_blend_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_DesiredTimescale {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_DesiredTimescale").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_DesiredTimescale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_DesiredTimescale {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_CurrentTimescale)
pub struct CUSRMsg_CurrentTimescale {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_CurrentTimescale.cur_timescale)
    pub cur_timescale: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_CurrentTimescale.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_CurrentTimescale {
    fn default() -> &'a CUSRMsg_CurrentTimescale {
        <CUSRMsg_CurrentTimescale as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_CurrentTimescale {
    pub fn new() -> CUSRMsg_CurrentTimescale {
        ::std::default::Default::default()
    }

    // optional float cur_timescale = 1;

    pub fn cur_timescale(&self) -> f32 {
        self.cur_timescale.unwrap_or(0.)
    }

    pub fn clear_cur_timescale(&mut self) {
        self.cur_timescale = ::std::option::Option::None;
    }

    pub fn has_cur_timescale(&self) -> bool {
        self.cur_timescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cur_timescale(&mut self, v: f32) {
        self.cur_timescale = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cur_timescale",
            |m: &CUSRMsg_CurrentTimescale| { &m.cur_timescale },
            |m: &mut CUSRMsg_CurrentTimescale| { &mut m.cur_timescale },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_CurrentTimescale>(
            "CUSRMsg_CurrentTimescale",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_CurrentTimescale {
    const NAME: &'static str = "CUSRMsg_CurrentTimescale";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.cur_timescale = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cur_timescale {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cur_timescale {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_CurrentTimescale {
        CUSRMsg_CurrentTimescale::new()
    }

    fn clear(&mut self) {
        self.cur_timescale = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_CurrentTimescale {
        static instance: CUSRMsg_CurrentTimescale = CUSRMsg_CurrentTimescale {
            cur_timescale: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_CurrentTimescale {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_CurrentTimescale").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_CurrentTimescale {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_CurrentTimescale {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_AchievementEvent)
pub struct CUSRMsg_AchievementEvent {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_AchievementEvent.achievement)
    pub achievement: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_AchievementEvent.count)
    pub count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_AchievementEvent.usr_id)
    pub usr_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_AchievementEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_AchievementEvent {
    fn default() -> &'a CUSRMsg_AchievementEvent {
        <CUSRMsg_AchievementEvent as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_AchievementEvent {
    pub fn new() -> CUSRMsg_AchievementEvent {
        ::std::default::Default::default()
    }

    // optional int32 achievement = 1;

    pub fn achievement(&self) -> i32 {
        self.achievement.unwrap_or(0)
    }

    pub fn clear_achievement(&mut self) {
        self.achievement = ::std::option::Option::None;
    }

    pub fn has_achievement(&self) -> bool {
        self.achievement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement(&mut self, v: i32) {
        self.achievement = ::std::option::Option::Some(v);
    }

    // optional int32 count = 2;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional int32 usr_id = 3;

    pub fn usr_id(&self) -> i32 {
        self.usr_id.unwrap_or(0)
    }

    pub fn clear_usr_id(&mut self) {
        self.usr_id = ::std::option::Option::None;
    }

    pub fn has_usr_id(&self) -> bool {
        self.usr_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usr_id(&mut self, v: i32) {
        self.usr_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "achievement",
            |m: &CUSRMsg_AchievementEvent| { &m.achievement },
            |m: &mut CUSRMsg_AchievementEvent| { &mut m.achievement },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &CUSRMsg_AchievementEvent| { &m.count },
            |m: &mut CUSRMsg_AchievementEvent| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "usr_id",
            |m: &CUSRMsg_AchievementEvent| { &m.usr_id },
            |m: &mut CUSRMsg_AchievementEvent| { &mut m.usr_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_AchievementEvent>(
            "CUSRMsg_AchievementEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_AchievementEvent {
    const NAME: &'static str = "CUSRMsg_AchievementEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.achievement = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.usr_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.achievement {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.usr_id {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.achievement {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.usr_id {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_AchievementEvent {
        CUSRMsg_AchievementEvent::new()
    }

    fn clear(&mut self) {
        self.achievement = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.usr_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_AchievementEvent {
        static instance: CUSRMsg_AchievementEvent = CUSRMsg_AchievementEvent {
            achievement: ::std::option::Option::None,
            count: ::std::option::Option::None,
            usr_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_AchievementEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_AchievementEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_AchievementEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_AchievementEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_MatchEndConditions)
pub struct CUSRMsg_MatchEndConditions {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_MatchEndConditions.fraglimit)
    pub fraglimit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_MatchEndConditions.mp_maxrounds)
    pub mp_maxrounds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_MatchEndConditions.mp_winlimit)
    pub mp_winlimit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_MatchEndConditions.mp_timelimit)
    pub mp_timelimit: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_MatchEndConditions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_MatchEndConditions {
    fn default() -> &'a CUSRMsg_MatchEndConditions {
        <CUSRMsg_MatchEndConditions as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_MatchEndConditions {
    pub fn new() -> CUSRMsg_MatchEndConditions {
        ::std::default::Default::default()
    }

    // optional int32 fraglimit = 1;

    pub fn fraglimit(&self) -> i32 {
        self.fraglimit.unwrap_or(0)
    }

    pub fn clear_fraglimit(&mut self) {
        self.fraglimit = ::std::option::Option::None;
    }

    pub fn has_fraglimit(&self) -> bool {
        self.fraglimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fraglimit(&mut self, v: i32) {
        self.fraglimit = ::std::option::Option::Some(v);
    }

    // optional int32 mp_maxrounds = 2;

    pub fn mp_maxrounds(&self) -> i32 {
        self.mp_maxrounds.unwrap_or(0)
    }

    pub fn clear_mp_maxrounds(&mut self) {
        self.mp_maxrounds = ::std::option::Option::None;
    }

    pub fn has_mp_maxrounds(&self) -> bool {
        self.mp_maxrounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mp_maxrounds(&mut self, v: i32) {
        self.mp_maxrounds = ::std::option::Option::Some(v);
    }

    // optional int32 mp_winlimit = 3;

    pub fn mp_winlimit(&self) -> i32 {
        self.mp_winlimit.unwrap_or(0)
    }

    pub fn clear_mp_winlimit(&mut self) {
        self.mp_winlimit = ::std::option::Option::None;
    }

    pub fn has_mp_winlimit(&self) -> bool {
        self.mp_winlimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mp_winlimit(&mut self, v: i32) {
        self.mp_winlimit = ::std::option::Option::Some(v);
    }

    // optional int32 mp_timelimit = 4;

    pub fn mp_timelimit(&self) -> i32 {
        self.mp_timelimit.unwrap_or(0)
    }

    pub fn clear_mp_timelimit(&mut self) {
        self.mp_timelimit = ::std::option::Option::None;
    }

    pub fn has_mp_timelimit(&self) -> bool {
        self.mp_timelimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mp_timelimit(&mut self, v: i32) {
        self.mp_timelimit = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fraglimit",
            |m: &CUSRMsg_MatchEndConditions| { &m.fraglimit },
            |m: &mut CUSRMsg_MatchEndConditions| { &mut m.fraglimit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mp_maxrounds",
            |m: &CUSRMsg_MatchEndConditions| { &m.mp_maxrounds },
            |m: &mut CUSRMsg_MatchEndConditions| { &mut m.mp_maxrounds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mp_winlimit",
            |m: &CUSRMsg_MatchEndConditions| { &m.mp_winlimit },
            |m: &mut CUSRMsg_MatchEndConditions| { &mut m.mp_winlimit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mp_timelimit",
            |m: &CUSRMsg_MatchEndConditions| { &m.mp_timelimit },
            |m: &mut CUSRMsg_MatchEndConditions| { &mut m.mp_timelimit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_MatchEndConditions>(
            "CUSRMsg_MatchEndConditions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_MatchEndConditions {
    const NAME: &'static str = "CUSRMsg_MatchEndConditions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fraglimit = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.mp_maxrounds = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.mp_winlimit = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.mp_timelimit = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fraglimit {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.mp_maxrounds {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.mp_winlimit {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.mp_timelimit {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.fraglimit {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.mp_maxrounds {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.mp_winlimit {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.mp_timelimit {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_MatchEndConditions {
        CUSRMsg_MatchEndConditions::new()
    }

    fn clear(&mut self) {
        self.fraglimit = ::std::option::Option::None;
        self.mp_maxrounds = ::std::option::Option::None;
        self.mp_winlimit = ::std::option::Option::None;
        self.mp_timelimit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_MatchEndConditions {
        static instance: CUSRMsg_MatchEndConditions = CUSRMsg_MatchEndConditions {
            fraglimit: ::std::option::Option::None,
            mp_maxrounds: ::std::option::Option::None,
            mp_winlimit: ::std::option::Option::None,
            mp_timelimit: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_MatchEndConditions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_MatchEndConditions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_MatchEndConditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_MatchEndConditions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_PlayerStatsUpdate)
pub struct CUSRMsg_PlayerStatsUpdate {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_PlayerStatsUpdate.version)
    pub version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_PlayerStatsUpdate.stats)
    pub stats: ::std::vec::Vec<cusrmsg_player_stats_update::Stat>,
    // @@protoc_insertion_point(field:CUSRMsg_PlayerStatsUpdate.usr_id)
    pub usr_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_PlayerStatsUpdate.crc)
    pub crc: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_PlayerStatsUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_PlayerStatsUpdate {
    fn default() -> &'a CUSRMsg_PlayerStatsUpdate {
        <CUSRMsg_PlayerStatsUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_PlayerStatsUpdate {
    pub fn new() -> CUSRMsg_PlayerStatsUpdate {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional int32 usr_id = 5;

    pub fn usr_id(&self) -> i32 {
        self.usr_id.unwrap_or(0)
    }

    pub fn clear_usr_id(&mut self) {
        self.usr_id = ::std::option::Option::None;
    }

    pub fn has_usr_id(&self) -> bool {
        self.usr_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usr_id(&mut self, v: i32) {
        self.usr_id = ::std::option::Option::Some(v);
    }

    // optional int32 crc = 6;

    pub fn crc(&self) -> i32 {
        self.crc.unwrap_or(0)
    }

    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: i32) {
        self.crc = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CUSRMsg_PlayerStatsUpdate| { &m.version },
            |m: &mut CUSRMsg_PlayerStatsUpdate| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stats",
            |m: &CUSRMsg_PlayerStatsUpdate| { &m.stats },
            |m: &mut CUSRMsg_PlayerStatsUpdate| { &mut m.stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "usr_id",
            |m: &CUSRMsg_PlayerStatsUpdate| { &m.usr_id },
            |m: &mut CUSRMsg_PlayerStatsUpdate| { &mut m.usr_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crc",
            |m: &CUSRMsg_PlayerStatsUpdate| { &m.crc },
            |m: &mut CUSRMsg_PlayerStatsUpdate| { &mut m.crc },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_PlayerStatsUpdate>(
            "CUSRMsg_PlayerStatsUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_PlayerStatsUpdate {
    const NAME: &'static str = "CUSRMsg_PlayerStatsUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.stats.push(is.read_message()?);
                },
                40 => {
                    self.usr_id = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.crc = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.usr_id {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.crc {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        for v in &self.stats {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.usr_id {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.crc {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_PlayerStatsUpdate {
        CUSRMsg_PlayerStatsUpdate::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.stats.clear();
        self.usr_id = ::std::option::Option::None;
        self.crc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_PlayerStatsUpdate {
        static instance: CUSRMsg_PlayerStatsUpdate = CUSRMsg_PlayerStatsUpdate {
            version: ::std::option::Option::None,
            stats: ::std::vec::Vec::new(),
            usr_id: ::std::option::Option::None,
            crc: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_PlayerStatsUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_PlayerStatsUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_PlayerStatsUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_PlayerStatsUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CUSRMsg_PlayerStatsUpdate`
pub mod cusrmsg_player_stats_update {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CUSRMsg_PlayerStatsUpdate.Stat)
    pub struct Stat {
        // message fields
        // @@protoc_insertion_point(field:CUSRMsg_PlayerStatsUpdate.Stat.idx)
        pub idx: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_PlayerStatsUpdate.Stat.delta)
        pub delta: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUSRMsg_PlayerStatsUpdate.Stat.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stat {
        fn default() -> &'a Stat {
            <Stat as ::protobuf::Message>::default_instance()
        }
    }

    impl Stat {
        pub fn new() -> Stat {
            ::std::default::Default::default()
        }

        // optional int32 idx = 1;

        pub fn idx(&self) -> i32 {
            self.idx.unwrap_or(0)
        }

        pub fn clear_idx(&mut self) {
            self.idx = ::std::option::Option::None;
        }

        pub fn has_idx(&self) -> bool {
            self.idx.is_some()
        }

        // Param is passed by value, moved
        pub fn set_idx(&mut self, v: i32) {
            self.idx = ::std::option::Option::Some(v);
        }

        // optional int32 delta = 2;

        pub fn delta(&self) -> i32 {
            self.delta.unwrap_or(0)
        }

        pub fn clear_delta(&mut self) {
            self.delta = ::std::option::Option::None;
        }

        pub fn has_delta(&self) -> bool {
            self.delta.is_some()
        }

        // Param is passed by value, moved
        pub fn set_delta(&mut self, v: i32) {
            self.delta = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "idx",
                |m: &Stat| { &m.idx },
                |m: &mut Stat| { &mut m.idx },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "delta",
                |m: &Stat| { &m.delta },
                |m: &mut Stat| { &mut m.delta },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Stat>(
                "CUSRMsg_PlayerStatsUpdate.Stat",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Stat {
        const NAME: &'static str = "Stat";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.idx = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.delta = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.idx {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.delta {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.idx {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.delta {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stat {
            Stat::new()
        }

        fn clear(&mut self) {
            self.idx = ::std::option::Option::None;
            self.delta = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stat {
            static instance: Stat = Stat {
                idx: ::std::option::Option::None,
                delta: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Stat {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUSRMsg_PlayerStatsUpdate.Stat").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Stat {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Stat {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_DisplayInventory)
pub struct CUSRMsg_DisplayInventory {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_DisplayInventory.display)
    pub display: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUSRMsg_DisplayInventory.usr_id)
    pub usr_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_DisplayInventory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_DisplayInventory {
    fn default() -> &'a CUSRMsg_DisplayInventory {
        <CUSRMsg_DisplayInventory as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_DisplayInventory {
    pub fn new() -> CUSRMsg_DisplayInventory {
        ::std::default::Default::default()
    }

    // optional bool display = 1;

    pub fn display(&self) -> bool {
        self.display.unwrap_or(false)
    }

    pub fn clear_display(&mut self) {
        self.display = ::std::option::Option::None;
    }

    pub fn has_display(&self) -> bool {
        self.display.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display(&mut self, v: bool) {
        self.display = ::std::option::Option::Some(v);
    }

    // optional int32 usr_id = 2;

    pub fn usr_id(&self) -> i32 {
        self.usr_id.unwrap_or(0)
    }

    pub fn clear_usr_id(&mut self) {
        self.usr_id = ::std::option::Option::None;
    }

    pub fn has_usr_id(&self) -> bool {
        self.usr_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usr_id(&mut self, v: i32) {
        self.usr_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display",
            |m: &CUSRMsg_DisplayInventory| { &m.display },
            |m: &mut CUSRMsg_DisplayInventory| { &mut m.display },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "usr_id",
            |m: &CUSRMsg_DisplayInventory| { &m.usr_id },
            |m: &mut CUSRMsg_DisplayInventory| { &mut m.usr_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_DisplayInventory>(
            "CUSRMsg_DisplayInventory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_DisplayInventory {
    const NAME: &'static str = "CUSRMsg_DisplayInventory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.display = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.usr_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.display {
            my_size += 1 + 1;
        }
        if let Some(v) = self.usr_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.display {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.usr_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_DisplayInventory {
        CUSRMsg_DisplayInventory::new()
    }

    fn clear(&mut self) {
        self.display = ::std::option::Option::None;
        self.usr_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_DisplayInventory {
        static instance: CUSRMsg_DisplayInventory = CUSRMsg_DisplayInventory {
            display: ::std::option::Option::None,
            usr_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_DisplayInventory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_DisplayInventory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_DisplayInventory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_DisplayInventory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_QuestProgress)
pub struct CUSRMsg_QuestProgress {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_QuestProgress.quest_id)
    pub quest_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUSRMsg_QuestProgress.normal_points)
    pub normal_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUSRMsg_QuestProgress.bonus_points)
    pub bonus_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUSRMsg_QuestProgress.is_event_quest)
    pub is_event_quest: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_QuestProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_QuestProgress {
    fn default() -> &'a CUSRMsg_QuestProgress {
        <CUSRMsg_QuestProgress as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_QuestProgress {
    pub fn new() -> CUSRMsg_QuestProgress {
        ::std::default::Default::default()
    }

    // optional uint32 quest_id = 1;

    pub fn quest_id(&self) -> u32 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u32) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 normal_points = 2;

    pub fn normal_points(&self) -> u32 {
        self.normal_points.unwrap_or(0)
    }

    pub fn clear_normal_points(&mut self) {
        self.normal_points = ::std::option::Option::None;
    }

    pub fn has_normal_points(&self) -> bool {
        self.normal_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normal_points(&mut self, v: u32) {
        self.normal_points = ::std::option::Option::Some(v);
    }

    // optional uint32 bonus_points = 3;

    pub fn bonus_points(&self) -> u32 {
        self.bonus_points.unwrap_or(0)
    }

    pub fn clear_bonus_points(&mut self) {
        self.bonus_points = ::std::option::Option::None;
    }

    pub fn has_bonus_points(&self) -> bool {
        self.bonus_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_points(&mut self, v: u32) {
        self.bonus_points = ::std::option::Option::Some(v);
    }

    // optional bool is_event_quest = 4;

    pub fn is_event_quest(&self) -> bool {
        self.is_event_quest.unwrap_or(false)
    }

    pub fn clear_is_event_quest(&mut self) {
        self.is_event_quest = ::std::option::Option::None;
    }

    pub fn has_is_event_quest(&self) -> bool {
        self.is_event_quest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_event_quest(&mut self, v: bool) {
        self.is_event_quest = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_id",
            |m: &CUSRMsg_QuestProgress| { &m.quest_id },
            |m: &mut CUSRMsg_QuestProgress| { &mut m.quest_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "normal_points",
            |m: &CUSRMsg_QuestProgress| { &m.normal_points },
            |m: &mut CUSRMsg_QuestProgress| { &mut m.normal_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bonus_points",
            |m: &CUSRMsg_QuestProgress| { &m.bonus_points },
            |m: &mut CUSRMsg_QuestProgress| { &mut m.bonus_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_event_quest",
            |m: &CUSRMsg_QuestProgress| { &m.is_event_quest },
            |m: &mut CUSRMsg_QuestProgress| { &mut m.is_event_quest },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_QuestProgress>(
            "CUSRMsg_QuestProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_QuestProgress {
    const NAME: &'static str = "CUSRMsg_QuestProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.normal_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.bonus_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.is_event_quest = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.normal_points {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.bonus_points {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.is_event_quest {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.normal_points {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bonus_points {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.is_event_quest {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_QuestProgress {
        CUSRMsg_QuestProgress::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.normal_points = ::std::option::Option::None;
        self.bonus_points = ::std::option::Option::None;
        self.is_event_quest = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_QuestProgress {
        static instance: CUSRMsg_QuestProgress = CUSRMsg_QuestProgress {
            quest_id: ::std::option::Option::None,
            normal_points: ::std::option::Option::None,
            bonus_points: ::std::option::Option::None,
            is_event_quest: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_QuestProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_QuestProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_QuestProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_QuestProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_ScoreLeaderboardData)
pub struct CUSRMsg_ScoreLeaderboardData {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_ScoreLeaderboardData.data)
    pub data: ::protobuf::MessageField<super::cstrike15_gcmessages::ScoreLeaderboardData>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_ScoreLeaderboardData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_ScoreLeaderboardData {
    fn default() -> &'a CUSRMsg_ScoreLeaderboardData {
        <CUSRMsg_ScoreLeaderboardData as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_ScoreLeaderboardData {
    pub fn new() -> CUSRMsg_ScoreLeaderboardData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::cstrike15_gcmessages::ScoreLeaderboardData>(
            "data",
            |m: &CUSRMsg_ScoreLeaderboardData| { &m.data },
            |m: &mut CUSRMsg_ScoreLeaderboardData| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_ScoreLeaderboardData>(
            "CUSRMsg_ScoreLeaderboardData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_ScoreLeaderboardData {
    const NAME: &'static str = "CUSRMsg_ScoreLeaderboardData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_ScoreLeaderboardData {
        CUSRMsg_ScoreLeaderboardData::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_ScoreLeaderboardData {
        static instance: CUSRMsg_ScoreLeaderboardData = CUSRMsg_ScoreLeaderboardData {
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_ScoreLeaderboardData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_ScoreLeaderboardData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_ScoreLeaderboardData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_ScoreLeaderboardData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_PlayerDecalDigitalSignature)
pub struct CUSRMsg_PlayerDecalDigitalSignature {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_PlayerDecalDigitalSignature.data)
    pub data: ::protobuf::MessageField<super::cstrike15_gcmessages::PlayerDecalDigitalSignature>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_PlayerDecalDigitalSignature.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_PlayerDecalDigitalSignature {
    fn default() -> &'a CUSRMsg_PlayerDecalDigitalSignature {
        <CUSRMsg_PlayerDecalDigitalSignature as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_PlayerDecalDigitalSignature {
    pub fn new() -> CUSRMsg_PlayerDecalDigitalSignature {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::cstrike15_gcmessages::PlayerDecalDigitalSignature>(
            "data",
            |m: &CUSRMsg_PlayerDecalDigitalSignature| { &m.data },
            |m: &mut CUSRMsg_PlayerDecalDigitalSignature| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_PlayerDecalDigitalSignature>(
            "CUSRMsg_PlayerDecalDigitalSignature",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_PlayerDecalDigitalSignature {
    const NAME: &'static str = "CUSRMsg_PlayerDecalDigitalSignature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_PlayerDecalDigitalSignature {
        CUSRMsg_PlayerDecalDigitalSignature::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_PlayerDecalDigitalSignature {
        static instance: CUSRMsg_PlayerDecalDigitalSignature = CUSRMsg_PlayerDecalDigitalSignature {
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_PlayerDecalDigitalSignature {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_PlayerDecalDigitalSignature").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_PlayerDecalDigitalSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_PlayerDecalDigitalSignature {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_XRankGet)
pub struct CUSRMsg_XRankGet {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_XRankGet.mode_idx)
    pub mode_idx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_XRankGet.controller)
    pub controller: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_XRankGet.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_XRankGet {
    fn default() -> &'a CUSRMsg_XRankGet {
        <CUSRMsg_XRankGet as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_XRankGet {
    pub fn new() -> CUSRMsg_XRankGet {
        ::std::default::Default::default()
    }

    // optional int32 mode_idx = 1;

    pub fn mode_idx(&self) -> i32 {
        self.mode_idx.unwrap_or(0)
    }

    pub fn clear_mode_idx(&mut self) {
        self.mode_idx = ::std::option::Option::None;
    }

    pub fn has_mode_idx(&self) -> bool {
        self.mode_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode_idx(&mut self, v: i32) {
        self.mode_idx = ::std::option::Option::Some(v);
    }

    // optional int32 controller = 2;

    pub fn controller(&self) -> i32 {
        self.controller.unwrap_or(0)
    }

    pub fn clear_controller(&mut self) {
        self.controller = ::std::option::Option::None;
    }

    pub fn has_controller(&self) -> bool {
        self.controller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller(&mut self, v: i32) {
        self.controller = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mode_idx",
            |m: &CUSRMsg_XRankGet| { &m.mode_idx },
            |m: &mut CUSRMsg_XRankGet| { &mut m.mode_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller",
            |m: &CUSRMsg_XRankGet| { &m.controller },
            |m: &mut CUSRMsg_XRankGet| { &mut m.controller },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_XRankGet>(
            "CUSRMsg_XRankGet",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_XRankGet {
    const NAME: &'static str = "CUSRMsg_XRankGet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode_idx = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.controller = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mode_idx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.controller {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mode_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.controller {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_XRankGet {
        CUSRMsg_XRankGet::new()
    }

    fn clear(&mut self) {
        self.mode_idx = ::std::option::Option::None;
        self.controller = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_XRankGet {
        static instance: CUSRMsg_XRankGet = CUSRMsg_XRankGet {
            mode_idx: ::std::option::Option::None,
            controller: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_XRankGet {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_XRankGet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_XRankGet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_XRankGet {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_XRankUpd)
pub struct CUSRMsg_XRankUpd {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_XRankUpd.mode_idx)
    pub mode_idx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_XRankUpd.controller)
    pub controller: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_XRankUpd.ranking)
    pub ranking: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_XRankUpd.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_XRankUpd {
    fn default() -> &'a CUSRMsg_XRankUpd {
        <CUSRMsg_XRankUpd as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_XRankUpd {
    pub fn new() -> CUSRMsg_XRankUpd {
        ::std::default::Default::default()
    }

    // optional int32 mode_idx = 1;

    pub fn mode_idx(&self) -> i32 {
        self.mode_idx.unwrap_or(0)
    }

    pub fn clear_mode_idx(&mut self) {
        self.mode_idx = ::std::option::Option::None;
    }

    pub fn has_mode_idx(&self) -> bool {
        self.mode_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode_idx(&mut self, v: i32) {
        self.mode_idx = ::std::option::Option::Some(v);
    }

    // optional int32 controller = 2;

    pub fn controller(&self) -> i32 {
        self.controller.unwrap_or(0)
    }

    pub fn clear_controller(&mut self) {
        self.controller = ::std::option::Option::None;
    }

    pub fn has_controller(&self) -> bool {
        self.controller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller(&mut self, v: i32) {
        self.controller = ::std::option::Option::Some(v);
    }

    // optional int32 ranking = 3;

    pub fn ranking(&self) -> i32 {
        self.ranking.unwrap_or(0)
    }

    pub fn clear_ranking(&mut self) {
        self.ranking = ::std::option::Option::None;
    }

    pub fn has_ranking(&self) -> bool {
        self.ranking.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranking(&mut self, v: i32) {
        self.ranking = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mode_idx",
            |m: &CUSRMsg_XRankUpd| { &m.mode_idx },
            |m: &mut CUSRMsg_XRankUpd| { &mut m.mode_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "controller",
            |m: &CUSRMsg_XRankUpd| { &m.controller },
            |m: &mut CUSRMsg_XRankUpd| { &mut m.controller },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ranking",
            |m: &CUSRMsg_XRankUpd| { &m.ranking },
            |m: &mut CUSRMsg_XRankUpd| { &mut m.ranking },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_XRankUpd>(
            "CUSRMsg_XRankUpd",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_XRankUpd {
    const NAME: &'static str = "CUSRMsg_XRankUpd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode_idx = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.controller = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.ranking = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mode_idx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.controller {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.ranking {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mode_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.controller {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ranking {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_XRankUpd {
        CUSRMsg_XRankUpd::new()
    }

    fn clear(&mut self) {
        self.mode_idx = ::std::option::Option::None;
        self.controller = ::std::option::Option::None;
        self.ranking = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_XRankUpd {
        static instance: CUSRMsg_XRankUpd = CUSRMsg_XRankUpd {
            mode_idx: ::std::option::Option::None,
            controller: ::std::option::Option::None,
            ranking: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_XRankUpd {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_XRankUpd").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_XRankUpd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_XRankUpd {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_CallVoteFailed)
pub struct CUSRMsg_CallVoteFailed {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_CallVoteFailed.reason)
    pub reason: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_CallVoteFailed.time)
    pub time: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_CallVoteFailed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_CallVoteFailed {
    fn default() -> &'a CUSRMsg_CallVoteFailed {
        <CUSRMsg_CallVoteFailed as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_CallVoteFailed {
    pub fn new() -> CUSRMsg_CallVoteFailed {
        ::std::default::Default::default()
    }

    // optional int32 reason = 1;

    pub fn reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: i32) {
        self.reason = ::std::option::Option::Some(v);
    }

    // optional int32 time = 2;

    pub fn time(&self) -> i32 {
        self.time.unwrap_or(0)
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i32) {
        self.time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CUSRMsg_CallVoteFailed| { &m.reason },
            |m: &mut CUSRMsg_CallVoteFailed| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time",
            |m: &CUSRMsg_CallVoteFailed| { &m.time },
            |m: &mut CUSRMsg_CallVoteFailed| { &mut m.time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_CallVoteFailed>(
            "CUSRMsg_CallVoteFailed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_CallVoteFailed {
    const NAME: &'static str = "CUSRMsg_CallVoteFailed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reason = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.time = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.time {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reason {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.time {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_CallVoteFailed {
        CUSRMsg_CallVoteFailed::new()
    }

    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_CallVoteFailed {
        static instance: CUSRMsg_CallVoteFailed = CUSRMsg_CallVoteFailed {
            reason: ::std::option::Option::None,
            time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_CallVoteFailed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_CallVoteFailed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_CallVoteFailed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_CallVoteFailed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_VoteStart)
pub struct CUSRMsg_VoteStart {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_VoteStart.team)
    pub team: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_VoteStart.ent_idx)
    pub ent_idx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_VoteStart.vote_type)
    pub vote_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_VoteStart.disp_str)
    pub disp_str: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CUSRMsg_VoteStart.details_str)
    pub details_str: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CUSRMsg_VoteStart.other_team_str)
    pub other_team_str: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CUSRMsg_VoteStart.is_yes_no_vote)
    pub is_yes_no_vote: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUSRMsg_VoteStart.entidx_target)
    pub entidx_target: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_VoteStart.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_VoteStart {
    fn default() -> &'a CUSRMsg_VoteStart {
        <CUSRMsg_VoteStart as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_VoteStart {
    pub fn new() -> CUSRMsg_VoteStart {
        ::std::default::Default::default()
    }

    // optional int32 team = 1;

    pub fn team(&self) -> i32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional int32 ent_idx = 2;

    pub fn ent_idx(&self) -> i32 {
        self.ent_idx.unwrap_or(0)
    }

    pub fn clear_ent_idx(&mut self) {
        self.ent_idx = ::std::option::Option::None;
    }

    pub fn has_ent_idx(&self) -> bool {
        self.ent_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_idx(&mut self, v: i32) {
        self.ent_idx = ::std::option::Option::Some(v);
    }

    // optional int32 vote_type = 3;

    pub fn vote_type(&self) -> i32 {
        self.vote_type.unwrap_or(0)
    }

    pub fn clear_vote_type(&mut self) {
        self.vote_type = ::std::option::Option::None;
    }

    pub fn has_vote_type(&self) -> bool {
        self.vote_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_type(&mut self, v: i32) {
        self.vote_type = ::std::option::Option::Some(v);
    }

    // optional string disp_str = 4;

    pub fn disp_str(&self) -> &str {
        match self.disp_str.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_disp_str(&mut self) {
        self.disp_str = ::std::option::Option::None;
    }

    pub fn has_disp_str(&self) -> bool {
        self.disp_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disp_str(&mut self, v: ::protobuf::Chars) {
        self.disp_str = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disp_str(&mut self) -> &mut ::protobuf::Chars {
        if self.disp_str.is_none() {
            self.disp_str = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.disp_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_disp_str(&mut self) -> ::protobuf::Chars {
        self.disp_str.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional string details_str = 5;

    pub fn details_str(&self) -> &str {
        match self.details_str.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_details_str(&mut self) {
        self.details_str = ::std::option::Option::None;
    }

    pub fn has_details_str(&self) -> bool {
        self.details_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details_str(&mut self, v: ::protobuf::Chars) {
        self.details_str = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details_str(&mut self) -> &mut ::protobuf::Chars {
        if self.details_str.is_none() {
            self.details_str = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.details_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_details_str(&mut self) -> ::protobuf::Chars {
        self.details_str.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional string other_team_str = 6;

    pub fn other_team_str(&self) -> &str {
        match self.other_team_str.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_other_team_str(&mut self) {
        self.other_team_str = ::std::option::Option::None;
    }

    pub fn has_other_team_str(&self) -> bool {
        self.other_team_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_team_str(&mut self, v: ::protobuf::Chars) {
        self.other_team_str = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_other_team_str(&mut self) -> &mut ::protobuf::Chars {
        if self.other_team_str.is_none() {
            self.other_team_str = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.other_team_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_other_team_str(&mut self) -> ::protobuf::Chars {
        self.other_team_str.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional bool is_yes_no_vote = 7;

    pub fn is_yes_no_vote(&self) -> bool {
        self.is_yes_no_vote.unwrap_or(false)
    }

    pub fn clear_is_yes_no_vote(&mut self) {
        self.is_yes_no_vote = ::std::option::Option::None;
    }

    pub fn has_is_yes_no_vote(&self) -> bool {
        self.is_yes_no_vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_yes_no_vote(&mut self, v: bool) {
        self.is_yes_no_vote = ::std::option::Option::Some(v);
    }

    // optional int32 entidx_target = 8;

    pub fn entidx_target(&self) -> i32 {
        self.entidx_target.unwrap_or(0)
    }

    pub fn clear_entidx_target(&mut self) {
        self.entidx_target = ::std::option::Option::None;
    }

    pub fn has_entidx_target(&self) -> bool {
        self.entidx_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx_target(&mut self, v: i32) {
        self.entidx_target = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CUSRMsg_VoteStart| { &m.team },
            |m: &mut CUSRMsg_VoteStart| { &mut m.team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ent_idx",
            |m: &CUSRMsg_VoteStart| { &m.ent_idx },
            |m: &mut CUSRMsg_VoteStart| { &mut m.ent_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vote_type",
            |m: &CUSRMsg_VoteStart| { &m.vote_type },
            |m: &mut CUSRMsg_VoteStart| { &mut m.vote_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disp_str",
            |m: &CUSRMsg_VoteStart| { &m.disp_str },
            |m: &mut CUSRMsg_VoteStart| { &mut m.disp_str },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "details_str",
            |m: &CUSRMsg_VoteStart| { &m.details_str },
            |m: &mut CUSRMsg_VoteStart| { &mut m.details_str },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "other_team_str",
            |m: &CUSRMsg_VoteStart| { &m.other_team_str },
            |m: &mut CUSRMsg_VoteStart| { &mut m.other_team_str },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_yes_no_vote",
            |m: &CUSRMsg_VoteStart| { &m.is_yes_no_vote },
            |m: &mut CUSRMsg_VoteStart| { &mut m.is_yes_no_vote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entidx_target",
            |m: &CUSRMsg_VoteStart| { &m.entidx_target },
            |m: &mut CUSRMsg_VoteStart| { &mut m.entidx_target },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_VoteStart>(
            "CUSRMsg_VoteStart",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_VoteStart {
    const NAME: &'static str = "CUSRMsg_VoteStart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.ent_idx = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.vote_type = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.disp_str = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                42 => {
                    self.details_str = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                50 => {
                    self.other_team_str = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                56 => {
                    self.is_yes_no_vote = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.entidx_target = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.ent_idx {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.vote_type {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.disp_str.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.details_str.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.other_team_str.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.is_yes_no_vote {
            my_size += 1 + 1;
        }
        if let Some(v) = self.entidx_target {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.ent_idx {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.vote_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.disp_str.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.details_str.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.other_team_str.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.is_yes_no_vote {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.entidx_target {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_VoteStart {
        CUSRMsg_VoteStart::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.ent_idx = ::std::option::Option::None;
        self.vote_type = ::std::option::Option::None;
        self.disp_str = ::std::option::Option::None;
        self.details_str = ::std::option::Option::None;
        self.other_team_str = ::std::option::Option::None;
        self.is_yes_no_vote = ::std::option::Option::None;
        self.entidx_target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_VoteStart {
        static instance: CUSRMsg_VoteStart = CUSRMsg_VoteStart {
            team: ::std::option::Option::None,
            ent_idx: ::std::option::Option::None,
            vote_type: ::std::option::Option::None,
            disp_str: ::std::option::Option::None,
            details_str: ::std::option::Option::None,
            other_team_str: ::std::option::Option::None,
            is_yes_no_vote: ::std::option::Option::None,
            entidx_target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_VoteStart {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_VoteStart").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_VoteStart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_VoteStart {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_VotePass)
pub struct CUSRMsg_VotePass {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_VotePass.team)
    pub team: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_VotePass.vote_type)
    pub vote_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_VotePass.disp_str)
    pub disp_str: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CUSRMsg_VotePass.details_str)
    pub details_str: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_VotePass.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_VotePass {
    fn default() -> &'a CUSRMsg_VotePass {
        <CUSRMsg_VotePass as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_VotePass {
    pub fn new() -> CUSRMsg_VotePass {
        ::std::default::Default::default()
    }

    // optional int32 team = 1;

    pub fn team(&self) -> i32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional int32 vote_type = 2;

    pub fn vote_type(&self) -> i32 {
        self.vote_type.unwrap_or(0)
    }

    pub fn clear_vote_type(&mut self) {
        self.vote_type = ::std::option::Option::None;
    }

    pub fn has_vote_type(&self) -> bool {
        self.vote_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_type(&mut self, v: i32) {
        self.vote_type = ::std::option::Option::Some(v);
    }

    // optional string disp_str = 3;

    pub fn disp_str(&self) -> &str {
        match self.disp_str.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_disp_str(&mut self) {
        self.disp_str = ::std::option::Option::None;
    }

    pub fn has_disp_str(&self) -> bool {
        self.disp_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disp_str(&mut self, v: ::protobuf::Chars) {
        self.disp_str = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disp_str(&mut self) -> &mut ::protobuf::Chars {
        if self.disp_str.is_none() {
            self.disp_str = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.disp_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_disp_str(&mut self) -> ::protobuf::Chars {
        self.disp_str.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional string details_str = 4;

    pub fn details_str(&self) -> &str {
        match self.details_str.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_details_str(&mut self) {
        self.details_str = ::std::option::Option::None;
    }

    pub fn has_details_str(&self) -> bool {
        self.details_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details_str(&mut self, v: ::protobuf::Chars) {
        self.details_str = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details_str(&mut self) -> &mut ::protobuf::Chars {
        if self.details_str.is_none() {
            self.details_str = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.details_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_details_str(&mut self) -> ::protobuf::Chars {
        self.details_str.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CUSRMsg_VotePass| { &m.team },
            |m: &mut CUSRMsg_VotePass| { &mut m.team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vote_type",
            |m: &CUSRMsg_VotePass| { &m.vote_type },
            |m: &mut CUSRMsg_VotePass| { &mut m.vote_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "disp_str",
            |m: &CUSRMsg_VotePass| { &m.disp_str },
            |m: &mut CUSRMsg_VotePass| { &mut m.disp_str },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "details_str",
            |m: &CUSRMsg_VotePass| { &m.details_str },
            |m: &mut CUSRMsg_VotePass| { &mut m.details_str },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_VotePass>(
            "CUSRMsg_VotePass",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_VotePass {
    const NAME: &'static str = "CUSRMsg_VotePass";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.vote_type = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.disp_str = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                34 => {
                    self.details_str = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.vote_type {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.disp_str.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.details_str.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.vote_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.disp_str.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.details_str.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_VotePass {
        CUSRMsg_VotePass::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.vote_type = ::std::option::Option::None;
        self.disp_str = ::std::option::Option::None;
        self.details_str = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_VotePass {
        static instance: CUSRMsg_VotePass = CUSRMsg_VotePass {
            team: ::std::option::Option::None,
            vote_type: ::std::option::Option::None,
            disp_str: ::std::option::Option::None,
            details_str: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_VotePass {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_VotePass").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_VotePass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_VotePass {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_VoteFailed)
pub struct CUSRMsg_VoteFailed {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_VoteFailed.team)
    pub team: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_VoteFailed.reason)
    pub reason: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_VoteFailed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_VoteFailed {
    fn default() -> &'a CUSRMsg_VoteFailed {
        <CUSRMsg_VoteFailed as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_VoteFailed {
    pub fn new() -> CUSRMsg_VoteFailed {
        ::std::default::Default::default()
    }

    // optional int32 team = 1;

    pub fn team(&self) -> i32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional int32 reason = 2;

    pub fn reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: i32) {
        self.reason = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team",
            |m: &CUSRMsg_VoteFailed| { &m.team },
            |m: &mut CUSRMsg_VoteFailed| { &mut m.team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CUSRMsg_VoteFailed| { &m.reason },
            |m: &mut CUSRMsg_VoteFailed| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_VoteFailed>(
            "CUSRMsg_VoteFailed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_VoteFailed {
    const NAME: &'static str = "CUSRMsg_VoteFailed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.reason = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.reason {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_VoteFailed {
        CUSRMsg_VoteFailed::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_VoteFailed {
        static instance: CUSRMsg_VoteFailed = CUSRMsg_VoteFailed {
            team: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_VoteFailed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_VoteFailed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_VoteFailed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_VoteFailed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_VoteSetup)
pub struct CUSRMsg_VoteSetup {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_VoteSetup.potential_issues)
    pub potential_issues: ::std::vec::Vec<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_VoteSetup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_VoteSetup {
    fn default() -> &'a CUSRMsg_VoteSetup {
        <CUSRMsg_VoteSetup as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_VoteSetup {
    pub fn new() -> CUSRMsg_VoteSetup {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "potential_issues",
            |m: &CUSRMsg_VoteSetup| { &m.potential_issues },
            |m: &mut CUSRMsg_VoteSetup| { &mut m.potential_issues },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_VoteSetup>(
            "CUSRMsg_VoteSetup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_VoteSetup {
    const NAME: &'static str = "CUSRMsg_VoteSetup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.potential_issues.push(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.potential_issues {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.potential_issues {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_VoteSetup {
        CUSRMsg_VoteSetup::new()
    }

    fn clear(&mut self) {
        self.potential_issues.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_VoteSetup {
        static instance: CUSRMsg_VoteSetup = CUSRMsg_VoteSetup {
            potential_issues: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_VoteSetup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_VoteSetup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_VoteSetup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_VoteSetup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_SendLastKillerDamageToClient)
pub struct CUSRMsg_SendLastKillerDamageToClient {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_SendLastKillerDamageToClient.num_hits_given)
    pub num_hits_given: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_SendLastKillerDamageToClient.damage_given)
    pub damage_given: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_SendLastKillerDamageToClient.num_hits_taken)
    pub num_hits_taken: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_SendLastKillerDamageToClient.damage_taken)
    pub damage_taken: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_SendLastKillerDamageToClient.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_SendLastKillerDamageToClient {
    fn default() -> &'a CUSRMsg_SendLastKillerDamageToClient {
        <CUSRMsg_SendLastKillerDamageToClient as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_SendLastKillerDamageToClient {
    pub fn new() -> CUSRMsg_SendLastKillerDamageToClient {
        ::std::default::Default::default()
    }

    // optional int32 num_hits_given = 1;

    pub fn num_hits_given(&self) -> i32 {
        self.num_hits_given.unwrap_or(0)
    }

    pub fn clear_num_hits_given(&mut self) {
        self.num_hits_given = ::std::option::Option::None;
    }

    pub fn has_num_hits_given(&self) -> bool {
        self.num_hits_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_hits_given(&mut self, v: i32) {
        self.num_hits_given = ::std::option::Option::Some(v);
    }

    // optional int32 damage_given = 2;

    pub fn damage_given(&self) -> i32 {
        self.damage_given.unwrap_or(0)
    }

    pub fn clear_damage_given(&mut self) {
        self.damage_given = ::std::option::Option::None;
    }

    pub fn has_damage_given(&self) -> bool {
        self.damage_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_given(&mut self, v: i32) {
        self.damage_given = ::std::option::Option::Some(v);
    }

    // optional int32 num_hits_taken = 3;

    pub fn num_hits_taken(&self) -> i32 {
        self.num_hits_taken.unwrap_or(0)
    }

    pub fn clear_num_hits_taken(&mut self) {
        self.num_hits_taken = ::std::option::Option::None;
    }

    pub fn has_num_hits_taken(&self) -> bool {
        self.num_hits_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_hits_taken(&mut self, v: i32) {
        self.num_hits_taken = ::std::option::Option::Some(v);
    }

    // optional int32 damage_taken = 4;

    pub fn damage_taken(&self) -> i32 {
        self.damage_taken.unwrap_or(0)
    }

    pub fn clear_damage_taken(&mut self) {
        self.damage_taken = ::std::option::Option::None;
    }

    pub fn has_damage_taken(&self) -> bool {
        self.damage_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_taken(&mut self, v: i32) {
        self.damage_taken = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_hits_given",
            |m: &CUSRMsg_SendLastKillerDamageToClient| { &m.num_hits_given },
            |m: &mut CUSRMsg_SendLastKillerDamageToClient| { &mut m.num_hits_given },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_given",
            |m: &CUSRMsg_SendLastKillerDamageToClient| { &m.damage_given },
            |m: &mut CUSRMsg_SendLastKillerDamageToClient| { &mut m.damage_given },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_hits_taken",
            |m: &CUSRMsg_SendLastKillerDamageToClient| { &m.num_hits_taken },
            |m: &mut CUSRMsg_SendLastKillerDamageToClient| { &mut m.num_hits_taken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "damage_taken",
            |m: &CUSRMsg_SendLastKillerDamageToClient| { &m.damage_taken },
            |m: &mut CUSRMsg_SendLastKillerDamageToClient| { &mut m.damage_taken },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_SendLastKillerDamageToClient>(
            "CUSRMsg_SendLastKillerDamageToClient",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_SendLastKillerDamageToClient {
    const NAME: &'static str = "CUSRMsg_SendLastKillerDamageToClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_hits_given = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.damage_given = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.num_hits_taken = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.damage_taken = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.num_hits_given {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.damage_given {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.num_hits_taken {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.damage_taken {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.num_hits_given {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.damage_given {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.num_hits_taken {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.damage_taken {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_SendLastKillerDamageToClient {
        CUSRMsg_SendLastKillerDamageToClient::new()
    }

    fn clear(&mut self) {
        self.num_hits_given = ::std::option::Option::None;
        self.damage_given = ::std::option::Option::None;
        self.num_hits_taken = ::std::option::Option::None;
        self.damage_taken = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_SendLastKillerDamageToClient {
        static instance: CUSRMsg_SendLastKillerDamageToClient = CUSRMsg_SendLastKillerDamageToClient {
            num_hits_given: ::std::option::Option::None,
            damage_given: ::std::option::Option::None,
            num_hits_taken: ::std::option::Option::None,
            damage_taken: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_SendLastKillerDamageToClient {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_SendLastKillerDamageToClient").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_SendLastKillerDamageToClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_SendLastKillerDamageToClient {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_ServerRankUpdate)
pub struct CUSRMsg_ServerRankUpdate {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_ServerRankUpdate.rank_update)
    pub rank_update: ::std::vec::Vec<cusrmsg_server_rank_update::RankUpdate>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_ServerRankUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_ServerRankUpdate {
    fn default() -> &'a CUSRMsg_ServerRankUpdate {
        <CUSRMsg_ServerRankUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_ServerRankUpdate {
    pub fn new() -> CUSRMsg_ServerRankUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rank_update",
            |m: &CUSRMsg_ServerRankUpdate| { &m.rank_update },
            |m: &mut CUSRMsg_ServerRankUpdate| { &mut m.rank_update },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_ServerRankUpdate>(
            "CUSRMsg_ServerRankUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_ServerRankUpdate {
    const NAME: &'static str = "CUSRMsg_ServerRankUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rank_update.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rank_update {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.rank_update {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_ServerRankUpdate {
        CUSRMsg_ServerRankUpdate::new()
    }

    fn clear(&mut self) {
        self.rank_update.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_ServerRankUpdate {
        static instance: CUSRMsg_ServerRankUpdate = CUSRMsg_ServerRankUpdate {
            rank_update: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_ServerRankUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_ServerRankUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_ServerRankUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_ServerRankUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CUSRMsg_ServerRankUpdate`
pub mod cusrmsg_server_rank_update {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CUSRMsg_ServerRankUpdate.RankUpdate)
    pub struct RankUpdate {
        // message fields
        // @@protoc_insertion_point(field:CUSRMsg_ServerRankUpdate.RankUpdate.account_id)
        pub account_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_ServerRankUpdate.RankUpdate.rank_old)
        pub rank_old: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_ServerRankUpdate.RankUpdate.rank_new)
        pub rank_new: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_ServerRankUpdate.RankUpdate.num_wins)
        pub num_wins: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_ServerRankUpdate.RankUpdate.rank_change)
        pub rank_change: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CUSRMsg_ServerRankUpdate.RankUpdate.rank_type_id)
        pub rank_type_id: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUSRMsg_ServerRankUpdate.RankUpdate.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RankUpdate {
        fn default() -> &'a RankUpdate {
            <RankUpdate as ::protobuf::Message>::default_instance()
        }
    }

    impl RankUpdate {
        pub fn new() -> RankUpdate {
            ::std::default::Default::default()
        }

        // optional int32 account_id = 1;

        pub fn account_id(&self) -> i32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: i32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional int32 rank_old = 2;

        pub fn rank_old(&self) -> i32 {
            self.rank_old.unwrap_or(0)
        }

        pub fn clear_rank_old(&mut self) {
            self.rank_old = ::std::option::Option::None;
        }

        pub fn has_rank_old(&self) -> bool {
            self.rank_old.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_old(&mut self, v: i32) {
            self.rank_old = ::std::option::Option::Some(v);
        }

        // optional int32 rank_new = 3;

        pub fn rank_new(&self) -> i32 {
            self.rank_new.unwrap_or(0)
        }

        pub fn clear_rank_new(&mut self) {
            self.rank_new = ::std::option::Option::None;
        }

        pub fn has_rank_new(&self) -> bool {
            self.rank_new.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_new(&mut self, v: i32) {
            self.rank_new = ::std::option::Option::Some(v);
        }

        // optional int32 num_wins = 4;

        pub fn num_wins(&self) -> i32 {
            self.num_wins.unwrap_or(0)
        }

        pub fn clear_num_wins(&mut self) {
            self.num_wins = ::std::option::Option::None;
        }

        pub fn has_num_wins(&self) -> bool {
            self.num_wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_wins(&mut self, v: i32) {
            self.num_wins = ::std::option::Option::Some(v);
        }

        // optional float rank_change = 5;

        pub fn rank_change(&self) -> f32 {
            self.rank_change.unwrap_or(0.)
        }

        pub fn clear_rank_change(&mut self) {
            self.rank_change = ::std::option::Option::None;
        }

        pub fn has_rank_change(&self) -> bool {
            self.rank_change.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_change(&mut self, v: f32) {
            self.rank_change = ::std::option::Option::Some(v);
        }

        // optional int32 rank_type_id = 6;

        pub fn rank_type_id(&self) -> i32 {
            self.rank_type_id.unwrap_or(0)
        }

        pub fn clear_rank_type_id(&mut self) {
            self.rank_type_id = ::std::option::Option::None;
        }

        pub fn has_rank_type_id(&self) -> bool {
            self.rank_type_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_type_id(&mut self, v: i32) {
            self.rank_type_id = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_id",
                |m: &RankUpdate| { &m.account_id },
                |m: &mut RankUpdate| { &mut m.account_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank_old",
                |m: &RankUpdate| { &m.rank_old },
                |m: &mut RankUpdate| { &mut m.rank_old },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank_new",
                |m: &RankUpdate| { &m.rank_new },
                |m: &mut RankUpdate| { &mut m.rank_new },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_wins",
                |m: &RankUpdate| { &m.num_wins },
                |m: &mut RankUpdate| { &mut m.num_wins },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank_change",
                |m: &RankUpdate| { &m.rank_change },
                |m: &mut RankUpdate| { &mut m.rank_change },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rank_type_id",
                |m: &RankUpdate| { &m.rank_type_id },
                |m: &mut RankUpdate| { &mut m.rank_type_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RankUpdate>(
                "CUSRMsg_ServerRankUpdate.RankUpdate",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RankUpdate {
        const NAME: &'static str = "RankUpdate";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.rank_old = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.rank_new = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.num_wins = ::std::option::Option::Some(is.read_int32()?);
                    },
                    45 => {
                        self.rank_change = ::std::option::Option::Some(is.read_float()?);
                    },
                    48 => {
                        self.rank_type_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.rank_old {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.rank_new {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.num_wins {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.rank_change {
                my_size += 1 + 4;
            }
            if let Some(v) = self.rank_type_id {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.rank_old {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.rank_new {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.num_wins {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.rank_change {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.rank_type_id {
                os.write_int32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RankUpdate {
            RankUpdate::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.rank_old = ::std::option::Option::None;
            self.rank_new = ::std::option::Option::None;
            self.num_wins = ::std::option::Option::None;
            self.rank_change = ::std::option::Option::None;
            self.rank_type_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RankUpdate {
            static instance: RankUpdate = RankUpdate {
                account_id: ::std::option::Option::None,
                rank_old: ::std::option::Option::None,
                rank_new: ::std::option::Option::None,
                num_wins: ::std::option::Option::None,
                rank_change: ::std::option::Option::None,
                rank_type_id: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RankUpdate {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUSRMsg_ServerRankUpdate.RankUpdate").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RankUpdate {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RankUpdate {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_XpUpdate)
pub struct CUSRMsg_XpUpdate {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_XpUpdate.data)
    pub data: ::protobuf::MessageField<super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_XpUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_XpUpdate {
    fn default() -> &'a CUSRMsg_XpUpdate {
        <CUSRMsg_XpUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_XpUpdate {
    pub fn new() -> CUSRMsg_XpUpdate {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded>(
            "data",
            |m: &CUSRMsg_XpUpdate| { &m.data },
            |m: &mut CUSRMsg_XpUpdate| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_XpUpdate>(
            "CUSRMsg_XpUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_XpUpdate {
    const NAME: &'static str = "CUSRMsg_XpUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_XpUpdate {
        CUSRMsg_XpUpdate::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_XpUpdate {
        static instance: CUSRMsg_XpUpdate = CUSRMsg_XpUpdate {
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_XpUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_XpUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_XpUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_XpUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_ItemPickup)
pub struct CUSRMsg_ItemPickup {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_ItemPickup.item)
    pub item: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_ItemPickup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_ItemPickup {
    fn default() -> &'a CUSRMsg_ItemPickup {
        <CUSRMsg_ItemPickup as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_ItemPickup {
    pub fn new() -> CUSRMsg_ItemPickup {
        ::std::default::Default::default()
    }

    // optional string item = 1;

    pub fn item(&self) -> &str {
        match self.item.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_item(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: ::protobuf::Chars) {
        self.item = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item(&mut self) -> &mut ::protobuf::Chars {
        if self.item.is_none() {
            self.item = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.item.as_mut().unwrap()
    }

    // Take field
    pub fn take_item(&mut self) -> ::protobuf::Chars {
        self.item.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item",
            |m: &CUSRMsg_ItemPickup| { &m.item },
            |m: &mut CUSRMsg_ItemPickup| { &mut m.item },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_ItemPickup>(
            "CUSRMsg_ItemPickup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_ItemPickup {
    const NAME: &'static str = "CUSRMsg_ItemPickup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.item = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_ItemPickup {
        CUSRMsg_ItemPickup::new()
    }

    fn clear(&mut self) {
        self.item = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_ItemPickup {
        static instance: CUSRMsg_ItemPickup = CUSRMsg_ItemPickup {
            item: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_ItemPickup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_ItemPickup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_ItemPickup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_ItemPickup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_ShowMenu)
pub struct CUSRMsg_ShowMenu {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_ShowMenu.bits_valid_slots)
    pub bits_valid_slots: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_ShowMenu.display_time)
    pub display_time: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_ShowMenu.menu_string)
    pub menu_string: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_ShowMenu.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_ShowMenu {
    fn default() -> &'a CUSRMsg_ShowMenu {
        <CUSRMsg_ShowMenu as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_ShowMenu {
    pub fn new() -> CUSRMsg_ShowMenu {
        ::std::default::Default::default()
    }

    // optional int32 bits_valid_slots = 1;

    pub fn bits_valid_slots(&self) -> i32 {
        self.bits_valid_slots.unwrap_or(0)
    }

    pub fn clear_bits_valid_slots(&mut self) {
        self.bits_valid_slots = ::std::option::Option::None;
    }

    pub fn has_bits_valid_slots(&self) -> bool {
        self.bits_valid_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bits_valid_slots(&mut self, v: i32) {
        self.bits_valid_slots = ::std::option::Option::Some(v);
    }

    // optional int32 display_time = 2;

    pub fn display_time(&self) -> i32 {
        self.display_time.unwrap_or(0)
    }

    pub fn clear_display_time(&mut self) {
        self.display_time = ::std::option::Option::None;
    }

    pub fn has_display_time(&self) -> bool {
        self.display_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_time(&mut self, v: i32) {
        self.display_time = ::std::option::Option::Some(v);
    }

    // optional string menu_string = 3;

    pub fn menu_string(&self) -> &str {
        match self.menu_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_menu_string(&mut self) {
        self.menu_string = ::std::option::Option::None;
    }

    pub fn has_menu_string(&self) -> bool {
        self.menu_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_menu_string(&mut self, v: ::protobuf::Chars) {
        self.menu_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_menu_string(&mut self) -> &mut ::protobuf::Chars {
        if self.menu_string.is_none() {
            self.menu_string = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.menu_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_menu_string(&mut self) -> ::protobuf::Chars {
        self.menu_string.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bits_valid_slots",
            |m: &CUSRMsg_ShowMenu| { &m.bits_valid_slots },
            |m: &mut CUSRMsg_ShowMenu| { &mut m.bits_valid_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "display_time",
            |m: &CUSRMsg_ShowMenu| { &m.display_time },
            |m: &mut CUSRMsg_ShowMenu| { &mut m.display_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "menu_string",
            |m: &CUSRMsg_ShowMenu| { &m.menu_string },
            |m: &mut CUSRMsg_ShowMenu| { &mut m.menu_string },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_ShowMenu>(
            "CUSRMsg_ShowMenu",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_ShowMenu {
    const NAME: &'static str = "CUSRMsg_ShowMenu";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bits_valid_slots = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.display_time = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.menu_string = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bits_valid_slots {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.display_time {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.menu_string.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.bits_valid_slots {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.display_time {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.menu_string.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_ShowMenu {
        CUSRMsg_ShowMenu::new()
    }

    fn clear(&mut self) {
        self.bits_valid_slots = ::std::option::Option::None;
        self.display_time = ::std::option::Option::None;
        self.menu_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_ShowMenu {
        static instance: CUSRMsg_ShowMenu = CUSRMsg_ShowMenu {
            bits_valid_slots: ::std::option::Option::None,
            display_time: ::std::option::Option::None,
            menu_string: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_ShowMenu {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_ShowMenu").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_ShowMenu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_ShowMenu {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_BarTime)
pub struct CUSRMsg_BarTime {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_BarTime.time)
    pub time: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_BarTime.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_BarTime {
    fn default() -> &'a CUSRMsg_BarTime {
        <CUSRMsg_BarTime as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_BarTime {
    pub fn new() -> CUSRMsg_BarTime {
        ::std::default::Default::default()
    }

    // optional string time = 1;

    pub fn time(&self) -> &str {
        match self.time.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: ::protobuf::Chars) {
        self.time = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&mut self) -> &mut ::protobuf::Chars {
        if self.time.is_none() {
            self.time = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.time.as_mut().unwrap()
    }

    // Take field
    pub fn take_time(&mut self) -> ::protobuf::Chars {
        self.time.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time",
            |m: &CUSRMsg_BarTime| { &m.time },
            |m: &mut CUSRMsg_BarTime| { &mut m.time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_BarTime>(
            "CUSRMsg_BarTime",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_BarTime {
    const NAME: &'static str = "CUSRMsg_BarTime";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.time = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.time.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.time.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_BarTime {
        CUSRMsg_BarTime::new()
    }

    fn clear(&mut self) {
        self.time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_BarTime {
        static instance: CUSRMsg_BarTime = CUSRMsg_BarTime {
            time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_BarTime {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_BarTime").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_BarTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_BarTime {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_AmmoDenied)
pub struct CUSRMsg_AmmoDenied {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_AmmoDenied.ammoIdx)
    pub ammoIdx: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_AmmoDenied.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_AmmoDenied {
    fn default() -> &'a CUSRMsg_AmmoDenied {
        <CUSRMsg_AmmoDenied as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_AmmoDenied {
    pub fn new() -> CUSRMsg_AmmoDenied {
        ::std::default::Default::default()
    }

    // optional int32 ammoIdx = 1;

    pub fn ammoIdx(&self) -> i32 {
        self.ammoIdx.unwrap_or(0)
    }

    pub fn clear_ammoIdx(&mut self) {
        self.ammoIdx = ::std::option::Option::None;
    }

    pub fn has_ammoIdx(&self) -> bool {
        self.ammoIdx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ammoIdx(&mut self, v: i32) {
        self.ammoIdx = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ammoIdx",
            |m: &CUSRMsg_AmmoDenied| { &m.ammoIdx },
            |m: &mut CUSRMsg_AmmoDenied| { &mut m.ammoIdx },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_AmmoDenied>(
            "CUSRMsg_AmmoDenied",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_AmmoDenied {
    const NAME: &'static str = "CUSRMsg_AmmoDenied";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ammoIdx = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ammoIdx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ammoIdx {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_AmmoDenied {
        CUSRMsg_AmmoDenied::new()
    }

    fn clear(&mut self) {
        self.ammoIdx = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_AmmoDenied {
        static instance: CUSRMsg_AmmoDenied = CUSRMsg_AmmoDenied {
            ammoIdx: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_AmmoDenied {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_AmmoDenied").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_AmmoDenied {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_AmmoDenied {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_MarkAchievement)
pub struct CUSRMsg_MarkAchievement {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_MarkAchievement.achievement)
    pub achievement: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_MarkAchievement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_MarkAchievement {
    fn default() -> &'a CUSRMsg_MarkAchievement {
        <CUSRMsg_MarkAchievement as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_MarkAchievement {
    pub fn new() -> CUSRMsg_MarkAchievement {
        ::std::default::Default::default()
    }

    // optional string achievement = 1;

    pub fn achievement(&self) -> &str {
        match self.achievement.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_achievement(&mut self) {
        self.achievement = ::std::option::Option::None;
    }

    pub fn has_achievement(&self) -> bool {
        self.achievement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement(&mut self, v: ::protobuf::Chars) {
        self.achievement = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_achievement(&mut self) -> &mut ::protobuf::Chars {
        if self.achievement.is_none() {
            self.achievement = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.achievement.as_mut().unwrap()
    }

    // Take field
    pub fn take_achievement(&mut self) -> ::protobuf::Chars {
        self.achievement.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "achievement",
            |m: &CUSRMsg_MarkAchievement| { &m.achievement },
            |m: &mut CUSRMsg_MarkAchievement| { &mut m.achievement },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_MarkAchievement>(
            "CUSRMsg_MarkAchievement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_MarkAchievement {
    const NAME: &'static str = "CUSRMsg_MarkAchievement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.achievement = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.achievement.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.achievement.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_MarkAchievement {
        CUSRMsg_MarkAchievement::new()
    }

    fn clear(&mut self) {
        self.achievement = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_MarkAchievement {
        static instance: CUSRMsg_MarkAchievement = CUSRMsg_MarkAchievement {
            achievement: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_MarkAchievement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_MarkAchievement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_MarkAchievement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_MarkAchievement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_MatchStatsUpdate)
pub struct CUSRMsg_MatchStatsUpdate {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_MatchStatsUpdate.update)
    pub update: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_MatchStatsUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_MatchStatsUpdate {
    fn default() -> &'a CUSRMsg_MatchStatsUpdate {
        <CUSRMsg_MatchStatsUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_MatchStatsUpdate {
    pub fn new() -> CUSRMsg_MatchStatsUpdate {
        ::std::default::Default::default()
    }

    // optional string update = 1;

    pub fn update(&self) -> &str {
        match self.update.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_update(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: ::protobuf::Chars) {
        self.update = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update(&mut self) -> &mut ::protobuf::Chars {
        if self.update.is_none() {
            self.update = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.update.as_mut().unwrap()
    }

    // Take field
    pub fn take_update(&mut self) -> ::protobuf::Chars {
        self.update.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update",
            |m: &CUSRMsg_MatchStatsUpdate| { &m.update },
            |m: &mut CUSRMsg_MatchStatsUpdate| { &mut m.update },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_MatchStatsUpdate>(
            "CUSRMsg_MatchStatsUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_MatchStatsUpdate {
    const NAME: &'static str = "CUSRMsg_MatchStatsUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.update = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.update.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.update.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_MatchStatsUpdate {
        CUSRMsg_MatchStatsUpdate::new()
    }

    fn clear(&mut self) {
        self.update = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_MatchStatsUpdate {
        static instance: CUSRMsg_MatchStatsUpdate = CUSRMsg_MatchStatsUpdate {
            update: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_MatchStatsUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_MatchStatsUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_MatchStatsUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_MatchStatsUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_ItemDrop)
pub struct CUSRMsg_ItemDrop {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_ItemDrop.itemid)
    pub itemid: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CUSRMsg_ItemDrop.death)
    pub death: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_ItemDrop.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_ItemDrop {
    fn default() -> &'a CUSRMsg_ItemDrop {
        <CUSRMsg_ItemDrop as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_ItemDrop {
    pub fn new() -> CUSRMsg_ItemDrop {
        ::std::default::Default::default()
    }

    // optional int64 itemid = 1;

    pub fn itemid(&self) -> i64 {
        self.itemid.unwrap_or(0)
    }

    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: i64) {
        self.itemid = ::std::option::Option::Some(v);
    }

    // optional bool death = 2;

    pub fn death(&self) -> bool {
        self.death.unwrap_or(false)
    }

    pub fn clear_death(&mut self) {
        self.death = ::std::option::Option::None;
    }

    pub fn has_death(&self) -> bool {
        self.death.is_some()
    }

    // Param is passed by value, moved
    pub fn set_death(&mut self, v: bool) {
        self.death = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "itemid",
            |m: &CUSRMsg_ItemDrop| { &m.itemid },
            |m: &mut CUSRMsg_ItemDrop| { &mut m.itemid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "death",
            |m: &CUSRMsg_ItemDrop| { &m.death },
            |m: &mut CUSRMsg_ItemDrop| { &mut m.death },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_ItemDrop>(
            "CUSRMsg_ItemDrop",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_ItemDrop {
    const NAME: &'static str = "CUSRMsg_ItemDrop";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.itemid = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.death = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.death {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.itemid {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.death {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_ItemDrop {
        CUSRMsg_ItemDrop::new()
    }

    fn clear(&mut self) {
        self.itemid = ::std::option::Option::None;
        self.death = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_ItemDrop {
        static instance: CUSRMsg_ItemDrop = CUSRMsg_ItemDrop {
            itemid: ::std::option::Option::None,
            death: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_ItemDrop {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_ItemDrop").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_ItemDrop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_ItemDrop {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_GlowPropTurnOff)
pub struct CUSRMsg_GlowPropTurnOff {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_GlowPropTurnOff.entidx)
    pub entidx: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_GlowPropTurnOff.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_GlowPropTurnOff {
    fn default() -> &'a CUSRMsg_GlowPropTurnOff {
        <CUSRMsg_GlowPropTurnOff as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_GlowPropTurnOff {
    pub fn new() -> CUSRMsg_GlowPropTurnOff {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;

    pub fn entidx(&self) -> i32 {
        self.entidx.unwrap_or(0)
    }

    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entidx",
            |m: &CUSRMsg_GlowPropTurnOff| { &m.entidx },
            |m: &mut CUSRMsg_GlowPropTurnOff| { &mut m.entidx },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_GlowPropTurnOff>(
            "CUSRMsg_GlowPropTurnOff",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_GlowPropTurnOff {
    const NAME: &'static str = "CUSRMsg_GlowPropTurnOff";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entidx = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_GlowPropTurnOff {
        CUSRMsg_GlowPropTurnOff::new()
    }

    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_GlowPropTurnOff {
        static instance: CUSRMsg_GlowPropTurnOff = CUSRMsg_GlowPropTurnOff {
            entidx: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_GlowPropTurnOff {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_GlowPropTurnOff").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_GlowPropTurnOff {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_GlowPropTurnOff {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_RoundBackupFilenames)
pub struct CUSRMsg_RoundBackupFilenames {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_RoundBackupFilenames.count)
    pub count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_RoundBackupFilenames.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_RoundBackupFilenames.filename)
    pub filename: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CUSRMsg_RoundBackupFilenames.nicename)
    pub nicename: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_RoundBackupFilenames.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_RoundBackupFilenames {
    fn default() -> &'a CUSRMsg_RoundBackupFilenames {
        <CUSRMsg_RoundBackupFilenames as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_RoundBackupFilenames {
    pub fn new() -> CUSRMsg_RoundBackupFilenames {
        ::std::default::Default::default()
    }

    // optional int32 count = 1;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional int32 index = 2;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional string filename = 3;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::protobuf::Chars) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::protobuf::Chars {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::protobuf::Chars {
        self.filename.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional string nicename = 4;

    pub fn nicename(&self) -> &str {
        match self.nicename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nicename(&mut self) {
        self.nicename = ::std::option::Option::None;
    }

    pub fn has_nicename(&self) -> bool {
        self.nicename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nicename(&mut self, v: ::protobuf::Chars) {
        self.nicename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nicename(&mut self) -> &mut ::protobuf::Chars {
        if self.nicename.is_none() {
            self.nicename = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.nicename.as_mut().unwrap()
    }

    // Take field
    pub fn take_nicename(&mut self) -> ::protobuf::Chars {
        self.nicename.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &CUSRMsg_RoundBackupFilenames| { &m.count },
            |m: &mut CUSRMsg_RoundBackupFilenames| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "index",
            |m: &CUSRMsg_RoundBackupFilenames| { &m.index },
            |m: &mut CUSRMsg_RoundBackupFilenames| { &mut m.index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CUSRMsg_RoundBackupFilenames| { &m.filename },
            |m: &mut CUSRMsg_RoundBackupFilenames| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nicename",
            |m: &CUSRMsg_RoundBackupFilenames| { &m.nicename },
            |m: &mut CUSRMsg_RoundBackupFilenames| { &mut m.nicename },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_RoundBackupFilenames>(
            "CUSRMsg_RoundBackupFilenames",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_RoundBackupFilenames {
    const NAME: &'static str = "CUSRMsg_RoundBackupFilenames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.filename = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                34 => {
                    self.nicename = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.nicename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.count {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.nicename.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_RoundBackupFilenames {
        CUSRMsg_RoundBackupFilenames::new()
    }

    fn clear(&mut self) {
        self.count = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.nicename = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_RoundBackupFilenames {
        static instance: CUSRMsg_RoundBackupFilenames = CUSRMsg_RoundBackupFilenames {
            count: ::std::option::Option::None,
            index: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            nicename: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_RoundBackupFilenames {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_RoundBackupFilenames").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_RoundBackupFilenames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_RoundBackupFilenames {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_SSUI)
pub struct CUSRMsg_SSUI {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_SSUI.show)
    pub show: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUSRMsg_SSUI.start_time)
    pub start_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUSRMsg_SSUI.end_time)
    pub end_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_SSUI.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_SSUI {
    fn default() -> &'a CUSRMsg_SSUI {
        <CUSRMsg_SSUI as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_SSUI {
    pub fn new() -> CUSRMsg_SSUI {
        ::std::default::Default::default()
    }

    // optional bool show = 1;

    pub fn show(&self) -> bool {
        self.show.unwrap_or(false)
    }

    pub fn clear_show(&mut self) {
        self.show = ::std::option::Option::None;
    }

    pub fn has_show(&self) -> bool {
        self.show.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show(&mut self, v: bool) {
        self.show = ::std::option::Option::Some(v);
    }

    // optional float start_time = 2;

    pub fn start_time(&self) -> f32 {
        self.start_time.unwrap_or(0.)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: f32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional float end_time = 3;

    pub fn end_time(&self) -> f32 {
        self.end_time.unwrap_or(0.)
    }

    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: f32) {
        self.end_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "show",
            |m: &CUSRMsg_SSUI| { &m.show },
            |m: &mut CUSRMsg_SSUI| { &mut m.show },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "start_time",
            |m: &CUSRMsg_SSUI| { &m.start_time },
            |m: &mut CUSRMsg_SSUI| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "end_time",
            |m: &CUSRMsg_SSUI| { &m.end_time },
            |m: &mut CUSRMsg_SSUI| { &mut m.end_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_SSUI>(
            "CUSRMsg_SSUI",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_SSUI {
    const NAME: &'static str = "CUSRMsg_SSUI";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.show = ::std::option::Option::Some(is.read_bool()?);
                },
                21 => {
                    self.start_time = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.end_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.show {
            my_size += 1 + 1;
        }
        if let Some(v) = self.start_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.end_time {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.show {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_SSUI {
        CUSRMsg_SSUI::new()
    }

    fn clear(&mut self) {
        self.show = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.end_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_SSUI {
        static instance: CUSRMsg_SSUI = CUSRMsg_SSUI {
            show: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            end_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_SSUI {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_SSUI").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_SSUI {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_SSUI {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_SurvivalStats)
pub struct CUSRMsg_SurvivalStats {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_SurvivalStats.xuid)
    pub xuid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CUSRMsg_SurvivalStats.facts)
    pub facts: ::std::vec::Vec<cusrmsg_survival_stats::Fact>,
    // @@protoc_insertion_point(field:CUSRMsg_SurvivalStats.usrs)
    pub usrs: ::std::vec::Vec<cusrmsg_survival_stats::Placement>,
    // @@protoc_insertion_point(field:CUSRMsg_SurvivalStats.damages)
    pub damages: ::std::vec::Vec<cusrmsg_survival_stats::Damage>,
    // @@protoc_insertion_point(field:CUSRMsg_SurvivalStats.ticknumber)
    pub ticknumber: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_SurvivalStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_SurvivalStats {
    fn default() -> &'a CUSRMsg_SurvivalStats {
        <CUSRMsg_SurvivalStats as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_SurvivalStats {
    pub fn new() -> CUSRMsg_SurvivalStats {
        ::std::default::Default::default()
    }

    // optional uint64 xuid = 1;

    pub fn xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }

    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional int32 ticknumber = 4;

    pub fn ticknumber(&self) -> i32 {
        self.ticknumber.unwrap_or(0)
    }

    pub fn clear_ticknumber(&mut self) {
        self.ticknumber = ::std::option::Option::None;
    }

    pub fn has_ticknumber(&self) -> bool {
        self.ticknumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticknumber(&mut self, v: i32) {
        self.ticknumber = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xuid",
            |m: &CUSRMsg_SurvivalStats| { &m.xuid },
            |m: &mut CUSRMsg_SurvivalStats| { &mut m.xuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "facts",
            |m: &CUSRMsg_SurvivalStats| { &m.facts },
            |m: &mut CUSRMsg_SurvivalStats| { &mut m.facts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "usrs",
            |m: &CUSRMsg_SurvivalStats| { &m.usrs },
            |m: &mut CUSRMsg_SurvivalStats| { &mut m.usrs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "damages",
            |m: &CUSRMsg_SurvivalStats| { &m.damages },
            |m: &mut CUSRMsg_SurvivalStats| { &mut m.damages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticknumber",
            |m: &CUSRMsg_SurvivalStats| { &m.ticknumber },
            |m: &mut CUSRMsg_SurvivalStats| { &mut m.ticknumber },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_SurvivalStats>(
            "CUSRMsg_SurvivalStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_SurvivalStats {
    const NAME: &'static str = "CUSRMsg_SurvivalStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.xuid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.facts.push(is.read_message()?);
                },
                26 => {
                    self.usrs.push(is.read_message()?);
                },
                42 => {
                    self.damages.push(is.read_message()?);
                },
                32 => {
                    self.ticknumber = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.xuid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.facts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.usrs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.damages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.ticknumber {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.xuid {
            os.write_uint64(1, v)?;
        }
        for v in &self.facts {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.usrs {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.damages {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.ticknumber {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_SurvivalStats {
        CUSRMsg_SurvivalStats::new()
    }

    fn clear(&mut self) {
        self.xuid = ::std::option::Option::None;
        self.facts.clear();
        self.usrs.clear();
        self.damages.clear();
        self.ticknumber = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_SurvivalStats {
        static instance: CUSRMsg_SurvivalStats = CUSRMsg_SurvivalStats {
            xuid: ::std::option::Option::None,
            facts: ::std::vec::Vec::new(),
            usrs: ::std::vec::Vec::new(),
            damages: ::std::vec::Vec::new(),
            ticknumber: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_SurvivalStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_SurvivalStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_SurvivalStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_SurvivalStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CUSRMsg_SurvivalStats`
pub mod cusrmsg_survival_stats {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CUSRMsg_SurvivalStats.Fact)
    pub struct Fact {
        // message fields
        // @@protoc_insertion_point(field:CUSRMsg_SurvivalStats.Fact.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_SurvivalStats.Fact.display)
        pub display: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_SurvivalStats.Fact.value)
        pub value: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_SurvivalStats.Fact.interestingness)
        pub interestingness: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUSRMsg_SurvivalStats.Fact.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Fact {
        fn default() -> &'a Fact {
            <Fact as ::protobuf::Message>::default_instance()
        }
    }

    impl Fact {
        pub fn new() -> Fact {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional int32 display = 2;

        pub fn display(&self) -> i32 {
            self.display.unwrap_or(0)
        }

        pub fn clear_display(&mut self) {
            self.display = ::std::option::Option::None;
        }

        pub fn has_display(&self) -> bool {
            self.display.is_some()
        }

        // Param is passed by value, moved
        pub fn set_display(&mut self, v: i32) {
            self.display = ::std::option::Option::Some(v);
        }

        // optional int32 value = 3;

        pub fn value(&self) -> i32 {
            self.value.unwrap_or(0)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: i32) {
            self.value = ::std::option::Option::Some(v);
        }

        // optional float interestingness = 4;

        pub fn interestingness(&self) -> f32 {
            self.interestingness.unwrap_or(0.)
        }

        pub fn clear_interestingness(&mut self) {
            self.interestingness = ::std::option::Option::None;
        }

        pub fn has_interestingness(&self) -> bool {
            self.interestingness.is_some()
        }

        // Param is passed by value, moved
        pub fn set_interestingness(&mut self, v: f32) {
            self.interestingness = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Fact| { &m.type_ },
                |m: &mut Fact| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "display",
                |m: &Fact| { &m.display },
                |m: &mut Fact| { &mut m.display },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &Fact| { &m.value },
                |m: &mut Fact| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "interestingness",
                |m: &Fact| { &m.interestingness },
                |m: &mut Fact| { &mut m.interestingness },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Fact>(
                "CUSRMsg_SurvivalStats.Fact",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Fact {
        const NAME: &'static str = "Fact";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.display = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.value = ::std::option::Option::Some(is.read_int32()?);
                    },
                    37 => {
                        self.interestingness = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.display {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.value {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.interestingness {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.display {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.value {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.interestingness {
                os.write_float(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Fact {
            Fact::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.display = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.interestingness = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Fact {
            static instance: Fact = Fact {
                type_: ::std::option::Option::None,
                display: ::std::option::Option::None,
                value: ::std::option::Option::None,
                interestingness: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Fact {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUSRMsg_SurvivalStats.Fact").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Fact {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Fact {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CUSRMsg_SurvivalStats.Placement)
    pub struct Placement {
        // message fields
        // @@protoc_insertion_point(field:CUSRMsg_SurvivalStats.Placement.xuid)
        pub xuid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CUSRMsg_SurvivalStats.Placement.teamnumber)
        pub teamnumber: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_SurvivalStats.Placement.placement)
        pub placement: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUSRMsg_SurvivalStats.Placement.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Placement {
        fn default() -> &'a Placement {
            <Placement as ::protobuf::Message>::default_instance()
        }
    }

    impl Placement {
        pub fn new() -> Placement {
            ::std::default::Default::default()
        }

        // optional uint64 xuid = 1;

        pub fn xuid(&self) -> u64 {
            self.xuid.unwrap_or(0)
        }

        pub fn clear_xuid(&mut self) {
            self.xuid = ::std::option::Option::None;
        }

        pub fn has_xuid(&self) -> bool {
            self.xuid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xuid(&mut self, v: u64) {
            self.xuid = ::std::option::Option::Some(v);
        }

        // optional int32 teamnumber = 2;

        pub fn teamnumber(&self) -> i32 {
            self.teamnumber.unwrap_or(0)
        }

        pub fn clear_teamnumber(&mut self) {
            self.teamnumber = ::std::option::Option::None;
        }

        pub fn has_teamnumber(&self) -> bool {
            self.teamnumber.is_some()
        }

        // Param is passed by value, moved
        pub fn set_teamnumber(&mut self, v: i32) {
            self.teamnumber = ::std::option::Option::Some(v);
        }

        // optional int32 placement = 3;

        pub fn placement(&self) -> i32 {
            self.placement.unwrap_or(0)
        }

        pub fn clear_placement(&mut self) {
            self.placement = ::std::option::Option::None;
        }

        pub fn has_placement(&self) -> bool {
            self.placement.is_some()
        }

        // Param is passed by value, moved
        pub fn set_placement(&mut self, v: i32) {
            self.placement = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "xuid",
                |m: &Placement| { &m.xuid },
                |m: &mut Placement| { &mut m.xuid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "teamnumber",
                |m: &Placement| { &m.teamnumber },
                |m: &mut Placement| { &mut m.teamnumber },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "placement",
                |m: &Placement| { &m.placement },
                |m: &mut Placement| { &mut m.placement },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Placement>(
                "CUSRMsg_SurvivalStats.Placement",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Placement {
        const NAME: &'static str = "Placement";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.xuid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.teamnumber = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.placement = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.xuid {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.teamnumber {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.placement {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.xuid {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.teamnumber {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.placement {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Placement {
            Placement::new()
        }

        fn clear(&mut self) {
            self.xuid = ::std::option::Option::None;
            self.teamnumber = ::std::option::Option::None;
            self.placement = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Placement {
            static instance: Placement = Placement {
                xuid: ::std::option::Option::None,
                teamnumber: ::std::option::Option::None,
                placement: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Placement {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUSRMsg_SurvivalStats.Placement").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Placement {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Placement {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CUSRMsg_SurvivalStats.Damage)
    pub struct Damage {
        // message fields
        // @@protoc_insertion_point(field:CUSRMsg_SurvivalStats.Damage.xuid)
        pub xuid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CUSRMsg_SurvivalStats.Damage.to)
        pub to: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_SurvivalStats.Damage.to_hits)
        pub to_hits: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_SurvivalStats.Damage.from)
        pub from: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_SurvivalStats.Damage.from_hits)
        pub from_hits: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUSRMsg_SurvivalStats.Damage.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Damage {
        fn default() -> &'a Damage {
            <Damage as ::protobuf::Message>::default_instance()
        }
    }

    impl Damage {
        pub fn new() -> Damage {
            ::std::default::Default::default()
        }

        // optional uint64 xuid = 1;

        pub fn xuid(&self) -> u64 {
            self.xuid.unwrap_or(0)
        }

        pub fn clear_xuid(&mut self) {
            self.xuid = ::std::option::Option::None;
        }

        pub fn has_xuid(&self) -> bool {
            self.xuid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xuid(&mut self, v: u64) {
            self.xuid = ::std::option::Option::Some(v);
        }

        // optional int32 to = 2;

        pub fn to(&self) -> i32 {
            self.to.unwrap_or(0)
        }

        pub fn clear_to(&mut self) {
            self.to = ::std::option::Option::None;
        }

        pub fn has_to(&self) -> bool {
            self.to.is_some()
        }

        // Param is passed by value, moved
        pub fn set_to(&mut self, v: i32) {
            self.to = ::std::option::Option::Some(v);
        }

        // optional int32 to_hits = 3;

        pub fn to_hits(&self) -> i32 {
            self.to_hits.unwrap_or(0)
        }

        pub fn clear_to_hits(&mut self) {
            self.to_hits = ::std::option::Option::None;
        }

        pub fn has_to_hits(&self) -> bool {
            self.to_hits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_to_hits(&mut self, v: i32) {
            self.to_hits = ::std::option::Option::Some(v);
        }

        // optional int32 from = 4;

        pub fn from(&self) -> i32 {
            self.from.unwrap_or(0)
        }

        pub fn clear_from(&mut self) {
            self.from = ::std::option::Option::None;
        }

        pub fn has_from(&self) -> bool {
            self.from.is_some()
        }

        // Param is passed by value, moved
        pub fn set_from(&mut self, v: i32) {
            self.from = ::std::option::Option::Some(v);
        }

        // optional int32 from_hits = 5;

        pub fn from_hits(&self) -> i32 {
            self.from_hits.unwrap_or(0)
        }

        pub fn clear_from_hits(&mut self) {
            self.from_hits = ::std::option::Option::None;
        }

        pub fn has_from_hits(&self) -> bool {
            self.from_hits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_from_hits(&mut self, v: i32) {
            self.from_hits = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "xuid",
                |m: &Damage| { &m.xuid },
                |m: &mut Damage| { &mut m.xuid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "to",
                |m: &Damage| { &m.to },
                |m: &mut Damage| { &mut m.to },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "to_hits",
                |m: &Damage| { &m.to_hits },
                |m: &mut Damage| { &mut m.to_hits },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "from",
                |m: &Damage| { &m.from },
                |m: &mut Damage| { &mut m.from },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "from_hits",
                |m: &Damage| { &m.from_hits },
                |m: &mut Damage| { &mut m.from_hits },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Damage>(
                "CUSRMsg_SurvivalStats.Damage",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Damage {
        const NAME: &'static str = "Damage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.xuid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.to = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.to_hits = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.from = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.from_hits = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.xuid {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.to {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.to_hits {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.from {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.from_hits {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.xuid {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.to {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.to_hits {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.from {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.from_hits {
                os.write_int32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Damage {
            Damage::new()
        }

        fn clear(&mut self) {
            self.xuid = ::std::option::Option::None;
            self.to = ::std::option::Option::None;
            self.to_hits = ::std::option::Option::None;
            self.from = ::std::option::Option::None;
            self.from_hits = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Damage {
            static instance: Damage = Damage {
                xuid: ::std::option::Option::None,
                to: ::std::option::Option::None,
                to_hits: ::std::option::Option::None,
                from: ::std::option::Option::None,
                from_hits: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Damage {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUSRMsg_SurvivalStats.Damage").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Damage {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Damage {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_EndOfMatchAllPlayersData)
pub struct CUSRMsg_EndOfMatchAllPlayersData {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_EndOfMatchAllPlayersData.allplayerdata)
    pub allplayerdata: ::std::vec::Vec<cusrmsg_end_of_match_all_players_data::PlayerData>,
    // @@protoc_insertion_point(field:CUSRMsg_EndOfMatchAllPlayersData.scene)
    pub scene: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_EndOfMatchAllPlayersData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_EndOfMatchAllPlayersData {
    fn default() -> &'a CUSRMsg_EndOfMatchAllPlayersData {
        <CUSRMsg_EndOfMatchAllPlayersData as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_EndOfMatchAllPlayersData {
    pub fn new() -> CUSRMsg_EndOfMatchAllPlayersData {
        ::std::default::Default::default()
    }

    // optional int32 scene = 2;

    pub fn scene(&self) -> i32 {
        self.scene.unwrap_or(0)
    }

    pub fn clear_scene(&mut self) {
        self.scene = ::std::option::Option::None;
    }

    pub fn has_scene(&self) -> bool {
        self.scene.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scene(&mut self, v: i32) {
        self.scene = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "allplayerdata",
            |m: &CUSRMsg_EndOfMatchAllPlayersData| { &m.allplayerdata },
            |m: &mut CUSRMsg_EndOfMatchAllPlayersData| { &mut m.allplayerdata },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scene",
            |m: &CUSRMsg_EndOfMatchAllPlayersData| { &m.scene },
            |m: &mut CUSRMsg_EndOfMatchAllPlayersData| { &mut m.scene },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_EndOfMatchAllPlayersData>(
            "CUSRMsg_EndOfMatchAllPlayersData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_EndOfMatchAllPlayersData {
    const NAME: &'static str = "CUSRMsg_EndOfMatchAllPlayersData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.allplayerdata.push(is.read_message()?);
                },
                16 => {
                    self.scene = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.allplayerdata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.scene {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.allplayerdata {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.scene {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_EndOfMatchAllPlayersData {
        CUSRMsg_EndOfMatchAllPlayersData::new()
    }

    fn clear(&mut self) {
        self.allplayerdata.clear();
        self.scene = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_EndOfMatchAllPlayersData {
        static instance: CUSRMsg_EndOfMatchAllPlayersData = CUSRMsg_EndOfMatchAllPlayersData {
            allplayerdata: ::std::vec::Vec::new(),
            scene: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_EndOfMatchAllPlayersData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_EndOfMatchAllPlayersData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_EndOfMatchAllPlayersData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_EndOfMatchAllPlayersData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CUSRMsg_EndOfMatchAllPlayersData`
pub mod cusrmsg_end_of_match_all_players_data {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CUSRMsg_EndOfMatchAllPlayersData.Accolade)
    pub struct Accolade {
        // message fields
        // @@protoc_insertion_point(field:CUSRMsg_EndOfMatchAllPlayersData.Accolade.eaccolade)
        pub eaccolade: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_EndOfMatchAllPlayersData.Accolade.value)
        pub value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CUSRMsg_EndOfMatchAllPlayersData.Accolade.position)
        pub position: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUSRMsg_EndOfMatchAllPlayersData.Accolade.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Accolade {
        fn default() -> &'a Accolade {
            <Accolade as ::protobuf::Message>::default_instance()
        }
    }

    impl Accolade {
        pub fn new() -> Accolade {
            ::std::default::Default::default()
        }

        // optional int32 eaccolade = 1;

        pub fn eaccolade(&self) -> i32 {
            self.eaccolade.unwrap_or(0)
        }

        pub fn clear_eaccolade(&mut self) {
            self.eaccolade = ::std::option::Option::None;
        }

        pub fn has_eaccolade(&self) -> bool {
            self.eaccolade.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eaccolade(&mut self, v: i32) {
            self.eaccolade = ::std::option::Option::Some(v);
        }

        // optional float value = 2;

        pub fn value(&self) -> f32 {
            self.value.unwrap_or(0.)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: f32) {
            self.value = ::std::option::Option::Some(v);
        }

        // optional int32 position = 3;

        pub fn position(&self) -> i32 {
            self.position.unwrap_or(0)
        }

        pub fn clear_position(&mut self) {
            self.position = ::std::option::Option::None;
        }

        pub fn has_position(&self) -> bool {
            self.position.is_some()
        }

        // Param is passed by value, moved
        pub fn set_position(&mut self, v: i32) {
            self.position = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "eaccolade",
                |m: &Accolade| { &m.eaccolade },
                |m: &mut Accolade| { &mut m.eaccolade },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &Accolade| { &m.value },
                |m: &mut Accolade| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "position",
                |m: &Accolade| { &m.position },
                |m: &mut Accolade| { &mut m.position },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Accolade>(
                "CUSRMsg_EndOfMatchAllPlayersData.Accolade",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Accolade {
        const NAME: &'static str = "Accolade";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.eaccolade = ::std::option::Option::Some(is.read_int32()?);
                    },
                    21 => {
                        self.value = ::std::option::Option::Some(is.read_float()?);
                    },
                    24 => {
                        self.position = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.eaccolade {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.position {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.eaccolade {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.value {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.position {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Accolade {
            Accolade::new()
        }

        fn clear(&mut self) {
            self.eaccolade = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.position = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Accolade {
            static instance: Accolade = Accolade {
                eaccolade: ::std::option::Option::None,
                value: ::std::option::Option::None,
                position: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Accolade {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUSRMsg_EndOfMatchAllPlayersData.Accolade").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Accolade {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Accolade {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CUSRMsg_EndOfMatchAllPlayersData.PlayerData)
    pub struct PlayerData {
        // message fields
        // @@protoc_insertion_point(field:CUSRMsg_EndOfMatchAllPlayersData.PlayerData.entindex)
        pub entindex: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_EndOfMatchAllPlayersData.PlayerData.xuid)
        pub xuid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CUSRMsg_EndOfMatchAllPlayersData.PlayerData.name)
        pub name: ::std::option::Option<::protobuf::Chars>,
        // @@protoc_insertion_point(field:CUSRMsg_EndOfMatchAllPlayersData.PlayerData.teamnumber)
        pub teamnumber: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_EndOfMatchAllPlayersData.PlayerData.nomination)
        pub nomination: ::protobuf::MessageField<Accolade>,
        // @@protoc_insertion_point(field:CUSRMsg_EndOfMatchAllPlayersData.PlayerData.items)
        pub items: ::std::vec::Vec<super::super::cstrike15_gcmessages::CEconItemPreviewDataBlock>,
        // @@protoc_insertion_point(field:CUSRMsg_EndOfMatchAllPlayersData.PlayerData.playercolor)
        pub playercolor: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_EndOfMatchAllPlayersData.PlayerData.isbot)
        pub isbot: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CUSRMsg_EndOfMatchAllPlayersData.PlayerData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerData {
        fn default() -> &'a PlayerData {
            <PlayerData as ::protobuf::Message>::default_instance()
        }
    }

    impl PlayerData {
        pub fn new() -> PlayerData {
            ::std::default::Default::default()
        }

        // optional int32 entindex = 1;

        pub fn entindex(&self) -> i32 {
            self.entindex.unwrap_or(0)
        }

        pub fn clear_entindex(&mut self) {
            self.entindex = ::std::option::Option::None;
        }

        pub fn has_entindex(&self) -> bool {
            self.entindex.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entindex(&mut self, v: i32) {
            self.entindex = ::std::option::Option::Some(v);
        }

        // optional uint64 xuid = 2;

        pub fn xuid(&self) -> u64 {
            self.xuid.unwrap_or(0)
        }

        pub fn clear_xuid(&mut self) {
            self.xuid = ::std::option::Option::None;
        }

        pub fn has_xuid(&self) -> bool {
            self.xuid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xuid(&mut self, v: u64) {
            self.xuid = ::std::option::Option::Some(v);
        }

        // optional string name = 3;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::protobuf::Chars) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::protobuf::Chars {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::protobuf::Chars::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::protobuf::Chars {
            self.name.take().unwrap_or_else(|| ::protobuf::Chars::new())
        }

        // optional int32 teamnumber = 4;

        pub fn teamnumber(&self) -> i32 {
            self.teamnumber.unwrap_or(0)
        }

        pub fn clear_teamnumber(&mut self) {
            self.teamnumber = ::std::option::Option::None;
        }

        pub fn has_teamnumber(&self) -> bool {
            self.teamnumber.is_some()
        }

        // Param is passed by value, moved
        pub fn set_teamnumber(&mut self, v: i32) {
            self.teamnumber = ::std::option::Option::Some(v);
        }

        // optional int32 playercolor = 7;

        pub fn playercolor(&self) -> i32 {
            self.playercolor.unwrap_or(0)
        }

        pub fn clear_playercolor(&mut self) {
            self.playercolor = ::std::option::Option::None;
        }

        pub fn has_playercolor(&self) -> bool {
            self.playercolor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_playercolor(&mut self, v: i32) {
            self.playercolor = ::std::option::Option::Some(v);
        }

        // optional bool isbot = 8;

        pub fn isbot(&self) -> bool {
            self.isbot.unwrap_or(false)
        }

        pub fn clear_isbot(&mut self) {
            self.isbot = ::std::option::Option::None;
        }

        pub fn has_isbot(&self) -> bool {
            self.isbot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_isbot(&mut self, v: bool) {
            self.isbot = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(8);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entindex",
                |m: &PlayerData| { &m.entindex },
                |m: &mut PlayerData| { &mut m.entindex },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "xuid",
                |m: &PlayerData| { &m.xuid },
                |m: &mut PlayerData| { &mut m.xuid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &PlayerData| { &m.name },
                |m: &mut PlayerData| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "teamnumber",
                |m: &PlayerData| { &m.teamnumber },
                |m: &mut PlayerData| { &mut m.teamnumber },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Accolade>(
                "nomination",
                |m: &PlayerData| { &m.nomination },
                |m: &mut PlayerData| { &mut m.nomination },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "items",
                |m: &PlayerData| { &m.items },
                |m: &mut PlayerData| { &mut m.items },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "playercolor",
                |m: &PlayerData| { &m.playercolor },
                |m: &mut PlayerData| { &mut m.playercolor },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "isbot",
                |m: &PlayerData| { &m.isbot },
                |m: &mut PlayerData| { &mut m.isbot },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerData>(
                "CUSRMsg_EndOfMatchAllPlayersData.PlayerData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PlayerData {
        const NAME: &'static str = "PlayerData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.entindex = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.xuid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    26 => {
                        self.name = ::std::option::Option::Some(is.read_tokio_chars()?);
                    },
                    32 => {
                        self.teamnumber = ::std::option::Option::Some(is.read_int32()?);
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.nomination)?;
                    },
                    50 => {
                        self.items.push(is.read_message()?);
                    },
                    56 => {
                        self.playercolor = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.isbot = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.entindex {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.xuid {
                my_size += ::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.teamnumber {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.nomination.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.items {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.playercolor {
                my_size += ::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.isbot {
                my_size += 1 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.entindex {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.xuid {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.teamnumber {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.nomination.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            for v in &self.items {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            if let Some(v) = self.playercolor {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.isbot {
                os.write_bool(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerData {
            PlayerData::new()
        }

        fn clear(&mut self) {
            self.entindex = ::std::option::Option::None;
            self.xuid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.teamnumber = ::std::option::Option::None;
            self.nomination.clear();
            self.items.clear();
            self.playercolor = ::std::option::Option::None;
            self.isbot = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerData {
            static instance: PlayerData = PlayerData {
                entindex: ::std::option::Option::None,
                xuid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                teamnumber: ::std::option::Option::None,
                nomination: ::protobuf::MessageField::none(),
                items: ::std::vec::Vec::new(),
                playercolor: ::std::option::Option::None,
                isbot: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PlayerData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUSRMsg_EndOfMatchAllPlayersData.PlayerData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PlayerData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PlayerData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_RoundImpactScoreData)
pub struct CUSRMsg_RoundImpactScoreData {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.init_conditions)
    pub init_conditions: ::protobuf::MessageField<cusrmsg_round_impact_score_data::InitialConditions>,
    // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.all_ris_event_data)
    pub all_ris_event_data: ::std::vec::Vec<cusrmsg_round_impact_score_data::RisEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_RoundImpactScoreData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_RoundImpactScoreData {
    fn default() -> &'a CUSRMsg_RoundImpactScoreData {
        <CUSRMsg_RoundImpactScoreData as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_RoundImpactScoreData {
    pub fn new() -> CUSRMsg_RoundImpactScoreData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cusrmsg_round_impact_score_data::InitialConditions>(
            "init_conditions",
            |m: &CUSRMsg_RoundImpactScoreData| { &m.init_conditions },
            |m: &mut CUSRMsg_RoundImpactScoreData| { &mut m.init_conditions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "all_ris_event_data",
            |m: &CUSRMsg_RoundImpactScoreData| { &m.all_ris_event_data },
            |m: &mut CUSRMsg_RoundImpactScoreData| { &mut m.all_ris_event_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_RoundImpactScoreData>(
            "CUSRMsg_RoundImpactScoreData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_RoundImpactScoreData {
    const NAME: &'static str = "CUSRMsg_RoundImpactScoreData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.init_conditions)?;
                },
                18 => {
                    self.all_ris_event_data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.init_conditions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.all_ris_event_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.init_conditions.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.all_ris_event_data {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_RoundImpactScoreData {
        CUSRMsg_RoundImpactScoreData::new()
    }

    fn clear(&mut self) {
        self.init_conditions.clear();
        self.all_ris_event_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_RoundImpactScoreData {
        static instance: CUSRMsg_RoundImpactScoreData = CUSRMsg_RoundImpactScoreData {
            init_conditions: ::protobuf::MessageField::none(),
            all_ris_event_data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_RoundImpactScoreData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_RoundImpactScoreData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_RoundImpactScoreData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_RoundImpactScoreData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CUSRMsg_RoundImpactScoreData`
pub mod cusrmsg_round_impact_score_data {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CUSRMsg_RoundImpactScoreData.RisEvent)
    pub struct RisEvent {
        // message fields
        // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.timestamp)
        pub timestamp: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.terrorist_odds)
        pub terrorist_odds: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.ct_alive)
        pub ct_alive: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.t_alive)
        pub t_alive: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.victim_data)
        pub victim_data: ::protobuf::MessageField<ris_event::Victim>,
        // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.objective_data)
        pub objective_data: ::protobuf::MessageField<ris_event::Objective>,
        // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.all_damage_data)
        pub all_damage_data: ::std::vec::Vec<ris_event::Damage>,
        // special fields
        // @@protoc_insertion_point(special_field:CUSRMsg_RoundImpactScoreData.RisEvent.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RisEvent {
        fn default() -> &'a RisEvent {
            <RisEvent as ::protobuf::Message>::default_instance()
        }
    }

    impl RisEvent {
        pub fn new() -> RisEvent {
            ::std::default::Default::default()
        }

        // optional float timestamp = 1;

        pub fn timestamp(&self) -> f32 {
            self.timestamp.unwrap_or(0.)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: f32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional int32 terrorist_odds = 2;

        pub fn terrorist_odds(&self) -> i32 {
            self.terrorist_odds.unwrap_or(0)
        }

        pub fn clear_terrorist_odds(&mut self) {
            self.terrorist_odds = ::std::option::Option::None;
        }

        pub fn has_terrorist_odds(&self) -> bool {
            self.terrorist_odds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_terrorist_odds(&mut self, v: i32) {
            self.terrorist_odds = ::std::option::Option::Some(v);
        }

        // optional int32 ct_alive = 3;

        pub fn ct_alive(&self) -> i32 {
            self.ct_alive.unwrap_or(0)
        }

        pub fn clear_ct_alive(&mut self) {
            self.ct_alive = ::std::option::Option::None;
        }

        pub fn has_ct_alive(&self) -> bool {
            self.ct_alive.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ct_alive(&mut self, v: i32) {
            self.ct_alive = ::std::option::Option::Some(v);
        }

        // optional int32 t_alive = 4;

        pub fn t_alive(&self) -> i32 {
            self.t_alive.unwrap_or(0)
        }

        pub fn clear_t_alive(&mut self) {
            self.t_alive = ::std::option::Option::None;
        }

        pub fn has_t_alive(&self) -> bool {
            self.t_alive.is_some()
        }

        // Param is passed by value, moved
        pub fn set_t_alive(&mut self, v: i32) {
            self.t_alive = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(7);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "timestamp",
                |m: &RisEvent| { &m.timestamp },
                |m: &mut RisEvent| { &mut m.timestamp },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "terrorist_odds",
                |m: &RisEvent| { &m.terrorist_odds },
                |m: &mut RisEvent| { &mut m.terrorist_odds },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ct_alive",
                |m: &RisEvent| { &m.ct_alive },
                |m: &mut RisEvent| { &mut m.ct_alive },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "t_alive",
                |m: &RisEvent| { &m.t_alive },
                |m: &mut RisEvent| { &mut m.t_alive },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ris_event::Victim>(
                "victim_data",
                |m: &RisEvent| { &m.victim_data },
                |m: &mut RisEvent| { &mut m.victim_data },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ris_event::Objective>(
                "objective_data",
                |m: &RisEvent| { &m.objective_data },
                |m: &mut RisEvent| { &mut m.objective_data },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "all_damage_data",
                |m: &RisEvent| { &m.all_damage_data },
                |m: &mut RisEvent| { &mut m.all_damage_data },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RisEvent>(
                "CUSRMsg_RoundImpactScoreData.RisEvent",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RisEvent {
        const NAME: &'static str = "RisEvent";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.timestamp = ::std::option::Option::Some(is.read_float()?);
                    },
                    16 => {
                        self.terrorist_odds = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.ct_alive = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.t_alive = ::std::option::Option::Some(is.read_int32()?);
                    },
                    42 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.victim_data)?;
                    },
                    50 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.objective_data)?;
                    },
                    58 => {
                        self.all_damage_data.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.timestamp {
                my_size += 1 + 4;
            }
            if let Some(v) = self.terrorist_odds {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.ct_alive {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.t_alive {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.victim_data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.objective_data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.all_damage_data {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.timestamp {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.terrorist_odds {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.ct_alive {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.t_alive {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.victim_data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.objective_data.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            for v in &self.all_damage_data {
                ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RisEvent {
            RisEvent::new()
        }

        fn clear(&mut self) {
            self.timestamp = ::std::option::Option::None;
            self.terrorist_odds = ::std::option::Option::None;
            self.ct_alive = ::std::option::Option::None;
            self.t_alive = ::std::option::Option::None;
            self.victim_data.clear();
            self.objective_data.clear();
            self.all_damage_data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RisEvent {
            static instance: RisEvent = RisEvent {
                timestamp: ::std::option::Option::None,
                terrorist_odds: ::std::option::Option::None,
                ct_alive: ::std::option::Option::None,
                t_alive: ::std::option::Option::None,
                victim_data: ::protobuf::MessageField::none(),
                objective_data: ::protobuf::MessageField::none(),
                all_damage_data: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RisEvent {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUSRMsg_RoundImpactScoreData.RisEvent").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RisEvent {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RisEvent {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `RisEvent`
    pub mod ris_event {
        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:CUSRMsg_RoundImpactScoreData.RisEvent.Victim)
        pub struct Victim {
            // message fields
            // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.Victim.team_number)
            pub team_number: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.Victim.entindex)
            pub entindex: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.Victim.xuid)
            pub xuid: ::std::option::Option<u64>,
            // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.Victim.color)
            pub color: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.Victim.is_bot)
            pub is_bot: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.Victim.is_dead)
            pub is_dead: ::std::option::Option<bool>,
            // special fields
            // @@protoc_insertion_point(special_field:CUSRMsg_RoundImpactScoreData.RisEvent.Victim.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Victim {
            fn default() -> &'a Victim {
                <Victim as ::protobuf::Message>::default_instance()
            }
        }

        impl Victim {
            pub fn new() -> Victim {
                ::std::default::Default::default()
            }

            // optional int32 team_number = 1;

            pub fn team_number(&self) -> i32 {
                self.team_number.unwrap_or(0)
            }

            pub fn clear_team_number(&mut self) {
                self.team_number = ::std::option::Option::None;
            }

            pub fn has_team_number(&self) -> bool {
                self.team_number.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_number(&mut self, v: i32) {
                self.team_number = ::std::option::Option::Some(v);
            }

            // optional int32 entindex = 2;

            pub fn entindex(&self) -> i32 {
                self.entindex.unwrap_or(0)
            }

            pub fn clear_entindex(&mut self) {
                self.entindex = ::std::option::Option::None;
            }

            pub fn has_entindex(&self) -> bool {
                self.entindex.is_some()
            }

            // Param is passed by value, moved
            pub fn set_entindex(&mut self, v: i32) {
                self.entindex = ::std::option::Option::Some(v);
            }

            // optional uint64 xuid = 3;

            pub fn xuid(&self) -> u64 {
                self.xuid.unwrap_or(0)
            }

            pub fn clear_xuid(&mut self) {
                self.xuid = ::std::option::Option::None;
            }

            pub fn has_xuid(&self) -> bool {
                self.xuid.is_some()
            }

            // Param is passed by value, moved
            pub fn set_xuid(&mut self, v: u64) {
                self.xuid = ::std::option::Option::Some(v);
            }

            // optional int32 color = 4;

            pub fn color(&self) -> i32 {
                self.color.unwrap_or(0)
            }

            pub fn clear_color(&mut self) {
                self.color = ::std::option::Option::None;
            }

            pub fn has_color(&self) -> bool {
                self.color.is_some()
            }

            // Param is passed by value, moved
            pub fn set_color(&mut self, v: i32) {
                self.color = ::std::option::Option::Some(v);
            }

            // optional bool is_bot = 5;

            pub fn is_bot(&self) -> bool {
                self.is_bot.unwrap_or(false)
            }

            pub fn clear_is_bot(&mut self) {
                self.is_bot = ::std::option::Option::None;
            }

            pub fn has_is_bot(&self) -> bool {
                self.is_bot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_is_bot(&mut self, v: bool) {
                self.is_bot = ::std::option::Option::Some(v);
            }

            // optional bool is_dead = 6;

            pub fn is_dead(&self) -> bool {
                self.is_dead.unwrap_or(false)
            }

            pub fn clear_is_dead(&mut self) {
                self.is_dead = ::std::option::Option::None;
            }

            pub fn has_is_dead(&self) -> bool {
                self.is_dead.is_some()
            }

            // Param is passed by value, moved
            pub fn set_is_dead(&mut self, v: bool) {
                self.is_dead = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(6);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "team_number",
                    |m: &Victim| { &m.team_number },
                    |m: &mut Victim| { &mut m.team_number },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "entindex",
                    |m: &Victim| { &m.entindex },
                    |m: &mut Victim| { &mut m.entindex },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "xuid",
                    |m: &Victim| { &m.xuid },
                    |m: &mut Victim| { &mut m.xuid },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "color",
                    |m: &Victim| { &m.color },
                    |m: &mut Victim| { &mut m.color },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "is_bot",
                    |m: &Victim| { &m.is_bot },
                    |m: &mut Victim| { &mut m.is_bot },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "is_dead",
                    |m: &Victim| { &m.is_dead },
                    |m: &mut Victim| { &mut m.is_dead },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Victim>(
                    "CUSRMsg_RoundImpactScoreData.RisEvent.Victim",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Victim {
            const NAME: &'static str = "Victim";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.team_number = ::std::option::Option::Some(is.read_int32()?);
                        },
                        16 => {
                            self.entindex = ::std::option::Option::Some(is.read_int32()?);
                        },
                        24 => {
                            self.xuid = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        32 => {
                            self.color = ::std::option::Option::Some(is.read_int32()?);
                        },
                        40 => {
                            self.is_bot = ::std::option::Option::Some(is.read_bool()?);
                        },
                        48 => {
                            self.is_dead = ::std::option::Option::Some(is.read_bool()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.team_number {
                    my_size += ::protobuf::rt::int32_size(1, v);
                }
                if let Some(v) = self.entindex {
                    my_size += ::protobuf::rt::int32_size(2, v);
                }
                if let Some(v) = self.xuid {
                    my_size += ::protobuf::rt::uint64_size(3, v);
                }
                if let Some(v) = self.color {
                    my_size += ::protobuf::rt::int32_size(4, v);
                }
                if let Some(v) = self.is_bot {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.is_dead {
                    my_size += 1 + 1;
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.team_number {
                    os.write_int32(1, v)?;
                }
                if let Some(v) = self.entindex {
                    os.write_int32(2, v)?;
                }
                if let Some(v) = self.xuid {
                    os.write_uint64(3, v)?;
                }
                if let Some(v) = self.color {
                    os.write_int32(4, v)?;
                }
                if let Some(v) = self.is_bot {
                    os.write_bool(5, v)?;
                }
                if let Some(v) = self.is_dead {
                    os.write_bool(6, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Victim {
                Victim::new()
            }

            fn clear(&mut self) {
                self.team_number = ::std::option::Option::None;
                self.entindex = ::std::option::Option::None;
                self.xuid = ::std::option::Option::None;
                self.color = ::std::option::Option::None;
                self.is_bot = ::std::option::Option::None;
                self.is_dead = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Victim {
                static instance: Victim = Victim {
                    team_number: ::std::option::Option::None,
                    entindex: ::std::option::Option::None,
                    xuid: ::std::option::Option::None,
                    color: ::std::option::Option::None,
                    is_bot: ::std::option::Option::None,
                    is_dead: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Victim {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CUSRMsg_RoundImpactScoreData.RisEvent.Victim").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Victim {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Victim {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:CUSRMsg_RoundImpactScoreData.RisEvent.Objective)
        pub struct Objective {
            // message fields
            // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.Objective.type)
            pub type_: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:CUSRMsg_RoundImpactScoreData.RisEvent.Objective.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Objective {
            fn default() -> &'a Objective {
                <Objective as ::protobuf::Message>::default_instance()
            }
        }

        impl Objective {
            pub fn new() -> Objective {
                ::std::default::Default::default()
            }

            // optional int32 type = 1;

            pub fn type_(&self) -> i32 {
                self.type_.unwrap_or(0)
            }

            pub fn clear_type_(&mut self) {
                self.type_ = ::std::option::Option::None;
            }

            pub fn has_type(&self) -> bool {
                self.type_.is_some()
            }

            // Param is passed by value, moved
            pub fn set_type(&mut self, v: i32) {
                self.type_ = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(1);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "type",
                    |m: &Objective| { &m.type_ },
                    |m: &mut Objective| { &mut m.type_ },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Objective>(
                    "CUSRMsg_RoundImpactScoreData.RisEvent.Objective",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Objective {
            const NAME: &'static str = "Objective";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.type_ = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.type_ {
                    my_size += ::protobuf::rt::int32_size(1, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.type_ {
                    os.write_int32(1, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Objective {
                Objective::new()
            }

            fn clear(&mut self) {
                self.type_ = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Objective {
                static instance: Objective = Objective {
                    type_: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Objective {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CUSRMsg_RoundImpactScoreData.RisEvent.Objective").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Objective {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Objective {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }

        #[derive(PartialEq,Clone,Default,Debug)]
        // @@protoc_insertion_point(message:CUSRMsg_RoundImpactScoreData.RisEvent.Damage)
        pub struct Damage {
            // message fields
            // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.Damage.target_entindex)
            pub target_entindex: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.Damage.target_xuid)
            pub target_xuid: ::std::option::Option<u64>,
            // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.Damage.health_removed)
            pub health_removed: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.Damage.num_hits)
            pub num_hits: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.Damage.return_health_removed)
            pub return_health_removed: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.RisEvent.Damage.num_return_hits)
            pub num_return_hits: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:CUSRMsg_RoundImpactScoreData.RisEvent.Damage.special_fields)
            pub special_fields: ::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Damage {
            fn default() -> &'a Damage {
                <Damage as ::protobuf::Message>::default_instance()
            }
        }

        impl Damage {
            pub fn new() -> Damage {
                ::std::default::Default::default()
            }

            // optional int32 target_entindex = 1;

            pub fn target_entindex(&self) -> i32 {
                self.target_entindex.unwrap_or(0)
            }

            pub fn clear_target_entindex(&mut self) {
                self.target_entindex = ::std::option::Option::None;
            }

            pub fn has_target_entindex(&self) -> bool {
                self.target_entindex.is_some()
            }

            // Param is passed by value, moved
            pub fn set_target_entindex(&mut self, v: i32) {
                self.target_entindex = ::std::option::Option::Some(v);
            }

            // optional uint64 target_xuid = 2;

            pub fn target_xuid(&self) -> u64 {
                self.target_xuid.unwrap_or(0)
            }

            pub fn clear_target_xuid(&mut self) {
                self.target_xuid = ::std::option::Option::None;
            }

            pub fn has_target_xuid(&self) -> bool {
                self.target_xuid.is_some()
            }

            // Param is passed by value, moved
            pub fn set_target_xuid(&mut self, v: u64) {
                self.target_xuid = ::std::option::Option::Some(v);
            }

            // optional int32 health_removed = 3;

            pub fn health_removed(&self) -> i32 {
                self.health_removed.unwrap_or(0)
            }

            pub fn clear_health_removed(&mut self) {
                self.health_removed = ::std::option::Option::None;
            }

            pub fn has_health_removed(&self) -> bool {
                self.health_removed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_health_removed(&mut self, v: i32) {
                self.health_removed = ::std::option::Option::Some(v);
            }

            // optional int32 num_hits = 4;

            pub fn num_hits(&self) -> i32 {
                self.num_hits.unwrap_or(0)
            }

            pub fn clear_num_hits(&mut self) {
                self.num_hits = ::std::option::Option::None;
            }

            pub fn has_num_hits(&self) -> bool {
                self.num_hits.is_some()
            }

            // Param is passed by value, moved
            pub fn set_num_hits(&mut self, v: i32) {
                self.num_hits = ::std::option::Option::Some(v);
            }

            // optional int32 return_health_removed = 5;

            pub fn return_health_removed(&self) -> i32 {
                self.return_health_removed.unwrap_or(0)
            }

            pub fn clear_return_health_removed(&mut self) {
                self.return_health_removed = ::std::option::Option::None;
            }

            pub fn has_return_health_removed(&self) -> bool {
                self.return_health_removed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_return_health_removed(&mut self, v: i32) {
                self.return_health_removed = ::std::option::Option::Some(v);
            }

            // optional int32 num_return_hits = 6;

            pub fn num_return_hits(&self) -> i32 {
                self.num_return_hits.unwrap_or(0)
            }

            pub fn clear_num_return_hits(&mut self) {
                self.num_return_hits = ::std::option::Option::None;
            }

            pub fn has_num_return_hits(&self) -> bool {
                self.num_return_hits.is_some()
            }

            // Param is passed by value, moved
            pub fn set_num_return_hits(&mut self, v: i32) {
                self.num_return_hits = ::std::option::Option::Some(v);
            }

            pub(in super::super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
                let mut fields = ::std::vec::Vec::with_capacity(6);
                let mut oneofs = ::std::vec::Vec::with_capacity(0);
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "target_entindex",
                    |m: &Damage| { &m.target_entindex },
                    |m: &mut Damage| { &mut m.target_entindex },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "target_xuid",
                    |m: &Damage| { &m.target_xuid },
                    |m: &mut Damage| { &mut m.target_xuid },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "health_removed",
                    |m: &Damage| { &m.health_removed },
                    |m: &mut Damage| { &mut m.health_removed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "num_hits",
                    |m: &Damage| { &m.num_hits },
                    |m: &mut Damage| { &mut m.num_hits },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "return_health_removed",
                    |m: &Damage| { &m.return_health_removed },
                    |m: &mut Damage| { &mut m.return_health_removed },
                ));
                fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                    "num_return_hits",
                    |m: &Damage| { &m.num_return_hits },
                    |m: &mut Damage| { &mut m.num_return_hits },
                ));
                ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Damage>(
                    "CUSRMsg_RoundImpactScoreData.RisEvent.Damage",
                    fields,
                    oneofs,
                )
            }
        }

        impl ::protobuf::Message for Damage {
            const NAME: &'static str = "Damage";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.target_entindex = ::std::option::Option::Some(is.read_int32()?);
                        },
                        16 => {
                            self.target_xuid = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        24 => {
                            self.health_removed = ::std::option::Option::Some(is.read_int32()?);
                        },
                        32 => {
                            self.num_hits = ::std::option::Option::Some(is.read_int32()?);
                        },
                        40 => {
                            self.return_health_removed = ::std::option::Option::Some(is.read_int32()?);
                        },
                        48 => {
                            self.num_return_hits = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.target_entindex {
                    my_size += ::protobuf::rt::int32_size(1, v);
                }
                if let Some(v) = self.target_xuid {
                    my_size += ::protobuf::rt::uint64_size(2, v);
                }
                if let Some(v) = self.health_removed {
                    my_size += ::protobuf::rt::int32_size(3, v);
                }
                if let Some(v) = self.num_hits {
                    my_size += ::protobuf::rt::int32_size(4, v);
                }
                if let Some(v) = self.return_health_removed {
                    my_size += ::protobuf::rt::int32_size(5, v);
                }
                if let Some(v) = self.num_return_hits {
                    my_size += ::protobuf::rt::int32_size(6, v);
                }
                my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
                if let Some(v) = self.target_entindex {
                    os.write_int32(1, v)?;
                }
                if let Some(v) = self.target_xuid {
                    os.write_uint64(2, v)?;
                }
                if let Some(v) = self.health_removed {
                    os.write_int32(3, v)?;
                }
                if let Some(v) = self.num_hits {
                    os.write_int32(4, v)?;
                }
                if let Some(v) = self.return_health_removed {
                    os.write_int32(5, v)?;
                }
                if let Some(v) = self.num_return_hits {
                    os.write_int32(6, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Damage {
                Damage::new()
            }

            fn clear(&mut self) {
                self.target_entindex = ::std::option::Option::None;
                self.target_xuid = ::std::option::Option::None;
                self.health_removed = ::std::option::Option::None;
                self.num_hits = ::std::option::Option::None;
                self.return_health_removed = ::std::option::Option::None;
                self.num_return_hits = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Damage {
                static instance: Damage = Damage {
                    target_entindex: ::std::option::Option::None,
                    target_xuid: ::std::option::Option::None,
                    health_removed: ::std::option::Option::None,
                    num_hits: ::std::option::Option::None,
                    return_health_removed: ::std::option::Option::None,
                    num_return_hits: ::std::option::Option::None,
                    special_fields: ::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        impl ::protobuf::MessageFull for Damage {
            fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().message_by_package_relative_name("CUSRMsg_RoundImpactScoreData.RisEvent.Damage").unwrap()).clone()
            }
        }

        impl ::std::fmt::Display for Damage {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                ::protobuf::text_format::fmt(self, f)
            }
        }

        impl ::protobuf::reflect::ProtobufValue for Damage {
            type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
        }
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CUSRMsg_RoundImpactScoreData.InitialConditions)
    pub struct InitialConditions {
        // message fields
        // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.InitialConditions.ct_equip_value)
        pub ct_equip_value: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.InitialConditions.t_equip_value)
        pub t_equip_value: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_RoundImpactScoreData.InitialConditions.terrorist_odds)
        pub terrorist_odds: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUSRMsg_RoundImpactScoreData.InitialConditions.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a InitialConditions {
        fn default() -> &'a InitialConditions {
            <InitialConditions as ::protobuf::Message>::default_instance()
        }
    }

    impl InitialConditions {
        pub fn new() -> InitialConditions {
            ::std::default::Default::default()
        }

        // optional int32 ct_equip_value = 1;

        pub fn ct_equip_value(&self) -> i32 {
            self.ct_equip_value.unwrap_or(0)
        }

        pub fn clear_ct_equip_value(&mut self) {
            self.ct_equip_value = ::std::option::Option::None;
        }

        pub fn has_ct_equip_value(&self) -> bool {
            self.ct_equip_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ct_equip_value(&mut self, v: i32) {
            self.ct_equip_value = ::std::option::Option::Some(v);
        }

        // optional int32 t_equip_value = 2;

        pub fn t_equip_value(&self) -> i32 {
            self.t_equip_value.unwrap_or(0)
        }

        pub fn clear_t_equip_value(&mut self) {
            self.t_equip_value = ::std::option::Option::None;
        }

        pub fn has_t_equip_value(&self) -> bool {
            self.t_equip_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_t_equip_value(&mut self, v: i32) {
            self.t_equip_value = ::std::option::Option::Some(v);
        }

        // optional int32 terrorist_odds = 3;

        pub fn terrorist_odds(&self) -> i32 {
            self.terrorist_odds.unwrap_or(0)
        }

        pub fn clear_terrorist_odds(&mut self) {
            self.terrorist_odds = ::std::option::Option::None;
        }

        pub fn has_terrorist_odds(&self) -> bool {
            self.terrorist_odds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_terrorist_odds(&mut self, v: i32) {
            self.terrorist_odds = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "ct_equip_value",
                |m: &InitialConditions| { &m.ct_equip_value },
                |m: &mut InitialConditions| { &mut m.ct_equip_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "t_equip_value",
                |m: &InitialConditions| { &m.t_equip_value },
                |m: &mut InitialConditions| { &mut m.t_equip_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "terrorist_odds",
                |m: &InitialConditions| { &m.terrorist_odds },
                |m: &mut InitialConditions| { &mut m.terrorist_odds },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<InitialConditions>(
                "CUSRMsg_RoundImpactScoreData.InitialConditions",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for InitialConditions {
        const NAME: &'static str = "InitialConditions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.ct_equip_value = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.t_equip_value = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.terrorist_odds = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.ct_equip_value {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.t_equip_value {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.terrorist_odds {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.ct_equip_value {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.t_equip_value {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.terrorist_odds {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> InitialConditions {
            InitialConditions::new()
        }

        fn clear(&mut self) {
            self.ct_equip_value = ::std::option::Option::None;
            self.t_equip_value = ::std::option::Option::None;
            self.terrorist_odds = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static InitialConditions {
            static instance: InitialConditions = InitialConditions {
                ct_equip_value: ::std::option::Option::None,
                t_equip_value: ::std::option::Option::None,
                terrorist_odds: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for InitialConditions {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUSRMsg_RoundImpactScoreData.InitialConditions").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for InitialConditions {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for InitialConditions {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_CurrentRoundOdds)
pub struct CUSRMsg_CurrentRoundOdds {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_CurrentRoundOdds.odds)
    pub odds: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_CurrentRoundOdds.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_CurrentRoundOdds {
    fn default() -> &'a CUSRMsg_CurrentRoundOdds {
        <CUSRMsg_CurrentRoundOdds as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_CurrentRoundOdds {
    pub fn new() -> CUSRMsg_CurrentRoundOdds {
        ::std::default::Default::default()
    }

    // optional int32 odds = 1;

    pub fn odds(&self) -> i32 {
        self.odds.unwrap_or(0)
    }

    pub fn clear_odds(&mut self) {
        self.odds = ::std::option::Option::None;
    }

    pub fn has_odds(&self) -> bool {
        self.odds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_odds(&mut self, v: i32) {
        self.odds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "odds",
            |m: &CUSRMsg_CurrentRoundOdds| { &m.odds },
            |m: &mut CUSRMsg_CurrentRoundOdds| { &mut m.odds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_CurrentRoundOdds>(
            "CUSRMsg_CurrentRoundOdds",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_CurrentRoundOdds {
    const NAME: &'static str = "CUSRMsg_CurrentRoundOdds";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.odds = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.odds {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.odds {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_CurrentRoundOdds {
        CUSRMsg_CurrentRoundOdds::new()
    }

    fn clear(&mut self) {
        self.odds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_CurrentRoundOdds {
        static instance: CUSRMsg_CurrentRoundOdds = CUSRMsg_CurrentRoundOdds {
            odds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_CurrentRoundOdds {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_CurrentRoundOdds").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_CurrentRoundOdds {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_CurrentRoundOdds {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_DeepStats)
pub struct CUSRMsg_DeepStats {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_DeepStats.stats)
    pub stats: ::protobuf::MessageField<super::cstrike15_gcmessages::CMsgGCCStrike15_ClientDeepStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_DeepStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_DeepStats {
    fn default() -> &'a CUSRMsg_DeepStats {
        <CUSRMsg_DeepStats as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_DeepStats {
    pub fn new() -> CUSRMsg_DeepStats {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::cstrike15_gcmessages::CMsgGCCStrike15_ClientDeepStats>(
            "stats",
            |m: &CUSRMsg_DeepStats| { &m.stats },
            |m: &mut CUSRMsg_DeepStats| { &mut m.stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_DeepStats>(
            "CUSRMsg_DeepStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_DeepStats {
    const NAME: &'static str = "CUSRMsg_DeepStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stats)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_DeepStats {
        CUSRMsg_DeepStats::new()
    }

    fn clear(&mut self) {
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_DeepStats {
        static instance: CUSRMsg_DeepStats = CUSRMsg_DeepStats {
            stats: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_DeepStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_DeepStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_DeepStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_DeepStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_ResetHud)
pub struct CUSRMsg_ResetHud {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_ResetHud.reset)
    pub reset: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_ResetHud.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_ResetHud {
    fn default() -> &'a CUSRMsg_ResetHud {
        <CUSRMsg_ResetHud as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_ResetHud {
    pub fn new() -> CUSRMsg_ResetHud {
        ::std::default::Default::default()
    }

    // optional bool reset = 1;

    pub fn reset(&self) -> bool {
        self.reset.unwrap_or(false)
    }

    pub fn clear_reset(&mut self) {
        self.reset = ::std::option::Option::None;
    }

    pub fn has_reset(&self) -> bool {
        self.reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reset(&mut self, v: bool) {
        self.reset = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reset",
            |m: &CUSRMsg_ResetHud| { &m.reset },
            |m: &mut CUSRMsg_ResetHud| { &mut m.reset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_ResetHud>(
            "CUSRMsg_ResetHud",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_ResetHud {
    const NAME: &'static str = "CUSRMsg_ResetHud";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reset = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reset {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reset {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_ResetHud {
        CUSRMsg_ResetHud::new()
    }

    fn clear(&mut self) {
        self.reset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_ResetHud {
        static instance: CUSRMsg_ResetHud = CUSRMsg_ResetHud {
            reset: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_ResetHud {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_ResetHud").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_ResetHud {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_ResetHud {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_GameTitle)
pub struct CUSRMsg_GameTitle {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_GameTitle.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_GameTitle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_GameTitle {
    fn default() -> &'a CUSRMsg_GameTitle {
        <CUSRMsg_GameTitle as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_GameTitle {
    pub fn new() -> CUSRMsg_GameTitle {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dummy",
            |m: &CUSRMsg_GameTitle| { &m.dummy },
            |m: &mut CUSRMsg_GameTitle| { &mut m.dummy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_GameTitle>(
            "CUSRMsg_GameTitle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_GameTitle {
    const NAME: &'static str = "CUSRMsg_GameTitle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_GameTitle {
        CUSRMsg_GameTitle::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_GameTitle {
        static instance: CUSRMsg_GameTitle = CUSRMsg_GameTitle {
            dummy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_GameTitle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_GameTitle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_GameTitle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_GameTitle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_RequestState)
pub struct CUSRMsg_RequestState {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_RequestState.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_RequestState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_RequestState {
    fn default() -> &'a CUSRMsg_RequestState {
        <CUSRMsg_RequestState as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_RequestState {
    pub fn new() -> CUSRMsg_RequestState {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dummy",
            |m: &CUSRMsg_RequestState| { &m.dummy },
            |m: &mut CUSRMsg_RequestState| { &mut m.dummy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_RequestState>(
            "CUSRMsg_RequestState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_RequestState {
    const NAME: &'static str = "CUSRMsg_RequestState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_RequestState {
        CUSRMsg_RequestState::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_RequestState {
        static instance: CUSRMsg_RequestState = CUSRMsg_RequestState {
            dummy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_RequestState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_RequestState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_RequestState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_RequestState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_StopSpectatorMode)
pub struct CUSRMsg_StopSpectatorMode {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_StopSpectatorMode.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_StopSpectatorMode.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_StopSpectatorMode {
    fn default() -> &'a CUSRMsg_StopSpectatorMode {
        <CUSRMsg_StopSpectatorMode as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_StopSpectatorMode {
    pub fn new() -> CUSRMsg_StopSpectatorMode {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dummy",
            |m: &CUSRMsg_StopSpectatorMode| { &m.dummy },
            |m: &mut CUSRMsg_StopSpectatorMode| { &mut m.dummy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_StopSpectatorMode>(
            "CUSRMsg_StopSpectatorMode",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_StopSpectatorMode {
    const NAME: &'static str = "CUSRMsg_StopSpectatorMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_StopSpectatorMode {
        CUSRMsg_StopSpectatorMode::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_StopSpectatorMode {
        static instance: CUSRMsg_StopSpectatorMode = CUSRMsg_StopSpectatorMode {
            dummy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_StopSpectatorMode {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_StopSpectatorMode").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_StopSpectatorMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_StopSpectatorMode {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_DisconnectToLobby)
pub struct CUSRMsg_DisconnectToLobby {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_DisconnectToLobby.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_DisconnectToLobby.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_DisconnectToLobby {
    fn default() -> &'a CUSRMsg_DisconnectToLobby {
        <CUSRMsg_DisconnectToLobby as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_DisconnectToLobby {
    pub fn new() -> CUSRMsg_DisconnectToLobby {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dummy",
            |m: &CUSRMsg_DisconnectToLobby| { &m.dummy },
            |m: &mut CUSRMsg_DisconnectToLobby| { &mut m.dummy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_DisconnectToLobby>(
            "CUSRMsg_DisconnectToLobby",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_DisconnectToLobby {
    const NAME: &'static str = "CUSRMsg_DisconnectToLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_DisconnectToLobby {
        CUSRMsg_DisconnectToLobby::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_DisconnectToLobby {
        static instance: CUSRMsg_DisconnectToLobby = CUSRMsg_DisconnectToLobby {
            dummy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_DisconnectToLobby {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_DisconnectToLobby").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_DisconnectToLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_DisconnectToLobby {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_WarmupHasEnded)
pub struct CUSRMsg_WarmupHasEnded {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_WarmupHasEnded.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_WarmupHasEnded.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_WarmupHasEnded {
    fn default() -> &'a CUSRMsg_WarmupHasEnded {
        <CUSRMsg_WarmupHasEnded as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_WarmupHasEnded {
    pub fn new() -> CUSRMsg_WarmupHasEnded {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dummy",
            |m: &CUSRMsg_WarmupHasEnded| { &m.dummy },
            |m: &mut CUSRMsg_WarmupHasEnded| { &mut m.dummy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_WarmupHasEnded>(
            "CUSRMsg_WarmupHasEnded",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_WarmupHasEnded {
    const NAME: &'static str = "CUSRMsg_WarmupHasEnded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_WarmupHasEnded {
        CUSRMsg_WarmupHasEnded::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_WarmupHasEnded {
        static instance: CUSRMsg_WarmupHasEnded = CUSRMsg_WarmupHasEnded {
            dummy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_WarmupHasEnded {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_WarmupHasEnded").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_WarmupHasEnded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_WarmupHasEnded {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_ClientInfo)
pub struct CUSRMsg_ClientInfo {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_ClientInfo.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_ClientInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_ClientInfo {
    fn default() -> &'a CUSRMsg_ClientInfo {
        <CUSRMsg_ClientInfo as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_ClientInfo {
    pub fn new() -> CUSRMsg_ClientInfo {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dummy",
            |m: &CUSRMsg_ClientInfo| { &m.dummy },
            |m: &mut CUSRMsg_ClientInfo| { &mut m.dummy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_ClientInfo>(
            "CUSRMsg_ClientInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_ClientInfo {
    const NAME: &'static str = "CUSRMsg_ClientInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_ClientInfo {
        CUSRMsg_ClientInfo::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_ClientInfo {
        static instance: CUSRMsg_ClientInfo = CUSRMsg_ClientInfo {
            dummy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_ClientInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_ClientInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_ClientInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_ClientInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_ServerRankRevealAll)
pub struct CUSRMsg_ServerRankRevealAll {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_ServerRankRevealAll.seconds_till_shutdown)
    pub seconds_till_shutdown: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_ServerRankRevealAll.reservation)
    pub reservation: ::protobuf::MessageField<super::cstrike15_gcmessages::CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_ServerRankRevealAll.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_ServerRankRevealAll {
    fn default() -> &'a CUSRMsg_ServerRankRevealAll {
        <CUSRMsg_ServerRankRevealAll as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_ServerRankRevealAll {
    pub fn new() -> CUSRMsg_ServerRankRevealAll {
        ::std::default::Default::default()
    }

    // optional int32 seconds_till_shutdown = 1;

    pub fn seconds_till_shutdown(&self) -> i32 {
        self.seconds_till_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_till_shutdown(&mut self) {
        self.seconds_till_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_till_shutdown(&self) -> bool {
        self.seconds_till_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_till_shutdown(&mut self, v: i32) {
        self.seconds_till_shutdown = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds_till_shutdown",
            |m: &CUSRMsg_ServerRankRevealAll| { &m.seconds_till_shutdown },
            |m: &mut CUSRMsg_ServerRankRevealAll| { &mut m.seconds_till_shutdown },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::cstrike15_gcmessages::CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>(
            "reservation",
            |m: &CUSRMsg_ServerRankRevealAll| { &m.reservation },
            |m: &mut CUSRMsg_ServerRankRevealAll| { &mut m.reservation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_ServerRankRevealAll>(
            "CUSRMsg_ServerRankRevealAll",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_ServerRankRevealAll {
    const NAME: &'static str = "CUSRMsg_ServerRankRevealAll";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.seconds_till_shutdown = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reservation)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.seconds_till_shutdown {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.seconds_till_shutdown {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.reservation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_ServerRankRevealAll {
        CUSRMsg_ServerRankRevealAll::new()
    }

    fn clear(&mut self) {
        self.seconds_till_shutdown = ::std::option::Option::None;
        self.reservation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_ServerRankRevealAll {
        static instance: CUSRMsg_ServerRankRevealAll = CUSRMsg_ServerRankRevealAll {
            seconds_till_shutdown: ::std::option::Option::None,
            reservation: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_ServerRankRevealAll {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_ServerRankRevealAll").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_ServerRankRevealAll {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_ServerRankRevealAll {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_UtilMessage)
pub struct CUSRMsg_UtilMessage {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_UtilMessage.util_action)
    pub util_action: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CUSRMsg_UtilMessage.util1)
    pub util1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_UtilMessage.util2)
    pub util2: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_UtilMessage.util3)
    pub util3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_UtilMessage.util4)
    pub util4: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_UtilMessage.util5)
    pub util5: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_UtilMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_UtilMessage {
    fn default() -> &'a CUSRMsg_UtilMessage {
        <CUSRMsg_UtilMessage as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_UtilMessage {
    pub fn new() -> CUSRMsg_UtilMessage {
        ::std::default::Default::default()
    }

    // optional string util_action = 1;

    pub fn util_action(&self) -> &str {
        match self.util_action.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_util_action(&mut self) {
        self.util_action = ::std::option::Option::None;
    }

    pub fn has_util_action(&self) -> bool {
        self.util_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_util_action(&mut self, v: ::protobuf::Chars) {
        self.util_action = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_util_action(&mut self) -> &mut ::protobuf::Chars {
        if self.util_action.is_none() {
            self.util_action = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.util_action.as_mut().unwrap()
    }

    // Take field
    pub fn take_util_action(&mut self) -> ::protobuf::Chars {
        self.util_action.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional int32 util1 = 2;

    pub fn util1(&self) -> i32 {
        self.util1.unwrap_or(0)
    }

    pub fn clear_util1(&mut self) {
        self.util1 = ::std::option::Option::None;
    }

    pub fn has_util1(&self) -> bool {
        self.util1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_util1(&mut self, v: i32) {
        self.util1 = ::std::option::Option::Some(v);
    }

    // optional int32 util2 = 3;

    pub fn util2(&self) -> i32 {
        self.util2.unwrap_or(0)
    }

    pub fn clear_util2(&mut self) {
        self.util2 = ::std::option::Option::None;
    }

    pub fn has_util2(&self) -> bool {
        self.util2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_util2(&mut self, v: i32) {
        self.util2 = ::std::option::Option::Some(v);
    }

    // optional int32 util3 = 4;

    pub fn util3(&self) -> i32 {
        self.util3.unwrap_or(0)
    }

    pub fn clear_util3(&mut self) {
        self.util3 = ::std::option::Option::None;
    }

    pub fn has_util3(&self) -> bool {
        self.util3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_util3(&mut self, v: i32) {
        self.util3 = ::std::option::Option::Some(v);
    }

    // optional int32 util4 = 5;

    pub fn util4(&self) -> i32 {
        self.util4.unwrap_or(0)
    }

    pub fn clear_util4(&mut self) {
        self.util4 = ::std::option::Option::None;
    }

    pub fn has_util4(&self) -> bool {
        self.util4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_util4(&mut self, v: i32) {
        self.util4 = ::std::option::Option::Some(v);
    }

    // optional int32 util5 = 6;

    pub fn util5(&self) -> i32 {
        self.util5.unwrap_or(0)
    }

    pub fn clear_util5(&mut self) {
        self.util5 = ::std::option::Option::None;
    }

    pub fn has_util5(&self) -> bool {
        self.util5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_util5(&mut self, v: i32) {
        self.util5 = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "util_action",
            |m: &CUSRMsg_UtilMessage| { &m.util_action },
            |m: &mut CUSRMsg_UtilMessage| { &mut m.util_action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "util1",
            |m: &CUSRMsg_UtilMessage| { &m.util1 },
            |m: &mut CUSRMsg_UtilMessage| { &mut m.util1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "util2",
            |m: &CUSRMsg_UtilMessage| { &m.util2 },
            |m: &mut CUSRMsg_UtilMessage| { &mut m.util2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "util3",
            |m: &CUSRMsg_UtilMessage| { &m.util3 },
            |m: &mut CUSRMsg_UtilMessage| { &mut m.util3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "util4",
            |m: &CUSRMsg_UtilMessage| { &m.util4 },
            |m: &mut CUSRMsg_UtilMessage| { &mut m.util4 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "util5",
            |m: &CUSRMsg_UtilMessage| { &m.util5 },
            |m: &mut CUSRMsg_UtilMessage| { &mut m.util5 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_UtilMessage>(
            "CUSRMsg_UtilMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_UtilMessage {
    const NAME: &'static str = "CUSRMsg_UtilMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.util_action = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                16 => {
                    self.util1 = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.util2 = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.util3 = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.util4 = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.util5 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.util_action.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.util1 {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.util2 {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.util3 {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.util4 {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.util5 {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.util_action.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.util1 {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.util2 {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.util3 {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.util4 {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.util5 {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_UtilMessage {
        CUSRMsg_UtilMessage::new()
    }

    fn clear(&mut self) {
        self.util_action = ::std::option::Option::None;
        self.util1 = ::std::option::Option::None;
        self.util2 = ::std::option::Option::None;
        self.util3 = ::std::option::Option::None;
        self.util4 = ::std::option::Option::None;
        self.util5 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_UtilMessage {
        static instance: CUSRMsg_UtilMessage = CUSRMsg_UtilMessage {
            util_action: ::std::option::Option::None,
            util1: ::std::option::Option::None,
            util2: ::std::option::Option::None,
            util3: ::std::option::Option::None,
            util4: ::std::option::Option::None,
            util5: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_UtilMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_UtilMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_UtilMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_UtilMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CUSRMsg_UtilMessageResponse)
pub struct CUSRMsg_UtilMessageResponse {
    // message fields
    // @@protoc_insertion_point(field:CUSRMsg_UtilMessageResponse.crc)
    pub crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUSRMsg_UtilMessageResponse.item_count)
    pub item_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_UtilMessageResponse.crc2)
    pub crc2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUSRMsg_UtilMessageResponse.item_count2)
    pub item_count2: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_UtilMessageResponse.crc_part)
    pub crc_part: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_UtilMessageResponse.crc_part2)
    pub crc_part2: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_UtilMessageResponse.client_timestamp)
    pub client_timestamp: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_UtilMessageResponse.platform)
    pub platform: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUSRMsg_UtilMessageResponse.itemdetails)
    pub itemdetails: ::std::vec::Vec<cusrmsg_util_message_response::ItemDetail>,
    // @@protoc_insertion_point(field:CUSRMsg_UtilMessageResponse.itemgroup)
    pub itemgroup: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUSRMsg_UtilMessageResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUSRMsg_UtilMessageResponse {
    fn default() -> &'a CUSRMsg_UtilMessageResponse {
        <CUSRMsg_UtilMessageResponse as ::protobuf::Message>::default_instance()
    }
}

impl CUSRMsg_UtilMessageResponse {
    pub fn new() -> CUSRMsg_UtilMessageResponse {
        ::std::default::Default::default()
    }

    // optional fixed32 crc = 1;

    pub fn crc(&self) -> u32 {
        self.crc.unwrap_or(0)
    }

    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: u32) {
        self.crc = ::std::option::Option::Some(v);
    }

    // optional int32 item_count = 2;

    pub fn item_count(&self) -> i32 {
        self.item_count.unwrap_or(0)
    }

    pub fn clear_item_count(&mut self) {
        self.item_count = ::std::option::Option::None;
    }

    pub fn has_item_count(&self) -> bool {
        self.item_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_count(&mut self, v: i32) {
        self.item_count = ::std::option::Option::Some(v);
    }

    // optional fixed32 crc2 = 3;

    pub fn crc2(&self) -> u32 {
        self.crc2.unwrap_or(0)
    }

    pub fn clear_crc2(&mut self) {
        self.crc2 = ::std::option::Option::None;
    }

    pub fn has_crc2(&self) -> bool {
        self.crc2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc2(&mut self, v: u32) {
        self.crc2 = ::std::option::Option::Some(v);
    }

    // optional int32 item_count2 = 4;

    pub fn item_count2(&self) -> i32 {
        self.item_count2.unwrap_or(0)
    }

    pub fn clear_item_count2(&mut self) {
        self.item_count2 = ::std::option::Option::None;
    }

    pub fn has_item_count2(&self) -> bool {
        self.item_count2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_count2(&mut self, v: i32) {
        self.item_count2 = ::std::option::Option::Some(v);
    }

    // optional int32 client_timestamp = 7;

    pub fn client_timestamp(&self) -> i32 {
        self.client_timestamp.unwrap_or(0)
    }

    pub fn clear_client_timestamp(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
    }

    pub fn has_client_timestamp(&self) -> bool {
        self.client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_timestamp(&mut self, v: i32) {
        self.client_timestamp = ::std::option::Option::Some(v);
    }

    // optional int32 platform = 8;

    pub fn platform(&self) -> i32 {
        self.platform.unwrap_or(0)
    }

    pub fn clear_platform(&mut self) {
        self.platform = ::std::option::Option::None;
    }

    pub fn has_platform(&self) -> bool {
        self.platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform(&mut self, v: i32) {
        self.platform = ::std::option::Option::Some(v);
    }

    // optional int32 itemgroup = 10;

    pub fn itemgroup(&self) -> i32 {
        self.itemgroup.unwrap_or(0)
    }

    pub fn clear_itemgroup(&mut self) {
        self.itemgroup = ::std::option::Option::None;
    }

    pub fn has_itemgroup(&self) -> bool {
        self.itemgroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemgroup(&mut self, v: i32) {
        self.itemgroup = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crc",
            |m: &CUSRMsg_UtilMessageResponse| { &m.crc },
            |m: &mut CUSRMsg_UtilMessageResponse| { &mut m.crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_count",
            |m: &CUSRMsg_UtilMessageResponse| { &m.item_count },
            |m: &mut CUSRMsg_UtilMessageResponse| { &mut m.item_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crc2",
            |m: &CUSRMsg_UtilMessageResponse| { &m.crc2 },
            |m: &mut CUSRMsg_UtilMessageResponse| { &mut m.crc2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_count2",
            |m: &CUSRMsg_UtilMessageResponse| { &m.item_count2 },
            |m: &mut CUSRMsg_UtilMessageResponse| { &mut m.item_count2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "crc_part",
            |m: &CUSRMsg_UtilMessageResponse| { &m.crc_part },
            |m: &mut CUSRMsg_UtilMessageResponse| { &mut m.crc_part },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "crc_part2",
            |m: &CUSRMsg_UtilMessageResponse| { &m.crc_part2 },
            |m: &mut CUSRMsg_UtilMessageResponse| { &mut m.crc_part2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_timestamp",
            |m: &CUSRMsg_UtilMessageResponse| { &m.client_timestamp },
            |m: &mut CUSRMsg_UtilMessageResponse| { &mut m.client_timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "platform",
            |m: &CUSRMsg_UtilMessageResponse| { &m.platform },
            |m: &mut CUSRMsg_UtilMessageResponse| { &mut m.platform },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "itemdetails",
            |m: &CUSRMsg_UtilMessageResponse| { &m.itemdetails },
            |m: &mut CUSRMsg_UtilMessageResponse| { &mut m.itemdetails },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "itemgroup",
            |m: &CUSRMsg_UtilMessageResponse| { &m.itemgroup },
            |m: &mut CUSRMsg_UtilMessageResponse| { &mut m.itemgroup },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CUSRMsg_UtilMessageResponse>(
            "CUSRMsg_UtilMessageResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CUSRMsg_UtilMessageResponse {
    const NAME: &'static str = "CUSRMsg_UtilMessageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.crc = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.item_count = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.crc2 = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.item_count2 = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.crc_part)?;
                },
                40 => {
                    self.crc_part.push(is.read_int32()?);
                },
                50 => {
                    is.read_repeated_packed_int32_into(&mut self.crc_part2)?;
                },
                48 => {
                    self.crc_part2.push(is.read_int32()?);
                },
                56 => {
                    self.client_timestamp = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.platform = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    self.itemdetails.push(is.read_message()?);
                },
                80 => {
                    self.itemgroup = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.crc {
            my_size += 1 + 4;
        }
        if let Some(v) = self.item_count {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.crc2 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.item_count2 {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        for value in &self.crc_part {
            my_size += ::protobuf::rt::int32_size(5, *value);
        };
        for value in &self.crc_part2 {
            my_size += ::protobuf::rt::int32_size(6, *value);
        };
        if let Some(v) = self.client_timestamp {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.platform {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        for value in &self.itemdetails {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.itemgroup {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.crc {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.item_count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.crc2 {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.item_count2 {
            os.write_int32(4, v)?;
        }
        for v in &self.crc_part {
            os.write_int32(5, *v)?;
        };
        for v in &self.crc_part2 {
            os.write_int32(6, *v)?;
        };
        if let Some(v) = self.client_timestamp {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.platform {
            os.write_int32(8, v)?;
        }
        for v in &self.itemdetails {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.itemgroup {
            os.write_int32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUSRMsg_UtilMessageResponse {
        CUSRMsg_UtilMessageResponse::new()
    }

    fn clear(&mut self) {
        self.crc = ::std::option::Option::None;
        self.item_count = ::std::option::Option::None;
        self.crc2 = ::std::option::Option::None;
        self.item_count2 = ::std::option::Option::None;
        self.crc_part.clear();
        self.crc_part2.clear();
        self.client_timestamp = ::std::option::Option::None;
        self.platform = ::std::option::Option::None;
        self.itemdetails.clear();
        self.itemgroup = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUSRMsg_UtilMessageResponse {
        static instance: CUSRMsg_UtilMessageResponse = CUSRMsg_UtilMessageResponse {
            crc: ::std::option::Option::None,
            item_count: ::std::option::Option::None,
            crc2: ::std::option::Option::None,
            item_count2: ::std::option::Option::None,
            crc_part: ::std::vec::Vec::new(),
            crc_part2: ::std::vec::Vec::new(),
            client_timestamp: ::std::option::Option::None,
            platform: ::std::option::Option::None,
            itemdetails: ::std::vec::Vec::new(),
            itemgroup: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CUSRMsg_UtilMessageResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CUSRMsg_UtilMessageResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CUSRMsg_UtilMessageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CUSRMsg_UtilMessageResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CUSRMsg_UtilMessageResponse`
pub mod cusrmsg_util_message_response {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CUSRMsg_UtilMessageResponse.ItemDetail)
    pub struct ItemDetail {
        // message fields
        // @@protoc_insertion_point(field:CUSRMsg_UtilMessageResponse.ItemDetail.index)
        pub index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_UtilMessageResponse.ItemDetail.hash)
        pub hash: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_UtilMessageResponse.ItemDetail.crc)
        pub crc: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUSRMsg_UtilMessageResponse.ItemDetail.name)
        pub name: ::std::option::Option<::protobuf::Chars>,
        // special fields
        // @@protoc_insertion_point(special_field:CUSRMsg_UtilMessageResponse.ItemDetail.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemDetail {
        fn default() -> &'a ItemDetail {
            <ItemDetail as ::protobuf::Message>::default_instance()
        }
    }

    impl ItemDetail {
        pub fn new() -> ItemDetail {
            ::std::default::Default::default()
        }

        // optional int32 index = 1;

        pub fn index(&self) -> i32 {
            self.index.unwrap_or(0)
        }

        pub fn clear_index(&mut self) {
            self.index = ::std::option::Option::None;
        }

        pub fn has_index(&self) -> bool {
            self.index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_index(&mut self, v: i32) {
            self.index = ::std::option::Option::Some(v);
        }

        // optional int32 hash = 2;

        pub fn hash(&self) -> i32 {
            self.hash.unwrap_or(0)
        }

        pub fn clear_hash(&mut self) {
            self.hash = ::std::option::Option::None;
        }

        pub fn has_hash(&self) -> bool {
            self.hash.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hash(&mut self, v: i32) {
            self.hash = ::std::option::Option::Some(v);
        }

        // optional int32 crc = 3;

        pub fn crc(&self) -> i32 {
            self.crc.unwrap_or(0)
        }

        pub fn clear_crc(&mut self) {
            self.crc = ::std::option::Option::None;
        }

        pub fn has_crc(&self) -> bool {
            self.crc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_crc(&mut self, v: i32) {
            self.crc = ::std::option::Option::Some(v);
        }

        // optional string name = 4;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::protobuf::Chars) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::protobuf::Chars {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::protobuf::Chars::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::protobuf::Chars {
            self.name.take().unwrap_or_else(|| ::protobuf::Chars::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "index",
                |m: &ItemDetail| { &m.index },
                |m: &mut ItemDetail| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "hash",
                |m: &ItemDetail| { &m.hash },
                |m: &mut ItemDetail| { &mut m.hash },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "crc",
                |m: &ItemDetail| { &m.crc },
                |m: &mut ItemDetail| { &mut m.crc },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &ItemDetail| { &m.name },
                |m: &mut ItemDetail| { &mut m.name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ItemDetail>(
                "CUSRMsg_UtilMessageResponse.ItemDetail",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ItemDetail {
        const NAME: &'static str = "ItemDetail";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.hash = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.crc = ::std::option::Option::Some(is.read_int32()?);
                    },
                    34 => {
                        self.name = ::std::option::Option::Some(is.read_tokio_chars()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.index {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.hash {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.crc {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.index {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.hash {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.crc {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemDetail {
            ItemDetail::new()
        }

        fn clear(&mut self) {
            self.index = ::std::option::Option::None;
            self.hash = ::std::option::Option::None;
            self.crc = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemDetail {
            static instance: ItemDetail = ItemDetail {
                index: ::std::option::Option::None,
                hash: ::std::option::Option::None,
                crc: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ItemDetail {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CUSRMsg_UtilMessageResponse.ItemDetail").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ItemDetail {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ItemDetail {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:USR_Messages)
pub enum USR_Messages {
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_VGUIMenu)
    usr_VGUIMenu = 1,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_Geiger)
    usr_Geiger = 2,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_Train)
    usr_Train = 3,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_HudText)
    usr_HudText = 4,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_SayText)
    usr_SayText = 5,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_SayText2)
    usr_SayText2 = 6,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_TextMsg)
    usr_TextMsg = 7,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_HudMsg)
    usr_HudMsg = 8,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_ResetHud)
    usr_ResetHud = 9,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_GameTitle)
    usr_GameTitle = 10,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_Shake)
    usr_Shake = 12,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_Fade)
    usr_Fade = 13,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_Rumble)
    usr_Rumble = 14,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_CloseCaption)
    usr_CloseCaption = 15,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_CloseCaptionDirect)
    usr_CloseCaptionDirect = 16,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_SendAudio)
    usr_SendAudio = 17,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_RawAudio)
    usr_RawAudio = 18,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_VoiceMask)
    usr_VoiceMask = 19,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_RequestState)
    usr_RequestState = 20,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_Damage)
    usr_Damage = 21,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_RadioText)
    usr_RadioText = 22,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_HintText)
    usr_HintText = 23,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_KeyHintText)
    usr_KeyHintText = 24,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_ProcessSpottedEntityUpdate)
    usr_ProcessSpottedEntityUpdate = 25,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_ReloadEffect)
    usr_ReloadEffect = 26,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_AdjustMoney)
    usr_AdjustMoney = 27,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_UpdateTeamMoney)
    usr_UpdateTeamMoney = 28,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_StopSpectatorMode)
    usr_StopSpectatorMode = 29,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_KillCam)
    usr_KillCam = 30,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_DesiredTimescale)
    usr_DesiredTimescale = 31,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_CurrentTimescale)
    usr_CurrentTimescale = 32,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_AchievementEvent)
    usr_AchievementEvent = 33,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_MatchEndConditions)
    usr_MatchEndConditions = 34,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_DisconnectToLobby)
    usr_DisconnectToLobby = 35,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_PlayerStatsUpdate)
    usr_PlayerStatsUpdate = 36,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_DisplayInventory)
    usr_DisplayInventory = 37,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_WarmupHasEnded)
    usr_WarmupHasEnded = 38,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_ClientInfo)
    usr_ClientInfo = 39,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_XRankGet)
    usr_XRankGet = 40,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_XRankUpd)
    usr_XRankUpd = 41,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_CallVoteFailed)
    usr_CallVoteFailed = 45,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_VoteStart)
    usr_VoteStart = 46,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_VotePass)
    usr_VotePass = 47,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_VoteFailed)
    usr_VoteFailed = 48,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_VoteSetup)
    usr_VoteSetup = 49,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_ServerRankRevealAll)
    usr_ServerRankRevealAll = 50,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_SendLastKillerDamageToClient)
    usr_SendLastKillerDamageToClient = 51,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_ServerRankUpdate)
    usr_ServerRankUpdate = 52,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_ItemPickup)
    usr_ItemPickup = 53,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_ShowMenu)
    usr_ShowMenu = 54,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_BarTime)
    usr_BarTime = 55,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_AmmoDenied)
    usr_AmmoDenied = 56,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_MarkAchievement)
    usr_MarkAchievement = 57,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_MatchStatsUpdate)
    usr_MatchStatsUpdate = 58,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_ItemDrop)
    usr_ItemDrop = 59,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_GlowPropTurnOff)
    usr_GlowPropTurnOff = 60,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_SendPlayerItemDrops)
    usr_SendPlayerItemDrops = 61,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_RoundBackupFilenames)
    usr_RoundBackupFilenames = 62,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_SendPlayerItemFound)
    usr_SendPlayerItemFound = 63,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_ReportHit)
    usr_ReportHit = 64,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_XpUpdate)
    usr_XpUpdate = 65,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_QuestProgress)
    usr_QuestProgress = 66,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_ScoreLeaderboardData)
    usr_ScoreLeaderboardData = 67,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_PlayerDecalDigitalSignature)
    usr_PlayerDecalDigitalSignature = 68,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_WeaponSound)
    usr_WeaponSound = 69,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_UpdateScreenHealthBar)
    usr_UpdateScreenHealthBar = 70,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_EntityOutlineHighlight)
    usr_EntityOutlineHighlight = 71,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_SSUI)
    usr_SSUI = 72,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_SurvivalStats)
    usr_SurvivalStats = 73,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_DisconnectToLobby2)
    usr_DisconnectToLobby2 = 74,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_EndOfMatchAllPlayersData)
    usr_EndOfMatchAllPlayersData = 75,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_RoundImpactScoreData)
    usr_RoundImpactScoreData = 79,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_CurrentRoundOdds)
    usr_CurrentRoundOdds = 80,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_DeepStats)
    usr_DeepStats = 81,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_UtilMessage)
    usr_UtilMessage = 82,
    // @@protoc_insertion_point(enum_value:USR_Messages.usr_UtilMessageResponse)
    usr_UtilMessageResponse = 83,
}

impl ::protobuf::Enum for USR_Messages {
    const NAME: &'static str = "USR_Messages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<USR_Messages> {
        match value {
            1 => ::std::option::Option::Some(USR_Messages::usr_VGUIMenu),
            2 => ::std::option::Option::Some(USR_Messages::usr_Geiger),
            3 => ::std::option::Option::Some(USR_Messages::usr_Train),
            4 => ::std::option::Option::Some(USR_Messages::usr_HudText),
            5 => ::std::option::Option::Some(USR_Messages::usr_SayText),
            6 => ::std::option::Option::Some(USR_Messages::usr_SayText2),
            7 => ::std::option::Option::Some(USR_Messages::usr_TextMsg),
            8 => ::std::option::Option::Some(USR_Messages::usr_HudMsg),
            9 => ::std::option::Option::Some(USR_Messages::usr_ResetHud),
            10 => ::std::option::Option::Some(USR_Messages::usr_GameTitle),
            12 => ::std::option::Option::Some(USR_Messages::usr_Shake),
            13 => ::std::option::Option::Some(USR_Messages::usr_Fade),
            14 => ::std::option::Option::Some(USR_Messages::usr_Rumble),
            15 => ::std::option::Option::Some(USR_Messages::usr_CloseCaption),
            16 => ::std::option::Option::Some(USR_Messages::usr_CloseCaptionDirect),
            17 => ::std::option::Option::Some(USR_Messages::usr_SendAudio),
            18 => ::std::option::Option::Some(USR_Messages::usr_RawAudio),
            19 => ::std::option::Option::Some(USR_Messages::usr_VoiceMask),
            20 => ::std::option::Option::Some(USR_Messages::usr_RequestState),
            21 => ::std::option::Option::Some(USR_Messages::usr_Damage),
            22 => ::std::option::Option::Some(USR_Messages::usr_RadioText),
            23 => ::std::option::Option::Some(USR_Messages::usr_HintText),
            24 => ::std::option::Option::Some(USR_Messages::usr_KeyHintText),
            25 => ::std::option::Option::Some(USR_Messages::usr_ProcessSpottedEntityUpdate),
            26 => ::std::option::Option::Some(USR_Messages::usr_ReloadEffect),
            27 => ::std::option::Option::Some(USR_Messages::usr_AdjustMoney),
            28 => ::std::option::Option::Some(USR_Messages::usr_UpdateTeamMoney),
            29 => ::std::option::Option::Some(USR_Messages::usr_StopSpectatorMode),
            30 => ::std::option::Option::Some(USR_Messages::usr_KillCam),
            31 => ::std::option::Option::Some(USR_Messages::usr_DesiredTimescale),
            32 => ::std::option::Option::Some(USR_Messages::usr_CurrentTimescale),
            33 => ::std::option::Option::Some(USR_Messages::usr_AchievementEvent),
            34 => ::std::option::Option::Some(USR_Messages::usr_MatchEndConditions),
            35 => ::std::option::Option::Some(USR_Messages::usr_DisconnectToLobby),
            36 => ::std::option::Option::Some(USR_Messages::usr_PlayerStatsUpdate),
            37 => ::std::option::Option::Some(USR_Messages::usr_DisplayInventory),
            38 => ::std::option::Option::Some(USR_Messages::usr_WarmupHasEnded),
            39 => ::std::option::Option::Some(USR_Messages::usr_ClientInfo),
            40 => ::std::option::Option::Some(USR_Messages::usr_XRankGet),
            41 => ::std::option::Option::Some(USR_Messages::usr_XRankUpd),
            45 => ::std::option::Option::Some(USR_Messages::usr_CallVoteFailed),
            46 => ::std::option::Option::Some(USR_Messages::usr_VoteStart),
            47 => ::std::option::Option::Some(USR_Messages::usr_VotePass),
            48 => ::std::option::Option::Some(USR_Messages::usr_VoteFailed),
            49 => ::std::option::Option::Some(USR_Messages::usr_VoteSetup),
            50 => ::std::option::Option::Some(USR_Messages::usr_ServerRankRevealAll),
            51 => ::std::option::Option::Some(USR_Messages::usr_SendLastKillerDamageToClient),
            52 => ::std::option::Option::Some(USR_Messages::usr_ServerRankUpdate),
            53 => ::std::option::Option::Some(USR_Messages::usr_ItemPickup),
            54 => ::std::option::Option::Some(USR_Messages::usr_ShowMenu),
            55 => ::std::option::Option::Some(USR_Messages::usr_BarTime),
            56 => ::std::option::Option::Some(USR_Messages::usr_AmmoDenied),
            57 => ::std::option::Option::Some(USR_Messages::usr_MarkAchievement),
            58 => ::std::option::Option::Some(USR_Messages::usr_MatchStatsUpdate),
            59 => ::std::option::Option::Some(USR_Messages::usr_ItemDrop),
            60 => ::std::option::Option::Some(USR_Messages::usr_GlowPropTurnOff),
            61 => ::std::option::Option::Some(USR_Messages::usr_SendPlayerItemDrops),
            62 => ::std::option::Option::Some(USR_Messages::usr_RoundBackupFilenames),
            63 => ::std::option::Option::Some(USR_Messages::usr_SendPlayerItemFound),
            64 => ::std::option::Option::Some(USR_Messages::usr_ReportHit),
            65 => ::std::option::Option::Some(USR_Messages::usr_XpUpdate),
            66 => ::std::option::Option::Some(USR_Messages::usr_QuestProgress),
            67 => ::std::option::Option::Some(USR_Messages::usr_ScoreLeaderboardData),
            68 => ::std::option::Option::Some(USR_Messages::usr_PlayerDecalDigitalSignature),
            69 => ::std::option::Option::Some(USR_Messages::usr_WeaponSound),
            70 => ::std::option::Option::Some(USR_Messages::usr_UpdateScreenHealthBar),
            71 => ::std::option::Option::Some(USR_Messages::usr_EntityOutlineHighlight),
            72 => ::std::option::Option::Some(USR_Messages::usr_SSUI),
            73 => ::std::option::Option::Some(USR_Messages::usr_SurvivalStats),
            74 => ::std::option::Option::Some(USR_Messages::usr_DisconnectToLobby2),
            75 => ::std::option::Option::Some(USR_Messages::usr_EndOfMatchAllPlayersData),
            79 => ::std::option::Option::Some(USR_Messages::usr_RoundImpactScoreData),
            80 => ::std::option::Option::Some(USR_Messages::usr_CurrentRoundOdds),
            81 => ::std::option::Option::Some(USR_Messages::usr_DeepStats),
            82 => ::std::option::Option::Some(USR_Messages::usr_UtilMessage),
            83 => ::std::option::Option::Some(USR_Messages::usr_UtilMessageResponse),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [USR_Messages] = &[
        USR_Messages::usr_VGUIMenu,
        USR_Messages::usr_Geiger,
        USR_Messages::usr_Train,
        USR_Messages::usr_HudText,
        USR_Messages::usr_SayText,
        USR_Messages::usr_SayText2,
        USR_Messages::usr_TextMsg,
        USR_Messages::usr_HudMsg,
        USR_Messages::usr_ResetHud,
        USR_Messages::usr_GameTitle,
        USR_Messages::usr_Shake,
        USR_Messages::usr_Fade,
        USR_Messages::usr_Rumble,
        USR_Messages::usr_CloseCaption,
        USR_Messages::usr_CloseCaptionDirect,
        USR_Messages::usr_SendAudio,
        USR_Messages::usr_RawAudio,
        USR_Messages::usr_VoiceMask,
        USR_Messages::usr_RequestState,
        USR_Messages::usr_Damage,
        USR_Messages::usr_RadioText,
        USR_Messages::usr_HintText,
        USR_Messages::usr_KeyHintText,
        USR_Messages::usr_ProcessSpottedEntityUpdate,
        USR_Messages::usr_ReloadEffect,
        USR_Messages::usr_AdjustMoney,
        USR_Messages::usr_UpdateTeamMoney,
        USR_Messages::usr_StopSpectatorMode,
        USR_Messages::usr_KillCam,
        USR_Messages::usr_DesiredTimescale,
        USR_Messages::usr_CurrentTimescale,
        USR_Messages::usr_AchievementEvent,
        USR_Messages::usr_MatchEndConditions,
        USR_Messages::usr_DisconnectToLobby,
        USR_Messages::usr_PlayerStatsUpdate,
        USR_Messages::usr_DisplayInventory,
        USR_Messages::usr_WarmupHasEnded,
        USR_Messages::usr_ClientInfo,
        USR_Messages::usr_XRankGet,
        USR_Messages::usr_XRankUpd,
        USR_Messages::usr_CallVoteFailed,
        USR_Messages::usr_VoteStart,
        USR_Messages::usr_VotePass,
        USR_Messages::usr_VoteFailed,
        USR_Messages::usr_VoteSetup,
        USR_Messages::usr_ServerRankRevealAll,
        USR_Messages::usr_SendLastKillerDamageToClient,
        USR_Messages::usr_ServerRankUpdate,
        USR_Messages::usr_ItemPickup,
        USR_Messages::usr_ShowMenu,
        USR_Messages::usr_BarTime,
        USR_Messages::usr_AmmoDenied,
        USR_Messages::usr_MarkAchievement,
        USR_Messages::usr_MatchStatsUpdate,
        USR_Messages::usr_ItemDrop,
        USR_Messages::usr_GlowPropTurnOff,
        USR_Messages::usr_SendPlayerItemDrops,
        USR_Messages::usr_RoundBackupFilenames,
        USR_Messages::usr_SendPlayerItemFound,
        USR_Messages::usr_ReportHit,
        USR_Messages::usr_XpUpdate,
        USR_Messages::usr_QuestProgress,
        USR_Messages::usr_ScoreLeaderboardData,
        USR_Messages::usr_PlayerDecalDigitalSignature,
        USR_Messages::usr_WeaponSound,
        USR_Messages::usr_UpdateScreenHealthBar,
        USR_Messages::usr_EntityOutlineHighlight,
        USR_Messages::usr_SSUI,
        USR_Messages::usr_SurvivalStats,
        USR_Messages::usr_DisconnectToLobby2,
        USR_Messages::usr_EndOfMatchAllPlayersData,
        USR_Messages::usr_RoundImpactScoreData,
        USR_Messages::usr_CurrentRoundOdds,
        USR_Messages::usr_DeepStats,
        USR_Messages::usr_UtilMessage,
        USR_Messages::usr_UtilMessageResponse,
    ];
}

impl ::protobuf::EnumFull for USR_Messages {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("USR_Messages").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            USR_Messages::usr_VGUIMenu => 0,
            USR_Messages::usr_Geiger => 1,
            USR_Messages::usr_Train => 2,
            USR_Messages::usr_HudText => 3,
            USR_Messages::usr_SayText => 4,
            USR_Messages::usr_SayText2 => 5,
            USR_Messages::usr_TextMsg => 6,
            USR_Messages::usr_HudMsg => 7,
            USR_Messages::usr_ResetHud => 8,
            USR_Messages::usr_GameTitle => 9,
            USR_Messages::usr_Shake => 10,
            USR_Messages::usr_Fade => 11,
            USR_Messages::usr_Rumble => 12,
            USR_Messages::usr_CloseCaption => 13,
            USR_Messages::usr_CloseCaptionDirect => 14,
            USR_Messages::usr_SendAudio => 15,
            USR_Messages::usr_RawAudio => 16,
            USR_Messages::usr_VoiceMask => 17,
            USR_Messages::usr_RequestState => 18,
            USR_Messages::usr_Damage => 19,
            USR_Messages::usr_RadioText => 20,
            USR_Messages::usr_HintText => 21,
            USR_Messages::usr_KeyHintText => 22,
            USR_Messages::usr_ProcessSpottedEntityUpdate => 23,
            USR_Messages::usr_ReloadEffect => 24,
            USR_Messages::usr_AdjustMoney => 25,
            USR_Messages::usr_UpdateTeamMoney => 26,
            USR_Messages::usr_StopSpectatorMode => 27,
            USR_Messages::usr_KillCam => 28,
            USR_Messages::usr_DesiredTimescale => 29,
            USR_Messages::usr_CurrentTimescale => 30,
            USR_Messages::usr_AchievementEvent => 31,
            USR_Messages::usr_MatchEndConditions => 32,
            USR_Messages::usr_DisconnectToLobby => 33,
            USR_Messages::usr_PlayerStatsUpdate => 34,
            USR_Messages::usr_DisplayInventory => 35,
            USR_Messages::usr_WarmupHasEnded => 36,
            USR_Messages::usr_ClientInfo => 37,
            USR_Messages::usr_XRankGet => 38,
            USR_Messages::usr_XRankUpd => 39,
            USR_Messages::usr_CallVoteFailed => 40,
            USR_Messages::usr_VoteStart => 41,
            USR_Messages::usr_VotePass => 42,
            USR_Messages::usr_VoteFailed => 43,
            USR_Messages::usr_VoteSetup => 44,
            USR_Messages::usr_ServerRankRevealAll => 45,
            USR_Messages::usr_SendLastKillerDamageToClient => 46,
            USR_Messages::usr_ServerRankUpdate => 47,
            USR_Messages::usr_ItemPickup => 48,
            USR_Messages::usr_ShowMenu => 49,
            USR_Messages::usr_BarTime => 50,
            USR_Messages::usr_AmmoDenied => 51,
            USR_Messages::usr_MarkAchievement => 52,
            USR_Messages::usr_MatchStatsUpdate => 53,
            USR_Messages::usr_ItemDrop => 54,
            USR_Messages::usr_GlowPropTurnOff => 55,
            USR_Messages::usr_SendPlayerItemDrops => 56,
            USR_Messages::usr_RoundBackupFilenames => 57,
            USR_Messages::usr_SendPlayerItemFound => 58,
            USR_Messages::usr_ReportHit => 59,
            USR_Messages::usr_XpUpdate => 60,
            USR_Messages::usr_QuestProgress => 61,
            USR_Messages::usr_ScoreLeaderboardData => 62,
            USR_Messages::usr_PlayerDecalDigitalSignature => 63,
            USR_Messages::usr_WeaponSound => 64,
            USR_Messages::usr_UpdateScreenHealthBar => 65,
            USR_Messages::usr_EntityOutlineHighlight => 66,
            USR_Messages::usr_SSUI => 67,
            USR_Messages::usr_SurvivalStats => 68,
            USR_Messages::usr_DisconnectToLobby2 => 69,
            USR_Messages::usr_EndOfMatchAllPlayersData => 70,
            USR_Messages::usr_RoundImpactScoreData => 71,
            USR_Messages::usr_CurrentRoundOdds => 72,
            USR_Messages::usr_DeepStats => 73,
            USR_Messages::usr_UtilMessage => 74,
            USR_Messages::usr_UtilMessageResponse => 75,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for USR_Messages {
    fn default() -> Self {
        USR_Messages::usr_VGUIMenu
    }
}

impl USR_Messages {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<USR_Messages>("USR_Messages")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECSUsrMsg_DisconnectToLobby_Action)
pub enum ECSUsrMsg_DisconnectToLobby_Action {
    // @@protoc_insertion_point(enum_value:ECSUsrMsg_DisconnectToLobby_Action.k_ECSUsrMsg_DisconnectToLobby_Action_Default)
    k_ECSUsrMsg_DisconnectToLobby_Action_Default = 0,
    // @@protoc_insertion_point(enum_value:ECSUsrMsg_DisconnectToLobby_Action.k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue)
    k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue = 1,
}

impl ::protobuf::Enum for ECSUsrMsg_DisconnectToLobby_Action {
    const NAME: &'static str = "ECSUsrMsg_DisconnectToLobby_Action";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECSUsrMsg_DisconnectToLobby_Action> {
        match value {
            0 => ::std::option::Option::Some(ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_Default),
            1 => ::std::option::Option::Some(ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECSUsrMsg_DisconnectToLobby_Action] = &[
        ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_Default,
        ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue,
    ];
}

impl ::protobuf::EnumFull for ECSUsrMsg_DisconnectToLobby_Action {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECSUsrMsg_DisconnectToLobby_Action").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ECSUsrMsg_DisconnectToLobby_Action {
    fn default() -> Self {
        ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_Default
    }
}

impl ECSUsrMsg_DisconnectToLobby_Action {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ECSUsrMsg_DisconnectToLobby_Action>("ECSUsrMsg_DisconnectToLobby_Action")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1ccstrike15_usermessages.proto\x1a\x20google/protobuf/descriptor.pro\
    to\x1a\x11netmessages.proto\x1a\x1acstrike15_gcmessages.proto\"\x9e\x01\
    \n\x10CUSRMsg_VGUIMenu\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x12\n\x04show\x18\x02\x20\x01(\x08R\x04show\x122\n\x07subkeys\x18\x03\
    \x20\x03(\x0b2\x18.CUSRMsg_VGUIMenu.SubkeyR\x07subkeys\x1a.\n\x06Subkey\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x10\n\x03str\x18\x02\
    \x20\x01(\tR\x03str\"&\n\x0eCUSRMsg_Geiger\x12\x14\n\x05range\x18\x01\
    \x20\x01(\x05R\x05range\"%\n\rCUSRMsg_Train\x12\x14\n\x05train\x18\x01\
    \x20\x01(\x05R\x05train\"%\n\x0fCUSRMsg_HudText\x12\x12\n\x04text\x18\
    \x01\x20\x01(\tR\x04text\"t\n\x0fCUSRMsg_SayText\x12\x17\n\x07ent_idx\
    \x18\x01\x20\x01(\x05R\x06entIdx\x12\x12\n\x04text\x18\x02\x20\x01(\tR\
    \x04text\x12\x12\n\x04chat\x18\x03\x20\x01(\x08R\x04chat\x12\x20\n\x0bte\
    xtallchat\x18\x04\x20\x01(\x08R\x0btextallchat\"\x94\x01\n\x10CUSRMsg_Sa\
    yText2\x12\x17\n\x07ent_idx\x18\x01\x20\x01(\x05R\x06entIdx\x12\x12\n\
    \x04chat\x18\x02\x20\x01(\x08R\x04chat\x12\x19\n\x08msg_name\x18\x03\x20\
    \x01(\tR\x07msgName\x12\x16\n\x06params\x18\x04\x20\x03(\tR\x06params\
    \x12\x20\n\x0btextallchat\x18\x05\x20\x01(\x08R\x0btextallchat\"B\n\x0fC\
    USRMsg_TextMsg\x12\x17\n\x07msg_dst\x18\x01\x20\x01(\x05R\x06msgDst\x12\
    \x16\n\x06params\x18\x03\x20\x03(\tR\x06params\"\xb1\x02\n\x0eCUSRMsg_Hu\
    dMsg\x12\x18\n\x07channel\x18\x01\x20\x01(\x05R\x07channel\x12\x1f\n\x03\
    pos\x18\x02\x20\x01(\x0b2\r.CMsgVector2DR\x03pos\x12\x1d\n\x04clr1\x18\
    \x03\x20\x01(\x0b2\t.CMsgRGBAR\x04clr1\x12\x1d\n\x04clr2\x18\x04\x20\x01\
    (\x0b2\t.CMsgRGBAR\x04clr2\x12\x16\n\x06effect\x18\x05\x20\x01(\x05R\x06\
    effect\x12\x20\n\x0cfade_in_time\x18\x06\x20\x01(\x02R\nfadeInTime\x12\"\
    \n\rfade_out_time\x18\x07\x20\x01(\x02R\x0bfadeOutTime\x12\x1b\n\thold_t\
    ime\x18\t\x20\x01(\x02R\x08holdTime\x12\x17\n\x07fx_time\x18\n\x20\x01(\
    \x02R\x06fxTime\x12\x12\n\x04text\x18\x0b\x20\x01(\tR\x04text\"\x8c\x01\
    \n\rCUSRMsg_Shake\x12\x18\n\x07command\x18\x01\x20\x01(\x05R\x07command\
    \x12'\n\x0flocal_amplitude\x18\x02\x20\x01(\x02R\x0elocalAmplitude\x12\
    \x1c\n\tfrequency\x18\x03\x20\x01(\x02R\tfrequency\x12\x1a\n\x08duration\
    \x18\x04\x20\x01(\x02R\x08duration\"z\n\x0cCUSRMsg_Fade\x12\x1a\n\x08dur\
    ation\x18\x01\x20\x01(\x05R\x08duration\x12\x1b\n\thold_time\x18\x02\x20\
    \x01(\x05R\x08holdTime\x12\x14\n\x05flags\x18\x03\x20\x01(\x05R\x05flags\
    \x12\x1b\n\x03clr\x18\x04\x20\x01(\x0b2\t.CMsgRGBAR\x03clr\"P\n\x0eCUSRM\
    sg_Rumble\x12\x14\n\x05index\x18\x01\x20\x01(\x05R\x05index\x12\x12\n\
    \x04data\x18\x02\x20\x01(\x05R\x04data\x12\x14\n\x05flags\x18\x03\x20\
    \x01(\x05R\x05flags\"\x81\x01\n\x14CUSRMsg_CloseCaption\x12\x12\n\x04has\
    h\x18\x01\x20\x01(\rR\x04hash\x12\x1a\n\x08duration\x18\x02\x20\x01(\x05\
    R\x08duration\x12\x1f\n\x0bfrom_player\x18\x03\x20\x01(\x08R\nfromPlayer\
    \x12\x18\n\x07cctoken\x18\x04\x20\x01(\tR\x07cctoken\"m\n\x1aCUSRMsg_Clo\
    seCaptionDirect\x12\x12\n\x04hash\x18\x01\x20\x01(\rR\x04hash\x12\x1a\n\
    \x08duration\x18\x02\x20\x01(\x05R\x08duration\x12\x1f\n\x0bfrom_player\
    \x18\x03\x20\x01(\x08R\nfromPlayer\"4\n\x11CUSRMsg_SendAudio\x12\x1f\n\
    \x0bradio_sound\x18\x01\x20\x01(\tR\nradioSound\"\x83\x01\n\x10CUSRMsg_R\
    awAudio\x12\x14\n\x05pitch\x18\x01\x20\x01(\x05R\x05pitch\x12\x16\n\x06e\
    ntidx\x18\x02\x20\x01(\x05R\x06entidx\x12\x1a\n\x08duration\x18\x03\x20\
    \x01(\x02R\x08duration\x12%\n\x0evoice_filename\x18\x04\x20\x01(\tR\rvoi\
    ceFilename\"\xd4\x01\n\x11CUSRMsg_VoiceMask\x12@\n\x0cplayer_masks\x18\
    \x01\x20\x03(\x0b2\x1d.CUSRMsg_VoiceMask.PlayerMaskR\x0bplayerMasks\x12*\
    \n\x11player_mod_enable\x18\x02\x20\x01(\x08R\x0fplayerModEnable\x1aQ\n\
    \nPlayerMask\x12&\n\x0fgame_rules_mask\x18\x01\x20\x01(\x05R\rgameRulesM\
    ask\x12\x1b\n\tban_masks\x18\x02\x20\x01(\x05R\x08banMasks\"\x8e\x01\n\
    \x0eCUSRMsg_Damage\x12\x16\n\x06amount\x18\x01\x20\x01(\x05R\x06amount\
    \x12;\n\x13inflictor_world_pos\x18\x02\x20\x01(\x0b2\x0b.CMsgVectorR\x11\
    inflictorWorldPos\x12'\n\x0fvictim_entindex\x18\x03\x20\x01(\x05R\x0evic\
    timEntindex\"w\n\x11CUSRMsg_RadioText\x12\x17\n\x07msg_dst\x18\x01\x20\
    \x01(\x05R\x06msgDst\x12\x16\n\x06client\x18\x02\x20\x01(\x05R\x06client\
    \x12\x19\n\x08msg_name\x18\x03\x20\x01(\tR\x07msgName\x12\x16\n\x06param\
    s\x18\x04\x20\x03(\tR\x06params\"&\n\x10CUSRMsg_HintText\x12\x12\n\x04te\
    xt\x18\x01\x20\x01(\tR\x04text\"+\n\x13CUSRMsg_KeyHintText\x12\x14\n\x05\
    hints\x18\x01\x20\x03(\tR\x05hints\"\xc7\x03\n\"CUSRMsg_ProcessSpottedEn\
    tityUpdate\x12\x1d\n\nnew_update\x18\x01\x20\x01(\x08R\tnewUpdate\x12^\n\
    \x0eentity_updates\x18\x02\x20\x03(\x0b27.CUSRMsg_ProcessSpottedEntityUp\
    date.SpottedEntityUpdateR\rentityUpdates\x1a\xa1\x02\n\x13SpottedEntityU\
    pdate\x12\x1d\n\nentity_idx\x18\x01\x20\x01(\x05R\tentityIdx\x12\x19\n\
    \x08class_id\x18\x02\x20\x01(\x05R\x07classId\x12\x19\n\x08origin_x\x18\
    \x03\x20\x01(\x05R\x07originX\x12\x19\n\x08origin_y\x18\x04\x20\x01(\x05\
    R\x07originY\x12\x19\n\x08origin_z\x18\x05\x20\x01(\x05R\x07originZ\x12\
    \x17\n\x07angle_y\x18\x06\x20\x01(\x05R\x06angleY\x12\x16\n\x06defusr\
    \x18\x07\x20\x01(\x08R\x06defusr\x12*\n\x11player_has_defusr\x18\x08\x20\
    \x01(\x08R\x0fplayerHasDefusr\x12\"\n\rplayer_has_c4\x18\t\x20\x01(\x08R\
    \x0bplayerHasC4\"`\n\x1bCUSRMsg_SendPlayerItemDrops\x12A\n\x0eentity_upd\
    ates\x18\x01\x20\x03(\x0b2\x1a.CEconItemPreviewDataBlockR\rentityUpdates\
    \"q\n\x1bCUSRMsg_SendPlayerItemFound\x126\n\x08iteminfo\x18\x01\x20\x01(\
    \x0b2\x1a.CEconItemPreviewDataBlockR\x08iteminfo\x12\x1a\n\x08entindex\
    \x18\x02\x20\x01(\x05R\x08entindex\"\x99\x01\n\x14CUSRMsg_ReloadEffect\
    \x12\x16\n\x06entidx\x18\x01\x20\x01(\x05R\x06entidx\x12\x18\n\x07actani\
    m\x18\x02\x20\x01(\x05R\x07actanim\x12\x19\n\x08origin_x\x18\x03\x20\x01\
    (\x02R\x07originX\x12\x19\n\x08origin_y\x18\x04\x20\x01(\x02R\x07originY\
    \x12\x19\n\x08origin_z\x18\x05\x20\x01(\x02R\x07originZ\"\xb2\x01\n\x13C\
    USRMsg_WeaponSound\x12\x16\n\x06entidx\x18\x01\x20\x01(\x05R\x06entidx\
    \x12\x19\n\x08origin_x\x18\x02\x20\x01(\x02R\x07originX\x12\x19\n\x08ori\
    gin_y\x18\x03\x20\x01(\x02R\x07originY\x12\x19\n\x08origin_z\x18\x04\x20\
    \x01(\x02R\x07originZ\x12\x14\n\x05sound\x18\x05\x20\x01(\tR\x05sound\
    \x12\x1c\n\ttimestamp\x18\x06\x20\x01(\x02R\ttimestamp\"\x9f\x01\n\x1dCU\
    SRMsg_UpdateScreenHealthBar\x12\x16\n\x06entidx\x18\x01\x20\x01(\x05R\
    \x06entidx\x12'\n\x0fhealthratio_old\x18\x02\x20\x01(\x02R\x0ehealthrati\
    oOld\x12'\n\x0fhealthratio_new\x18\x03\x20\x01(\x02R\x0ehealthratioNew\
    \x12\x14\n\x05style\x18\x04\x20\x01(\x05R\x05style\"b\n\x1eCUSRMsg_Entit\
    yOutlineHighlight\x12\x16\n\x06entidx\x18\x01\x20\x01(\x05R\x06entidx\
    \x12(\n\x0fremovehighlight\x18\x02\x20\x01(\x08R\x0fremovehighlight\"-\n\
    \x13CUSRMsg_AdjustMoney\x12\x16\n\x06amount\x18\x01\x20\x01(\x05R\x06amo\
    unt\"p\n\x11CUSRMsg_ReportHit\x12\x13\n\x05pos_x\x18\x01\x20\x01(\x02R\
    \x04posX\x12\x13\n\x05pos_y\x18\x02\x20\x01(\x02R\x04posY\x12\x1c\n\ttim\
    estamp\x18\x04\x20\x01(\x02R\ttimestamp\x12\x13\n\x05pos_z\x18\x03\x20\
    \x01(\x02R\x04posZ\"t\n\x0fCUSRMsg_KillCam\x12\x19\n\x08obs_mode\x18\x01\
    \x20\x01(\x05R\x07obsMode\x12!\n\x0cfirst_target\x18\x02\x20\x01(\x05R\
    \x0bfirstTarget\x12#\n\rsecond_target\x18\x03\x20\x01(\x05R\x0csecondTar\
    get\"\xd2\x01\n\x18CUSRMsg_DesiredTimescale\x12+\n\x11desired_timescale\
    \x18\x01\x20\x01(\x02R\x10desiredTimescale\x122\n\x15duration_realtime_s\
    ec\x18\x02\x20\x01(\x02R\x13durationRealtimeSec\x12+\n\x11interpolator_t\
    ype\x18\x03\x20\x01(\x05R\x10interpolatorType\x12(\n\x10start_blend_time\
    \x18\x04\x20\x01(\x02R\x0estartBlendTime\"?\n\x18CUSRMsg_CurrentTimescal\
    e\x12#\n\rcur_timescale\x18\x01\x20\x01(\x02R\x0ccurTimescale\"i\n\x18CU\
    SRMsg_AchievementEvent\x12\x20\n\x0bachievement\x18\x01\x20\x01(\x05R\
    \x0bachievement\x12\x14\n\x05count\x18\x02\x20\x01(\x05R\x05count\x12\
    \x15\n\x06usr_id\x18\x03\x20\x01(\x05R\x05usrId\"\xa1\x01\n\x1aCUSRMsg_M\
    atchEndConditions\x12\x1c\n\tfraglimit\x18\x01\x20\x01(\x05R\tfraglimit\
    \x12!\n\x0cmp_maxrounds\x18\x02\x20\x01(\x05R\x0bmpMaxrounds\x12\x1f\n\
    \x0bmp_winlimit\x18\x03\x20\x01(\x05R\nmpWinlimit\x12!\n\x0cmp_timelimit\
    \x18\x04\x20\x01(\x05R\x0bmpTimelimit\"\xc5\x01\n\x19CUSRMsg_PlayerStats\
    Update\x12\x18\n\x07version\x18\x01\x20\x01(\x05R\x07version\x125\n\x05s\
    tats\x18\x04\x20\x03(\x0b2\x1f.CUSRMsg_PlayerStatsUpdate.StatR\x05stats\
    \x12\x15\n\x06usr_id\x18\x05\x20\x01(\x05R\x05usrId\x12\x10\n\x03crc\x18\
    \x06\x20\x01(\x05R\x03crc\x1a.\n\x04Stat\x12\x10\n\x03idx\x18\x01\x20\
    \x01(\x05R\x03idx\x12\x14\n\x05delta\x18\x02\x20\x01(\x05R\x05delta\"K\n\
    \x18CUSRMsg_DisplayInventory\x12\x18\n\x07display\x18\x01\x20\x01(\x08R\
    \x07display\x12\x15\n\x06usr_id\x18\x02\x20\x01(\x05R\x05usrId\"\xa0\x01\
    \n\x15CUSRMsg_QuestProgress\x12\x19\n\x08quest_id\x18\x01\x20\x01(\rR\
    \x07questId\x12#\n\rnormal_points\x18\x02\x20\x01(\rR\x0cnormalPoints\
    \x12!\n\x0cbonus_points\x18\x03\x20\x01(\rR\x0bbonusPoints\x12$\n\x0eis_\
    event_quest\x18\x04\x20\x01(\x08R\x0cisEventQuest\"I\n\x1cCUSRMsg_ScoreL\
    eaderboardData\x12)\n\x04data\x18\x01\x20\x01(\x0b2\x15.ScoreLeaderboard\
    DataR\x04data\"W\n#CUSRMsg_PlayerDecalDigitalSignature\x120\n\x04data\
    \x18\x01\x20\x01(\x0b2\x1c.PlayerDecalDigitalSignatureR\x04data\"M\n\x10\
    CUSRMsg_XRankGet\x12\x19\n\x08mode_idx\x18\x01\x20\x01(\x05R\x07modeIdx\
    \x12\x1e\n\ncontroller\x18\x02\x20\x01(\x05R\ncontroller\"g\n\x10CUSRMsg\
    _XRankUpd\x12\x19\n\x08mode_idx\x18\x01\x20\x01(\x05R\x07modeIdx\x12\x1e\
    \n\ncontroller\x18\x02\x20\x01(\x05R\ncontroller\x12\x18\n\x07ranking\
    \x18\x03\x20\x01(\x05R\x07ranking\"D\n\x16CUSRMsg_CallVoteFailed\x12\x16\
    \n\x06reason\x18\x01\x20\x01(\x05R\x06reason\x12\x12\n\x04time\x18\x02\
    \x20\x01(\x05R\x04time\"\x89\x02\n\x11CUSRMsg_VoteStart\x12\x12\n\x04tea\
    m\x18\x01\x20\x01(\x05R\x04team\x12\x17\n\x07ent_idx\x18\x02\x20\x01(\
    \x05R\x06entIdx\x12\x1b\n\tvote_type\x18\x03\x20\x01(\x05R\x08voteType\
    \x12\x19\n\x08disp_str\x18\x04\x20\x01(\tR\x07dispStr\x12\x1f\n\x0bdetai\
    ls_str\x18\x05\x20\x01(\tR\ndetailsStr\x12$\n\x0eother_team_str\x18\x06\
    \x20\x01(\tR\x0cotherTeamStr\x12#\n\x0eis_yes_no_vote\x18\x07\x20\x01(\
    \x08R\x0bisYesNoVote\x12#\n\rentidx_target\x18\x08\x20\x01(\x05R\x0centi\
    dxTarget\"\x7f\n\x10CUSRMsg_VotePass\x12\x12\n\x04team\x18\x01\x20\x01(\
    \x05R\x04team\x12\x1b\n\tvote_type\x18\x02\x20\x01(\x05R\x08voteType\x12\
    \x19\n\x08disp_str\x18\x03\x20\x01(\tR\x07dispStr\x12\x1f\n\x0bdetails_s\
    tr\x18\x04\x20\x01(\tR\ndetailsStr\"@\n\x12CUSRMsg_VoteFailed\x12\x12\n\
    \x04team\x18\x01\x20\x01(\x05R\x04team\x12\x16\n\x06reason\x18\x02\x20\
    \x01(\x05R\x06reason\">\n\x11CUSRMsg_VoteSetup\x12)\n\x10potential_issue\
    s\x18\x01\x20\x03(\tR\x0fpotentialIssues\"\xb8\x01\n$CUSRMsg_SendLastKil\
    lerDamageToClient\x12$\n\x0enum_hits_given\x18\x01\x20\x01(\x05R\x0cnumH\
    itsGiven\x12!\n\x0cdamage_given\x18\x02\x20\x01(\x05R\x0bdamageGiven\x12\
    $\n\x0enum_hits_taken\x18\x03\x20\x01(\x05R\x0cnumHitsTaken\x12!\n\x0cda\
    mage_taken\x18\x04\x20\x01(\x05R\x0bdamageTaken\"\xa3\x02\n\x18CUSRMsg_S\
    erverRankUpdate\x12E\n\x0brank_update\x18\x01\x20\x03(\x0b2$.CUSRMsg_Ser\
    verRankUpdate.RankUpdateR\nrankUpdate\x1a\xbf\x01\n\nRankUpdate\x12\x1d\
    \n\naccount_id\x18\x01\x20\x01(\x05R\taccountId\x12\x19\n\x08rank_old\
    \x18\x02\x20\x01(\x05R\x07rankOld\x12\x19\n\x08rank_new\x18\x03\x20\x01(\
    \x05R\x07rankNew\x12\x19\n\x08num_wins\x18\x04\x20\x01(\x05R\x07numWins\
    \x12\x1f\n\x0brank_change\x18\x05\x20\x01(\x02R\nrankChange\x12\x20\n\
    \x0crank_type_id\x18\x06\x20\x01(\x05R\nrankTypeId\"U\n\x10CUSRMsg_XpUpd\
    ate\x12A\n\x04data\x18\x01\x20\x01(\x0b2-.CMsgGCCstrike15_v2_GC2ServerNo\
    tifyXPRewardedR\x04data\"(\n\x12CUSRMsg_ItemPickup\x12\x12\n\x04item\x18\
    \x01\x20\x01(\tR\x04item\"\x80\x01\n\x10CUSRMsg_ShowMenu\x12(\n\x10bits_\
    valid_slots\x18\x01\x20\x01(\x05R\x0ebitsValidSlots\x12!\n\x0cdisplay_ti\
    me\x18\x02\x20\x01(\x05R\x0bdisplayTime\x12\x1f\n\x0bmenu_string\x18\x03\
    \x20\x01(\tR\nmenuString\"%\n\x0fCUSRMsg_BarTime\x12\x12\n\x04time\x18\
    \x01\x20\x01(\tR\x04time\".\n\x12CUSRMsg_AmmoDenied\x12\x18\n\x07ammoIdx\
    \x18\x01\x20\x01(\x05R\x07ammoIdx\";\n\x17CUSRMsg_MarkAchievement\x12\
    \x20\n\x0bachievement\x18\x01\x20\x01(\tR\x0bachievement\"2\n\x18CUSRMsg\
    _MatchStatsUpdate\x12\x16\n\x06update\x18\x01\x20\x01(\tR\x06update\"@\n\
    \x10CUSRMsg_ItemDrop\x12\x16\n\x06itemid\x18\x01\x20\x01(\x03R\x06itemid\
    \x12\x14\n\x05death\x18\x02\x20\x01(\x08R\x05death\"1\n\x17CUSRMsg_GlowP\
    ropTurnOff\x12\x16\n\x06entidx\x18\x01\x20\x01(\x05R\x06entidx\"\x82\x01\
    \n\x1cCUSRMsg_RoundBackupFilenames\x12\x14\n\x05count\x18\x01\x20\x01(\
    \x05R\x05count\x12\x14\n\x05index\x18\x02\x20\x01(\x05R\x05index\x12\x1a\
    \n\x08filename\x18\x03\x20\x01(\tR\x08filename\x12\x1a\n\x08nicename\x18\
    \x04\x20\x01(\tR\x08nicename\"\\\n\x0cCUSRMsg_SSUI\x12\x12\n\x04show\x18\
    \x01\x20\x01(\x08R\x04show\x12\x1d\n\nstart_time\x18\x02\x20\x01(\x02R\t\
    startTime\x12\x19\n\x08end_time\x18\x03\x20\x01(\x02R\x07endTime\"\xba\
    \x04\n\x15CUSRMsg_SurvivalStats\x12\x12\n\x04xuid\x18\x01\x20\x01(\x04R\
    \x04xuid\x121\n\x05facts\x18\x02\x20\x03(\x0b2\x1b.CUSRMsg_SurvivalStats\
    .FactR\x05facts\x124\n\x04usrs\x18\x03\x20\x03(\x0b2\x20.CUSRMsg_Surviva\
    lStats.PlacementR\x04usrs\x127\n\x07damages\x18\x05\x20\x03(\x0b2\x1d.CU\
    SRMsg_SurvivalStats.DamageR\x07damages\x12\x1e\n\nticknumber\x18\x04\x20\
    \x01(\x05R\nticknumber\x1at\n\x04Fact\x12\x12\n\x04type\x18\x01\x20\x01(\
    \x05R\x04type\x12\x18\n\x07display\x18\x02\x20\x01(\x05R\x07display\x12\
    \x14\n\x05value\x18\x03\x20\x01(\x05R\x05value\x12(\n\x0finterestingness\
    \x18\x04\x20\x01(\x02R\x0finterestingness\x1a]\n\tPlacement\x12\x12\n\
    \x04xuid\x18\x01\x20\x01(\x04R\x04xuid\x12\x1e\n\nteamnumber\x18\x02\x20\
    \x01(\x05R\nteamnumber\x12\x1c\n\tplacement\x18\x03\x20\x01(\x05R\tplace\
    ment\x1av\n\x06Damage\x12\x12\n\x04xuid\x18\x01\x20\x01(\x04R\x04xuid\
    \x12\x0e\n\x02to\x18\x02\x20\x01(\x05R\x02to\x12\x17\n\x07to_hits\x18\
    \x03\x20\x01(\x05R\x06toHits\x12\x12\n\x04from\x18\x04\x20\x01(\x05R\x04\
    from\x12\x1b\n\tfrom_hits\x18\x05\x20\x01(\x05R\x08fromHits\"\x91\x04\n\
    \x20CUSRMsg_EndOfMatchAllPlayersData\x12R\n\rallplayerdata\x18\x01\x20\
    \x03(\x0b2,.CUSRMsg_EndOfMatchAllPlayersData.PlayerDataR\rallplayerdata\
    \x12\x14\n\x05scene\x18\x02\x20\x01(\x05R\x05scene\x1aZ\n\x08Accolade\
    \x12\x1c\n\teaccolade\x18\x01\x20\x01(\x05R\teaccolade\x12\x14\n\x05valu\
    e\x18\x02\x20\x01(\x02R\x05value\x12\x1a\n\x08position\x18\x03\x20\x01(\
    \x05R\x08position\x1a\xa6\x02\n\nPlayerData\x12\x1a\n\x08entindex\x18\
    \x01\x20\x01(\x05R\x08entindex\x12\x12\n\x04xuid\x18\x02\x20\x01(\x04R\
    \x04xuid\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1e\n\nteamnu\
    mber\x18\x04\x20\x01(\x05R\nteamnumber\x12J\n\nnomination\x18\x05\x20\
    \x01(\x0b2*.CUSRMsg_EndOfMatchAllPlayersData.AccoladeR\nnomination\x120\
    \n\x05items\x18\x06\x20\x03(\x0b2\x1a.CEconItemPreviewDataBlockR\x05item\
    s\x12\x20\n\x0bplayercolor\x18\x07\x20\x01(\x05R\x0bplayercolor\x12\x14\
    \n\x05isbot\x18\x08\x20\x01(\x08R\x05isbot\"\x90\t\n\x1cCUSRMsg_RoundImp\
    actScoreData\x12X\n\x0finit_conditions\x18\x01\x20\x01(\x0b2/.CUSRMsg_Ro\
    undImpactScoreData.InitialConditionsR\x0einitConditions\x12S\n\x12all_ri\
    s_event_data\x18\x02\x20\x03(\x0b2&.CUSRMsg_RoundImpactScoreData.RisEven\
    tR\x0fallRisEventData\x1a\xb9\x06\n\x08RisEvent\x12\x1c\n\ttimestamp\x18\
    \x01\x20\x01(\x02R\ttimestamp\x12%\n\x0eterrorist_odds\x18\x02\x20\x01(\
    \x05R\rterroristOdds\x12\x19\n\x08ct_alive\x18\x03\x20\x01(\x05R\x07ctAl\
    ive\x12\x17\n\x07t_alive\x18\x04\x20\x01(\x05R\x06tAlive\x12N\n\x0bvicti\
    m_data\x18\x05\x20\x01(\x0b2-.CUSRMsg_RoundImpactScoreData.RisEvent.Vict\
    imR\nvictimData\x12W\n\x0eobjective_data\x18\x06\x20\x01(\x0b20.CUSRMsg_\
    RoundImpactScoreData.RisEvent.ObjectiveR\robjectiveData\x12U\n\x0fall_da\
    mage_data\x18\x07\x20\x03(\x0b2-.CUSRMsg_RoundImpactScoreData.RisEvent.D\
    amageR\rallDamageData\x1a\x9f\x01\n\x06Victim\x12\x1f\n\x0bteam_number\
    \x18\x01\x20\x01(\x05R\nteamNumber\x12\x1a\n\x08entindex\x18\x02\x20\x01\
    (\x05R\x08entindex\x12\x12\n\x04xuid\x18\x03\x20\x01(\x04R\x04xuid\x12\
    \x14\n\x05color\x18\x04\x20\x01(\x05R\x05color\x12\x15\n\x06is_bot\x18\
    \x05\x20\x01(\x08R\x05isBot\x12\x17\n\x07is_dead\x18\x06\x20\x01(\x08R\
    \x06isDead\x1a\x1f\n\tObjective\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\
    \x04type\x1a\xf0\x01\n\x06Damage\x12'\n\x0ftarget_entindex\x18\x01\x20\
    \x01(\x05R\x0etargetEntindex\x12\x1f\n\x0btarget_xuid\x18\x02\x20\x01(\
    \x04R\ntargetXuid\x12%\n\x0ehealth_removed\x18\x03\x20\x01(\x05R\rhealth\
    Removed\x12\x19\n\x08num_hits\x18\x04\x20\x01(\x05R\x07numHits\x122\n\
    \x15return_health_removed\x18\x05\x20\x01(\x05R\x13returnHealthRemoved\
    \x12&\n\x0fnum_return_hits\x18\x06\x20\x01(\x05R\rnumReturnHits\x1a\x84\
    \x01\n\x11InitialConditions\x12$\n\x0ect_equip_value\x18\x01\x20\x01(\
    \x05R\x0cctEquipValue\x12\"\n\rt_equip_value\x18\x02\x20\x01(\x05R\x0btE\
    quipValue\x12%\n\x0eterrorist_odds\x18\x03\x20\x01(\x05R\rterroristOdds\
    \".\n\x18CUSRMsg_CurrentRoundOdds\x12\x12\n\x04odds\x18\x01\x20\x01(\x05\
    R\x04odds\"K\n\x11CUSRMsg_DeepStats\x126\n\x05stats\x18\x01\x20\x01(\x0b\
    2\x20.CMsgGCCStrike15_ClientDeepStatsR\x05stats\"(\n\x10CUSRMsg_ResetHud\
    \x12\x14\n\x05reset\x18\x01\x20\x01(\x08R\x05reset\")\n\x11CUSRMsg_GameT\
    itle\x12\x14\n\x05dummy\x18\x01\x20\x01(\x05R\x05dummy\",\n\x14CUSRMsg_R\
    equestState\x12\x14\n\x05dummy\x18\x01\x20\x01(\x05R\x05dummy\"1\n\x19CU\
    SRMsg_StopSpectatorMode\x12\x14\n\x05dummy\x18\x01\x20\x01(\x05R\x05dumm\
    y\"1\n\x19CUSRMsg_DisconnectToLobby\x12\x14\n\x05dummy\x18\x01\x20\x01(\
    \x05R\x05dummy\".\n\x16CUSRMsg_WarmupHasEnded\x12\x14\n\x05dummy\x18\x01\
    \x20\x01(\x05R\x05dummy\"*\n\x12CUSRMsg_ClientInfo\x12\x14\n\x05dummy\
    \x18\x01\x20\x01(\x05R\x05dummy\"\xa4\x01\n\x1bCUSRMsg_ServerRankRevealA\
    ll\x122\n\x15seconds_till_shutdown\x18\x01\x20\x01(\x05R\x13secondsTillS\
    hutdown\x12Q\n\x0breservation\x18\x02\x20\x01(\x0b2/.CMsgGCCStrike15_v2_\
    MatchmakingGC2ServerReserveR\x0breservation\"\xa4\x01\n\x13CUSRMsg_UtilM\
    essage\x12\x1f\n\x0butil_action\x18\x01\x20\x01(\tR\nutilAction\x12\x14\
    \n\x05util1\x18\x02\x20\x01(\x05R\x05util1\x12\x14\n\x05util2\x18\x03\
    \x20\x01(\x05R\x05util2\x12\x14\n\x05util3\x18\x04\x20\x01(\x05R\x05util\
    3\x12\x14\n\x05util4\x18\x05\x20\x01(\x05R\x05util4\x12\x14\n\x05util5\
    \x18\x06\x20\x01(\x05R\x05util5\"\xc9\x03\n\x1bCUSRMsg_UtilMessageRespon\
    se\x12\x10\n\x03crc\x18\x01\x20\x01(\x07R\x03crc\x12\x1d\n\nitem_count\
    \x18\x02\x20\x01(\x05R\titemCount\x12\x12\n\x04crc2\x18\x03\x20\x01(\x07\
    R\x04crc2\x12\x1f\n\x0bitem_count2\x18\x04\x20\x01(\x05R\nitemCount2\x12\
    \x19\n\x08crc_part\x18\x05\x20\x03(\x05R\x07crcPart\x12\x1b\n\tcrc_part2\
    \x18\x06\x20\x03(\x05R\x08crcPart2\x12)\n\x10client_timestamp\x18\x07\
    \x20\x01(\x05R\x0fclientTimestamp\x12\x1a\n\x08platform\x18\x08\x20\x01(\
    \x05R\x08platform\x12I\n\x0bitemdetails\x18\t\x20\x03(\x0b2'.CUSRMsg_Uti\
    lMessageResponse.ItemDetailR\x0bitemdetails\x12\x1c\n\titemgroup\x18\n\
    \x20\x01(\x05R\titemgroup\x1a\\\n\nItemDetail\x12\x14\n\x05index\x18\x01\
    \x20\x01(\x05R\x05index\x12\x12\n\x04hash\x18\x02\x20\x01(\x05R\x04hash\
    \x12\x10\n\x03crc\x18\x03\x20\x01(\x05R\x03crc\x12\x12\n\x04name\x18\x04\
    \x20\x01(\tR\x04name*\xc3\r\n\x0cUSR_Messages\x12\x10\n\x0cusr_VGUIMenu\
    \x10\x01\x12\x0e\n\nusr_Geiger\x10\x02\x12\r\n\tusr_Train\x10\x03\x12\
    \x0f\n\x0busr_HudText\x10\x04\x12\x0f\n\x0busr_SayText\x10\x05\x12\x10\n\
    \x0cusr_SayText2\x10\x06\x12\x0f\n\x0busr_TextMsg\x10\x07\x12\x0e\n\nusr\
    _HudMsg\x10\x08\x12\x10\n\x0cusr_ResetHud\x10\t\x12\x11\n\rusr_GameTitle\
    \x10\n\x12\r\n\tusr_Shake\x10\x0c\x12\x0c\n\x08usr_Fade\x10\r\x12\x0e\n\
    \nusr_Rumble\x10\x0e\x12\x14\n\x10usr_CloseCaption\x10\x0f\x12\x1a\n\x16\
    usr_CloseCaptionDirect\x10\x10\x12\x11\n\rusr_SendAudio\x10\x11\x12\x10\
    \n\x0cusr_RawAudio\x10\x12\x12\x11\n\rusr_VoiceMask\x10\x13\x12\x14\n\
    \x10usr_RequestState\x10\x14\x12\x0e\n\nusr_Damage\x10\x15\x12\x11\n\rus\
    r_RadioText\x10\x16\x12\x10\n\x0cusr_HintText\x10\x17\x12\x13\n\x0fusr_K\
    eyHintText\x10\x18\x12\"\n\x1eusr_ProcessSpottedEntityUpdate\x10\x19\x12\
    \x14\n\x10usr_ReloadEffect\x10\x1a\x12\x13\n\x0fusr_AdjustMoney\x10\x1b\
    \x12\x17\n\x13usr_UpdateTeamMoney\x10\x1c\x12\x19\n\x15usr_StopSpectator\
    Mode\x10\x1d\x12\x0f\n\x0busr_KillCam\x10\x1e\x12\x18\n\x14usr_DesiredTi\
    mescale\x10\x1f\x12\x18\n\x14usr_CurrentTimescale\x10\x20\x12\x18\n\x14u\
    sr_AchievementEvent\x10!\x12\x1a\n\x16usr_MatchEndConditions\x10\"\x12\
    \x19\n\x15usr_DisconnectToLobby\x10#\x12\x19\n\x15usr_PlayerStatsUpdate\
    \x10$\x12\x18\n\x14usr_DisplayInventory\x10%\x12\x16\n\x12usr_WarmupHasE\
    nded\x10&\x12\x12\n\x0eusr_ClientInfo\x10'\x12\x10\n\x0cusr_XRankGet\x10\
    (\x12\x10\n\x0cusr_XRankUpd\x10)\x12\x16\n\x12usr_CallVoteFailed\x10-\
    \x12\x11\n\rusr_VoteStart\x10.\x12\x10\n\x0cusr_VotePass\x10/\x12\x12\n\
    \x0eusr_VoteFailed\x100\x12\x11\n\rusr_VoteSetup\x101\x12\x1b\n\x17usr_S\
    erverRankRevealAll\x102\x12$\n\x20usr_SendLastKillerDamageToClient\x103\
    \x12\x18\n\x14usr_ServerRankUpdate\x104\x12\x12\n\x0eusr_ItemPickup\x105\
    \x12\x10\n\x0cusr_ShowMenu\x106\x12\x0f\n\x0busr_BarTime\x107\x12\x12\n\
    \x0eusr_AmmoDenied\x108\x12\x17\n\x13usr_MarkAchievement\x109\x12\x18\n\
    \x14usr_MatchStatsUpdate\x10:\x12\x10\n\x0cusr_ItemDrop\x10;\x12\x17\n\
    \x13usr_GlowPropTurnOff\x10<\x12\x1b\n\x17usr_SendPlayerItemDrops\x10=\
    \x12\x1c\n\x18usr_RoundBackupFilenames\x10>\x12\x1b\n\x17usr_SendPlayerI\
    temFound\x10?\x12\x11\n\rusr_ReportHit\x10@\x12\x10\n\x0cusr_XpUpdate\
    \x10A\x12\x15\n\x11usr_QuestProgress\x10B\x12\x1c\n\x18usr_ScoreLeaderbo\
    ardData\x10C\x12#\n\x1fusr_PlayerDecalDigitalSignature\x10D\x12\x13\n\
    \x0fusr_WeaponSound\x10E\x12\x1d\n\x19usr_UpdateScreenHealthBar\x10F\x12\
    \x1e\n\x1ausr_EntityOutlineHighlight\x10G\x12\x0c\n\x08usr_SSUI\x10H\x12\
    \x15\n\x11usr_SurvivalStats\x10I\x12\x1a\n\x16usr_DisconnectToLobby2\x10\
    J\x12\x20\n\x1cusr_EndOfMatchAllPlayersData\x10K\x12\x1c\n\x18usr_RoundI\
    mpactScoreData\x10O\x12\x18\n\x14usr_CurrentRoundOdds\x10P\x12\x11\n\rus\
    r_DeepStats\x10Q\x12\x13\n\x0fusr_UtilMessage\x10R\x12\x1b\n\x17usr_Util\
    MessageResponse\x10S*\x88\x01\n\"ECSUsrMsg_DisconnectToLobby_Action\x120\
    \n,k_ECSUsrMsg_DisconnectToLobby_Action_Default\x10\0\x120\n,k_ECSUsrMsg\
    _DisconnectToLobby_Action_GoQueue\x10\x01B\x05H\x01\x80\x01\0\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(3);
            deps.push(::protobuf::descriptor::file_descriptor().clone());
            deps.push(super::netmessages::file_descriptor().clone());
            deps.push(super::cstrike15_gcmessages::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(90);
            messages.push(CUSRMsg_VGUIMenu::generated_message_descriptor_data());
            messages.push(CUSRMsg_Geiger::generated_message_descriptor_data());
            messages.push(CUSRMsg_Train::generated_message_descriptor_data());
            messages.push(CUSRMsg_HudText::generated_message_descriptor_data());
            messages.push(CUSRMsg_SayText::generated_message_descriptor_data());
            messages.push(CUSRMsg_SayText2::generated_message_descriptor_data());
            messages.push(CUSRMsg_TextMsg::generated_message_descriptor_data());
            messages.push(CUSRMsg_HudMsg::generated_message_descriptor_data());
            messages.push(CUSRMsg_Shake::generated_message_descriptor_data());
            messages.push(CUSRMsg_Fade::generated_message_descriptor_data());
            messages.push(CUSRMsg_Rumble::generated_message_descriptor_data());
            messages.push(CUSRMsg_CloseCaption::generated_message_descriptor_data());
            messages.push(CUSRMsg_CloseCaptionDirect::generated_message_descriptor_data());
            messages.push(CUSRMsg_SendAudio::generated_message_descriptor_data());
            messages.push(CUSRMsg_RawAudio::generated_message_descriptor_data());
            messages.push(CUSRMsg_VoiceMask::generated_message_descriptor_data());
            messages.push(CUSRMsg_Damage::generated_message_descriptor_data());
            messages.push(CUSRMsg_RadioText::generated_message_descriptor_data());
            messages.push(CUSRMsg_HintText::generated_message_descriptor_data());
            messages.push(CUSRMsg_KeyHintText::generated_message_descriptor_data());
            messages.push(CUSRMsg_ProcessSpottedEntityUpdate::generated_message_descriptor_data());
            messages.push(CUSRMsg_SendPlayerItemDrops::generated_message_descriptor_data());
            messages.push(CUSRMsg_SendPlayerItemFound::generated_message_descriptor_data());
            messages.push(CUSRMsg_ReloadEffect::generated_message_descriptor_data());
            messages.push(CUSRMsg_WeaponSound::generated_message_descriptor_data());
            messages.push(CUSRMsg_UpdateScreenHealthBar::generated_message_descriptor_data());
            messages.push(CUSRMsg_EntityOutlineHighlight::generated_message_descriptor_data());
            messages.push(CUSRMsg_AdjustMoney::generated_message_descriptor_data());
            messages.push(CUSRMsg_ReportHit::generated_message_descriptor_data());
            messages.push(CUSRMsg_KillCam::generated_message_descriptor_data());
            messages.push(CUSRMsg_DesiredTimescale::generated_message_descriptor_data());
            messages.push(CUSRMsg_CurrentTimescale::generated_message_descriptor_data());
            messages.push(CUSRMsg_AchievementEvent::generated_message_descriptor_data());
            messages.push(CUSRMsg_MatchEndConditions::generated_message_descriptor_data());
            messages.push(CUSRMsg_PlayerStatsUpdate::generated_message_descriptor_data());
            messages.push(CUSRMsg_DisplayInventory::generated_message_descriptor_data());
            messages.push(CUSRMsg_QuestProgress::generated_message_descriptor_data());
            messages.push(CUSRMsg_ScoreLeaderboardData::generated_message_descriptor_data());
            messages.push(CUSRMsg_PlayerDecalDigitalSignature::generated_message_descriptor_data());
            messages.push(CUSRMsg_XRankGet::generated_message_descriptor_data());
            messages.push(CUSRMsg_XRankUpd::generated_message_descriptor_data());
            messages.push(CUSRMsg_CallVoteFailed::generated_message_descriptor_data());
            messages.push(CUSRMsg_VoteStart::generated_message_descriptor_data());
            messages.push(CUSRMsg_VotePass::generated_message_descriptor_data());
            messages.push(CUSRMsg_VoteFailed::generated_message_descriptor_data());
            messages.push(CUSRMsg_VoteSetup::generated_message_descriptor_data());
            messages.push(CUSRMsg_SendLastKillerDamageToClient::generated_message_descriptor_data());
            messages.push(CUSRMsg_ServerRankUpdate::generated_message_descriptor_data());
            messages.push(CUSRMsg_XpUpdate::generated_message_descriptor_data());
            messages.push(CUSRMsg_ItemPickup::generated_message_descriptor_data());
            messages.push(CUSRMsg_ShowMenu::generated_message_descriptor_data());
            messages.push(CUSRMsg_BarTime::generated_message_descriptor_data());
            messages.push(CUSRMsg_AmmoDenied::generated_message_descriptor_data());
            messages.push(CUSRMsg_MarkAchievement::generated_message_descriptor_data());
            messages.push(CUSRMsg_MatchStatsUpdate::generated_message_descriptor_data());
            messages.push(CUSRMsg_ItemDrop::generated_message_descriptor_data());
            messages.push(CUSRMsg_GlowPropTurnOff::generated_message_descriptor_data());
            messages.push(CUSRMsg_RoundBackupFilenames::generated_message_descriptor_data());
            messages.push(CUSRMsg_SSUI::generated_message_descriptor_data());
            messages.push(CUSRMsg_SurvivalStats::generated_message_descriptor_data());
            messages.push(CUSRMsg_EndOfMatchAllPlayersData::generated_message_descriptor_data());
            messages.push(CUSRMsg_RoundImpactScoreData::generated_message_descriptor_data());
            messages.push(CUSRMsg_CurrentRoundOdds::generated_message_descriptor_data());
            messages.push(CUSRMsg_DeepStats::generated_message_descriptor_data());
            messages.push(CUSRMsg_ResetHud::generated_message_descriptor_data());
            messages.push(CUSRMsg_GameTitle::generated_message_descriptor_data());
            messages.push(CUSRMsg_RequestState::generated_message_descriptor_data());
            messages.push(CUSRMsg_StopSpectatorMode::generated_message_descriptor_data());
            messages.push(CUSRMsg_DisconnectToLobby::generated_message_descriptor_data());
            messages.push(CUSRMsg_WarmupHasEnded::generated_message_descriptor_data());
            messages.push(CUSRMsg_ClientInfo::generated_message_descriptor_data());
            messages.push(CUSRMsg_ServerRankRevealAll::generated_message_descriptor_data());
            messages.push(CUSRMsg_UtilMessage::generated_message_descriptor_data());
            messages.push(CUSRMsg_UtilMessageResponse::generated_message_descriptor_data());
            messages.push(cusrmsg_vguimenu::Subkey::generated_message_descriptor_data());
            messages.push(cusrmsg_voice_mask::PlayerMask::generated_message_descriptor_data());
            messages.push(cusrmsg_process_spotted_entity_update::SpottedEntityUpdate::generated_message_descriptor_data());
            messages.push(cusrmsg_player_stats_update::Stat::generated_message_descriptor_data());
            messages.push(cusrmsg_server_rank_update::RankUpdate::generated_message_descriptor_data());
            messages.push(cusrmsg_survival_stats::Fact::generated_message_descriptor_data());
            messages.push(cusrmsg_survival_stats::Placement::generated_message_descriptor_data());
            messages.push(cusrmsg_survival_stats::Damage::generated_message_descriptor_data());
            messages.push(cusrmsg_end_of_match_all_players_data::Accolade::generated_message_descriptor_data());
            messages.push(cusrmsg_end_of_match_all_players_data::PlayerData::generated_message_descriptor_data());
            messages.push(cusrmsg_round_impact_score_data::RisEvent::generated_message_descriptor_data());
            messages.push(cusrmsg_round_impact_score_data::InitialConditions::generated_message_descriptor_data());
            messages.push(cusrmsg_round_impact_score_data::ris_event::Victim::generated_message_descriptor_data());
            messages.push(cusrmsg_round_impact_score_data::ris_event::Objective::generated_message_descriptor_data());
            messages.push(cusrmsg_round_impact_score_data::ris_event::Damage::generated_message_descriptor_data());
            messages.push(cusrmsg_util_message_response::ItemDetail::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(USR_Messages::generated_enum_descriptor_data());
            enums.push(ECSUsrMsg_DisconnectToLobby_Action::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
