// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc 3.21.12
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `netmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgVector)
pub struct CMsgVector {
    // message fields
    // @@protoc_insertion_point(field:CMsgVector.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgVector.y)
    pub y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgVector.z)
    pub z: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVector.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVector {
    fn default() -> &'a CMsgVector {
        <CMsgVector as ::protobuf::Message>::default_instance()
    }
}

impl CMsgVector {
    pub fn new() -> CMsgVector {
        ::std::default::Default::default()
    }

    // optional float x = 1;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 2;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional float z = 3;

    pub fn z(&self) -> f32 {
        self.z.unwrap_or(0.)
    }

    pub fn clear_z(&mut self) {
        self.z = ::std::option::Option::None;
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgVector| { &m.x },
            |m: &mut CMsgVector| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgVector| { &m.y },
            |m: &mut CMsgVector| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "z",
            |m: &CMsgVector| { &m.z },
            |m: &mut CMsgVector| { &mut m.z },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgVector>(
            "CMsgVector",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgVector {
    const NAME: &'static str = "CMsgVector";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.z = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.z {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.z {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVector {
        CMsgVector::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVector {
        static instance: CMsgVector = CMsgVector {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            z: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgVector {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgVector").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgVector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgVector {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgVector2D)
pub struct CMsgVector2D {
    // message fields
    // @@protoc_insertion_point(field:CMsgVector2D.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgVector2D.y)
    pub y: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgVector2D.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgVector2D {
    fn default() -> &'a CMsgVector2D {
        <CMsgVector2D as ::protobuf::Message>::default_instance()
    }
}

impl CMsgVector2D {
    pub fn new() -> CMsgVector2D {
        ::std::default::Default::default()
    }

    // optional float x = 1;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 2;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgVector2D| { &m.x },
            |m: &mut CMsgVector2D| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgVector2D| { &m.y },
            |m: &mut CMsgVector2D| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgVector2D>(
            "CMsgVector2D",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgVector2D {
    const NAME: &'static str = "CMsgVector2D";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgVector2D {
        CMsgVector2D::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgVector2D {
        static instance: CMsgVector2D = CMsgVector2D {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgVector2D {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgVector2D").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgVector2D {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgVector2D {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgQAngle)
pub struct CMsgQAngle {
    // message fields
    // @@protoc_insertion_point(field:CMsgQAngle.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQAngle.y)
    pub y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgQAngle.z)
    pub z: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQAngle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQAngle {
    fn default() -> &'a CMsgQAngle {
        <CMsgQAngle as ::protobuf::Message>::default_instance()
    }
}

impl CMsgQAngle {
    pub fn new() -> CMsgQAngle {
        ::std::default::Default::default()
    }

    // optional float x = 1;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 2;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional float z = 3;

    pub fn z(&self) -> f32 {
        self.z.unwrap_or(0.)
    }

    pub fn clear_z(&mut self) {
        self.z = ::std::option::Option::None;
    }

    pub fn has_z(&self) -> bool {
        self.z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "x",
            |m: &CMsgQAngle| { &m.x },
            |m: &mut CMsgQAngle| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "y",
            |m: &CMsgQAngle| { &m.y },
            |m: &mut CMsgQAngle| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "z",
            |m: &CMsgQAngle| { &m.z },
            |m: &mut CMsgQAngle| { &mut m.z },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgQAngle>(
            "CMsgQAngle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgQAngle {
    const NAME: &'static str = "CMsgQAngle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.z = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.z {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.z {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQAngle {
        CMsgQAngle::new()
    }

    fn clear(&mut self) {
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQAngle {
        static instance: CMsgQAngle = CMsgQAngle {
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            z: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgQAngle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgQAngle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgQAngle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgQAngle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgRGBA)
pub struct CMsgRGBA {
    // message fields
    // @@protoc_insertion_point(field:CMsgRGBA.r)
    pub r: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRGBA.g)
    pub g: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRGBA.b)
    pub b: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgRGBA.a)
    pub a: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRGBA.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRGBA {
    fn default() -> &'a CMsgRGBA {
        <CMsgRGBA as ::protobuf::Message>::default_instance()
    }
}

impl CMsgRGBA {
    pub fn new() -> CMsgRGBA {
        ::std::default::Default::default()
    }

    // optional int32 r = 1;

    pub fn r(&self) -> i32 {
        self.r.unwrap_or(0)
    }

    pub fn clear_r(&mut self) {
        self.r = ::std::option::Option::None;
    }

    pub fn has_r(&self) -> bool {
        self.r.is_some()
    }

    // Param is passed by value, moved
    pub fn set_r(&mut self, v: i32) {
        self.r = ::std::option::Option::Some(v);
    }

    // optional int32 g = 2;

    pub fn g(&self) -> i32 {
        self.g.unwrap_or(0)
    }

    pub fn clear_g(&mut self) {
        self.g = ::std::option::Option::None;
    }

    pub fn has_g(&self) -> bool {
        self.g.is_some()
    }

    // Param is passed by value, moved
    pub fn set_g(&mut self, v: i32) {
        self.g = ::std::option::Option::Some(v);
    }

    // optional int32 b = 3;

    pub fn b(&self) -> i32 {
        self.b.unwrap_or(0)
    }

    pub fn clear_b(&mut self) {
        self.b = ::std::option::Option::None;
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: i32) {
        self.b = ::std::option::Option::Some(v);
    }

    // optional int32 a = 4;

    pub fn a(&self) -> i32 {
        self.a.unwrap_or(0)
    }

    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None;
    }

    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_a(&mut self, v: i32) {
        self.a = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "r",
            |m: &CMsgRGBA| { &m.r },
            |m: &mut CMsgRGBA| { &mut m.r },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "g",
            |m: &CMsgRGBA| { &m.g },
            |m: &mut CMsgRGBA| { &mut m.g },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "b",
            |m: &CMsgRGBA| { &m.b },
            |m: &mut CMsgRGBA| { &mut m.b },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "a",
            |m: &CMsgRGBA| { &m.a },
            |m: &mut CMsgRGBA| { &mut m.a },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgRGBA>(
            "CMsgRGBA",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgRGBA {
    const NAME: &'static str = "CMsgRGBA";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.r = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.g = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.b = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.a = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.r {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.g {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.b {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.a {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.r {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.g {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.b {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.a {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRGBA {
        CMsgRGBA::new()
    }

    fn clear(&mut self) {
        self.r = ::std::option::Option::None;
        self.g = ::std::option::Option::None;
        self.b = ::std::option::Option::None;
        self.a = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRGBA {
        static instance: CMsgRGBA = CMsgRGBA {
            r: ::std::option::Option::None,
            g: ::std::option::Option::None,
            b: ::std::option::Option::None,
            a: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgRGBA {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgRGBA").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgRGBA {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgRGBA {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CNETMsg_Tick)
pub struct CNETMsg_Tick {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_Tick.tick)
    pub tick: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.host_computationtime)
    pub host_computationtime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.host_computationtime_std_deviation)
    pub host_computationtime_std_deviation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.host_framestarttime_std_deviation)
    pub host_framestarttime_std_deviation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_Tick.hltv_replay_flags)
    pub hltv_replay_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_Tick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_Tick {
    fn default() -> &'a CNETMsg_Tick {
        <CNETMsg_Tick as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_Tick {
    pub fn new() -> CNETMsg_Tick {
        ::std::default::Default::default()
    }

    // optional uint32 tick = 1;

    pub fn tick(&self) -> u32 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: u32) {
        self.tick = ::std::option::Option::Some(v);
    }

    // optional uint32 host_computationtime = 4;

    pub fn host_computationtime(&self) -> u32 {
        self.host_computationtime.unwrap_or(0)
    }

    pub fn clear_host_computationtime(&mut self) {
        self.host_computationtime = ::std::option::Option::None;
    }

    pub fn has_host_computationtime(&self) -> bool {
        self.host_computationtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_computationtime(&mut self, v: u32) {
        self.host_computationtime = ::std::option::Option::Some(v);
    }

    // optional uint32 host_computationtime_std_deviation = 5;

    pub fn host_computationtime_std_deviation(&self) -> u32 {
        self.host_computationtime_std_deviation.unwrap_or(0)
    }

    pub fn clear_host_computationtime_std_deviation(&mut self) {
        self.host_computationtime_std_deviation = ::std::option::Option::None;
    }

    pub fn has_host_computationtime_std_deviation(&self) -> bool {
        self.host_computationtime_std_deviation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_computationtime_std_deviation(&mut self, v: u32) {
        self.host_computationtime_std_deviation = ::std::option::Option::Some(v);
    }

    // optional uint32 host_framestarttime_std_deviation = 6;

    pub fn host_framestarttime_std_deviation(&self) -> u32 {
        self.host_framestarttime_std_deviation.unwrap_or(0)
    }

    pub fn clear_host_framestarttime_std_deviation(&mut self) {
        self.host_framestarttime_std_deviation = ::std::option::Option::None;
    }

    pub fn has_host_framestarttime_std_deviation(&self) -> bool {
        self.host_framestarttime_std_deviation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_framestarttime_std_deviation(&mut self, v: u32) {
        self.host_framestarttime_std_deviation = ::std::option::Option::Some(v);
    }

    // optional uint32 hltv_replay_flags = 7;

    pub fn hltv_replay_flags(&self) -> u32 {
        self.hltv_replay_flags.unwrap_or(0)
    }

    pub fn clear_hltv_replay_flags(&mut self) {
        self.hltv_replay_flags = ::std::option::Option::None;
    }

    pub fn has_hltv_replay_flags(&self) -> bool {
        self.hltv_replay_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hltv_replay_flags(&mut self, v: u32) {
        self.hltv_replay_flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick",
            |m: &CNETMsg_Tick| { &m.tick },
            |m: &mut CNETMsg_Tick| { &mut m.tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host_computationtime",
            |m: &CNETMsg_Tick| { &m.host_computationtime },
            |m: &mut CNETMsg_Tick| { &mut m.host_computationtime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host_computationtime_std_deviation",
            |m: &CNETMsg_Tick| { &m.host_computationtime_std_deviation },
            |m: &mut CNETMsg_Tick| { &mut m.host_computationtime_std_deviation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host_framestarttime_std_deviation",
            |m: &CNETMsg_Tick| { &m.host_framestarttime_std_deviation },
            |m: &mut CNETMsg_Tick| { &mut m.host_framestarttime_std_deviation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hltv_replay_flags",
            |m: &CNETMsg_Tick| { &m.hltv_replay_flags },
            |m: &mut CNETMsg_Tick| { &mut m.hltv_replay_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_Tick>(
            "CNETMsg_Tick",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_Tick {
    const NAME: &'static str = "CNETMsg_Tick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tick = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.host_computationtime = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.host_computationtime_std_deviation = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.host_framestarttime_std_deviation = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.hltv_replay_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tick {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.host_computationtime {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.host_computationtime_std_deviation {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.host_framestarttime_std_deviation {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.hltv_replay_flags {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tick {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.host_computationtime {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.host_computationtime_std_deviation {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.host_framestarttime_std_deviation {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.hltv_replay_flags {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_Tick {
        CNETMsg_Tick::new()
    }

    fn clear(&mut self) {
        self.tick = ::std::option::Option::None;
        self.host_computationtime = ::std::option::Option::None;
        self.host_computationtime_std_deviation = ::std::option::Option::None;
        self.host_framestarttime_std_deviation = ::std::option::Option::None;
        self.hltv_replay_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_Tick {
        static instance: CNETMsg_Tick = CNETMsg_Tick {
            tick: ::std::option::Option::None,
            host_computationtime: ::std::option::Option::None,
            host_computationtime_std_deviation: ::std::option::Option::None,
            host_framestarttime_std_deviation: ::std::option::Option::None,
            hltv_replay_flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_Tick {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_Tick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_Tick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_Tick {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CNETMsg_StringCmd)
pub struct CNETMsg_StringCmd {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_StringCmd.command)
    pub command: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_StringCmd.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_StringCmd {
    fn default() -> &'a CNETMsg_StringCmd {
        <CNETMsg_StringCmd as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_StringCmd {
    pub fn new() -> CNETMsg_StringCmd {
        ::std::default::Default::default()
    }

    // optional string command = 1;

    pub fn command(&self) -> &str {
        match self.command.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::protobuf::Chars) {
        self.command = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command(&mut self) -> &mut ::protobuf::Chars {
        if self.command.is_none() {
            self.command = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.command.as_mut().unwrap()
    }

    // Take field
    pub fn take_command(&mut self) -> ::protobuf::Chars {
        self.command.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "command",
            |m: &CNETMsg_StringCmd| { &m.command },
            |m: &mut CNETMsg_StringCmd| { &mut m.command },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_StringCmd>(
            "CNETMsg_StringCmd",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_StringCmd {
    const NAME: &'static str = "CNETMsg_StringCmd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.command = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.command.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.command.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_StringCmd {
        CNETMsg_StringCmd::new()
    }

    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_StringCmd {
        static instance: CNETMsg_StringCmd = CNETMsg_StringCmd {
            command: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_StringCmd {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_StringCmd").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_StringCmd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_StringCmd {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CNETMsg_SignonState)
pub struct CNETMsg_SignonState {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SignonState.signon_state)
    pub signon_state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SignonState.spawn_count)
    pub spawn_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SignonState.num_server_players)
    pub num_server_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_SignonState.players_networkids)
    pub players_networkids: ::std::vec::Vec<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CNETMsg_SignonState.map_name)
    pub map_name: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SignonState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SignonState {
    fn default() -> &'a CNETMsg_SignonState {
        <CNETMsg_SignonState as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SignonState {
    pub fn new() -> CNETMsg_SignonState {
        ::std::default::Default::default()
    }

    // optional uint32 signon_state = 1;

    pub fn signon_state(&self) -> u32 {
        self.signon_state.unwrap_or(0)
    }

    pub fn clear_signon_state(&mut self) {
        self.signon_state = ::std::option::Option::None;
    }

    pub fn has_signon_state(&self) -> bool {
        self.signon_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signon_state(&mut self, v: u32) {
        self.signon_state = ::std::option::Option::Some(v);
    }

    // optional uint32 spawn_count = 2;

    pub fn spawn_count(&self) -> u32 {
        self.spawn_count.unwrap_or(0)
    }

    pub fn clear_spawn_count(&mut self) {
        self.spawn_count = ::std::option::Option::None;
    }

    pub fn has_spawn_count(&self) -> bool {
        self.spawn_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawn_count(&mut self, v: u32) {
        self.spawn_count = ::std::option::Option::Some(v);
    }

    // optional uint32 num_server_players = 3;

    pub fn num_server_players(&self) -> u32 {
        self.num_server_players.unwrap_or(0)
    }

    pub fn clear_num_server_players(&mut self) {
        self.num_server_players = ::std::option::Option::None;
    }

    pub fn has_num_server_players(&self) -> bool {
        self.num_server_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_server_players(&mut self, v: u32) {
        self.num_server_players = ::std::option::Option::Some(v);
    }

    // optional string map_name = 5;

    pub fn map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_name(&mut self) {
        self.map_name = ::std::option::Option::None;
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::protobuf::Chars) {
        self.map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::protobuf::Chars {
        if self.map_name.is_none() {
            self.map_name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::protobuf::Chars {
        self.map_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "signon_state",
            |m: &CNETMsg_SignonState| { &m.signon_state },
            |m: &mut CNETMsg_SignonState| { &mut m.signon_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spawn_count",
            |m: &CNETMsg_SignonState| { &m.spawn_count },
            |m: &mut CNETMsg_SignonState| { &mut m.spawn_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_server_players",
            |m: &CNETMsg_SignonState| { &m.num_server_players },
            |m: &mut CNETMsg_SignonState| { &mut m.num_server_players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players_networkids",
            |m: &CNETMsg_SignonState| { &m.players_networkids },
            |m: &mut CNETMsg_SignonState| { &mut m.players_networkids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_name",
            |m: &CNETMsg_SignonState| { &m.map_name },
            |m: &mut CNETMsg_SignonState| { &mut m.map_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_SignonState>(
            "CNETMsg_SignonState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_SignonState {
    const NAME: &'static str = "CNETMsg_SignonState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.signon_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.spawn_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.num_server_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.players_networkids.push(is.read_tokio_chars()?);
                },
                42 => {
                    self.map_name = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.signon_state {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.spawn_count {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.num_server_players {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.players_networkids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(v) = self.map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.signon_state {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.spawn_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_server_players {
            os.write_uint32(3, v)?;
        }
        for v in &self.players_networkids {
            os.write_string(4, &v)?;
        };
        if let Some(v) = self.map_name.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SignonState {
        CNETMsg_SignonState::new()
    }

    fn clear(&mut self) {
        self.signon_state = ::std::option::Option::None;
        self.spawn_count = ::std::option::Option::None;
        self.num_server_players = ::std::option::Option::None;
        self.players_networkids.clear();
        self.map_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SignonState {
        static instance: CNETMsg_SignonState = CNETMsg_SignonState {
            signon_state: ::std::option::Option::None,
            spawn_count: ::std::option::Option::None,
            num_server_players: ::std::option::Option::None,
            players_networkids: ::std::vec::Vec::new(),
            map_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_SignonState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_SignonState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_SignonState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_SignonState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsg_CVars)
pub struct CMsg_CVars {
    // message fields
    // @@protoc_insertion_point(field:CMsg_CVars.cvars)
    pub cvars: ::std::vec::Vec<cmsg_cvars::CVar>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsg_CVars.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsg_CVars {
    fn default() -> &'a CMsg_CVars {
        <CMsg_CVars as ::protobuf::Message>::default_instance()
    }
}

impl CMsg_CVars {
    pub fn new() -> CMsg_CVars {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cvars",
            |m: &CMsg_CVars| { &m.cvars },
            |m: &mut CMsg_CVars| { &mut m.cvars },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsg_CVars>(
            "CMsg_CVars",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsg_CVars {
    const NAME: &'static str = "CMsg_CVars";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cvars.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cvars {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.cvars {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsg_CVars {
        CMsg_CVars::new()
    }

    fn clear(&mut self) {
        self.cvars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsg_CVars {
        static instance: CMsg_CVars = CMsg_CVars {
            cvars: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsg_CVars {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsg_CVars").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsg_CVars {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsg_CVars {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsg_CVars`
pub mod cmsg_cvars {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsg_CVars.CVar)
    pub struct CVar {
        // message fields
        // @@protoc_insertion_point(field:CMsg_CVars.CVar.name)
        pub name: ::std::option::Option<::protobuf::Chars>,
        // @@protoc_insertion_point(field:CMsg_CVars.CVar.value)
        pub value: ::std::option::Option<::protobuf::Chars>,
        // @@protoc_insertion_point(field:CMsg_CVars.CVar.dictionary_name)
        pub dictionary_name: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsg_CVars.CVar.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CVar {
        fn default() -> &'a CVar {
            <CVar as ::protobuf::Message>::default_instance()
        }
    }

    impl CVar {
        pub fn new() -> CVar {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::protobuf::Chars) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::protobuf::Chars {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::protobuf::Chars::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::protobuf::Chars {
            self.name.take().unwrap_or_else(|| ::protobuf::Chars::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::protobuf::Chars) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::protobuf::Chars {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::protobuf::Chars::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::protobuf::Chars {
            self.value.take().unwrap_or_else(|| ::protobuf::Chars::new())
        }

        // optional uint32 dictionary_name = 3;

        pub fn dictionary_name(&self) -> u32 {
            self.dictionary_name.unwrap_or(0)
        }

        pub fn clear_dictionary_name(&mut self) {
            self.dictionary_name = ::std::option::Option::None;
        }

        pub fn has_dictionary_name(&self) -> bool {
            self.dictionary_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dictionary_name(&mut self, v: u32) {
            self.dictionary_name = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &CVar| { &m.name },
                |m: &mut CVar| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "value",
                |m: &CVar| { &m.value },
                |m: &mut CVar| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dictionary_name",
                |m: &CVar| { &m.dictionary_name },
                |m: &mut CVar| { &mut m.dictionary_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CVar>(
                "CMsg_CVars.CVar",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for CVar {
        const NAME: &'static str = "CVar";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_tokio_chars()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_tokio_chars()?);
                    },
                    24 => {
                        self.dictionary_name = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.dictionary_name {
                my_size += ::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.dictionary_name {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CVar {
            CVar::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.dictionary_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CVar {
            static instance: CVar = CVar {
                name: ::std::option::Option::None,
                value: ::std::option::Option::None,
                dictionary_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for CVar {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsg_CVars.CVar").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for CVar {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for CVar {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CNETMsg_SetConVar)
pub struct CNETMsg_SetConVar {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SetConVar.convars)
    pub convars: ::protobuf::MessageField<CMsg_CVars>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SetConVar.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SetConVar {
    fn default() -> &'a CNETMsg_SetConVar {
        <CNETMsg_SetConVar as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SetConVar {
    pub fn new() -> CNETMsg_SetConVar {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsg_CVars>(
            "convars",
            |m: &CNETMsg_SetConVar| { &m.convars },
            |m: &mut CNETMsg_SetConVar| { &mut m.convars },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_SetConVar>(
            "CNETMsg_SetConVar",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_SetConVar {
    const NAME: &'static str = "CNETMsg_SetConVar";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.convars)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.convars.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.convars.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SetConVar {
        CNETMsg_SetConVar::new()
    }

    fn clear(&mut self) {
        self.convars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SetConVar {
        static instance: CNETMsg_SetConVar = CNETMsg_SetConVar {
            convars: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_SetConVar {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_SetConVar").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_SetConVar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_SetConVar {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CNETMsg_NOP)
pub struct CNETMsg_NOP {
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_NOP.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_NOP {
    fn default() -> &'a CNETMsg_NOP {
        <CNETMsg_NOP as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_NOP {
    pub fn new() -> CNETMsg_NOP {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_NOP>(
            "CNETMsg_NOP",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_NOP {
    const NAME: &'static str = "CNETMsg_NOP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_NOP {
        CNETMsg_NOP::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_NOP {
        static instance: CNETMsg_NOP = CNETMsg_NOP {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_NOP {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_NOP").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_NOP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_NOP {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CNETMsg_Disconnect)
pub struct CNETMsg_Disconnect {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_Disconnect.text)
    pub text: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_Disconnect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_Disconnect {
    fn default() -> &'a CNETMsg_Disconnect {
        <CNETMsg_Disconnect as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_Disconnect {
    pub fn new() -> CNETMsg_Disconnect {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::protobuf::Chars) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::protobuf::Chars {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::protobuf::Chars {
        self.text.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CNETMsg_Disconnect| { &m.text },
            |m: &mut CNETMsg_Disconnect| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_Disconnect>(
            "CNETMsg_Disconnect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_Disconnect {
    const NAME: &'static str = "CNETMsg_Disconnect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_Disconnect {
        CNETMsg_Disconnect::new()
    }

    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_Disconnect {
        static instance: CNETMsg_Disconnect = CNETMsg_Disconnect {
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_Disconnect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_Disconnect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_Disconnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_Disconnect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CNETMsg_File)
pub struct CNETMsg_File {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_File.transfer_id)
    pub transfer_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CNETMsg_File.file_name)
    pub file_name: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CNETMsg_File.is_replay_demo_file)
    pub is_replay_demo_file: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CNETMsg_File.deny)
    pub deny: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_File.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_File {
    fn default() -> &'a CNETMsg_File {
        <CNETMsg_File as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_File {
    pub fn new() -> CNETMsg_File {
        ::std::default::Default::default()
    }

    // optional int32 transfer_id = 1;

    pub fn transfer_id(&self) -> i32 {
        self.transfer_id.unwrap_or(0)
    }

    pub fn clear_transfer_id(&mut self) {
        self.transfer_id = ::std::option::Option::None;
    }

    pub fn has_transfer_id(&self) -> bool {
        self.transfer_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transfer_id(&mut self, v: i32) {
        self.transfer_id = ::std::option::Option::Some(v);
    }

    // optional string file_name = 2;

    pub fn file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name = ::std::option::Option::None;
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::protobuf::Chars) {
        self.file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::protobuf::Chars {
        if self.file_name.is_none() {
            self.file_name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::protobuf::Chars {
        self.file_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional bool is_replay_demo_file = 3;

    pub fn is_replay_demo_file(&self) -> bool {
        self.is_replay_demo_file.unwrap_or(false)
    }

    pub fn clear_is_replay_demo_file(&mut self) {
        self.is_replay_demo_file = ::std::option::Option::None;
    }

    pub fn has_is_replay_demo_file(&self) -> bool {
        self.is_replay_demo_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_replay_demo_file(&mut self, v: bool) {
        self.is_replay_demo_file = ::std::option::Option::Some(v);
    }

    // optional bool deny = 4;

    pub fn deny(&self) -> bool {
        self.deny.unwrap_or(false)
    }

    pub fn clear_deny(&mut self) {
        self.deny = ::std::option::Option::None;
    }

    pub fn has_deny(&self) -> bool {
        self.deny.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deny(&mut self, v: bool) {
        self.deny = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "transfer_id",
            |m: &CNETMsg_File| { &m.transfer_id },
            |m: &mut CNETMsg_File| { &mut m.transfer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_name",
            |m: &CNETMsg_File| { &m.file_name },
            |m: &mut CNETMsg_File| { &mut m.file_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_replay_demo_file",
            |m: &CNETMsg_File| { &m.is_replay_demo_file },
            |m: &mut CNETMsg_File| { &mut m.is_replay_demo_file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deny",
            |m: &CNETMsg_File| { &m.deny },
            |m: &mut CNETMsg_File| { &mut m.deny },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_File>(
            "CNETMsg_File",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_File {
    const NAME: &'static str = "CNETMsg_File";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.transfer_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.file_name = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                24 => {
                    self.is_replay_demo_file = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.deny = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.transfer_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.is_replay_demo_file {
            my_size += 1 + 1;
        }
        if let Some(v) = self.deny {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.transfer_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.is_replay_demo_file {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.deny {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_File {
        CNETMsg_File::new()
    }

    fn clear(&mut self) {
        self.transfer_id = ::std::option::Option::None;
        self.file_name = ::std::option::Option::None;
        self.is_replay_demo_file = ::std::option::Option::None;
        self.deny = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_File {
        static instance: CNETMsg_File = CNETMsg_File {
            transfer_id: ::std::option::Option::None,
            file_name: ::std::option::Option::None,
            is_replay_demo_file: ::std::option::Option::None,
            deny: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_File {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_File").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_File {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_File {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CNETMsg_SplitScreenUser)
pub struct CNETMsg_SplitScreenUser {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_SplitScreenUser.slot)
    pub slot: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_SplitScreenUser.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_SplitScreenUser {
    fn default() -> &'a CNETMsg_SplitScreenUser {
        <CNETMsg_SplitScreenUser as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_SplitScreenUser {
    pub fn new() -> CNETMsg_SplitScreenUser {
        ::std::default::Default::default()
    }

    // optional int32 slot = 1;

    pub fn slot(&self) -> i32 {
        self.slot.unwrap_or(0)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot",
            |m: &CNETMsg_SplitScreenUser| { &m.slot },
            |m: &mut CNETMsg_SplitScreenUser| { &mut m.slot },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_SplitScreenUser>(
            "CNETMsg_SplitScreenUser",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_SplitScreenUser {
    const NAME: &'static str = "CNETMsg_SplitScreenUser";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.slot = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.slot {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.slot {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_SplitScreenUser {
        CNETMsg_SplitScreenUser::new()
    }

    fn clear(&mut self) {
        self.slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_SplitScreenUser {
        static instance: CNETMsg_SplitScreenUser = CNETMsg_SplitScreenUser {
            slot: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_SplitScreenUser {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_SplitScreenUser").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_SplitScreenUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_SplitScreenUser {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CNETMsg_PlayerAvatarData)
pub struct CNETMsg_PlayerAvatarData {
    // message fields
    // @@protoc_insertion_point(field:CNETMsg_PlayerAvatarData.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CNETMsg_PlayerAvatarData.rgb)
    pub rgb: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CNETMsg_PlayerAvatarData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CNETMsg_PlayerAvatarData {
    fn default() -> &'a CNETMsg_PlayerAvatarData {
        <CNETMsg_PlayerAvatarData as ::protobuf::Message>::default_instance()
    }
}

impl CNETMsg_PlayerAvatarData {
    pub fn new() -> CNETMsg_PlayerAvatarData {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional bytes rgb = 2;

    pub fn rgb(&self) -> &[u8] {
        match self.rgb.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_rgb(&mut self) {
        self.rgb = ::std::option::Option::None;
    }

    pub fn has_rgb(&self) -> bool {
        self.rgb.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rgb(&mut self, v: ::bytes::Bytes) {
        self.rgb = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rgb(&mut self) -> &mut ::bytes::Bytes {
        if self.rgb.is_none() {
            self.rgb = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.rgb.as_mut().unwrap()
    }

    // Take field
    pub fn take_rgb(&mut self) -> ::bytes::Bytes {
        self.rgb.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CNETMsg_PlayerAvatarData| { &m.accountid },
            |m: &mut CNETMsg_PlayerAvatarData| { &mut m.accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rgb",
            |m: &CNETMsg_PlayerAvatarData| { &m.rgb },
            |m: &mut CNETMsg_PlayerAvatarData| { &mut m.rgb },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CNETMsg_PlayerAvatarData>(
            "CNETMsg_PlayerAvatarData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CNETMsg_PlayerAvatarData {
    const NAME: &'static str = "CNETMsg_PlayerAvatarData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.rgb = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rgb.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rgb.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CNETMsg_PlayerAvatarData {
        CNETMsg_PlayerAvatarData::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.rgb = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CNETMsg_PlayerAvatarData {
        static instance: CNETMsg_PlayerAvatarData = CNETMsg_PlayerAvatarData {
            accountid: ::std::option::Option::None,
            rgb: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CNETMsg_PlayerAvatarData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CNETMsg_PlayerAvatarData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CNETMsg_PlayerAvatarData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CNETMsg_PlayerAvatarData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CCLCMsg_ClientInfo)
pub struct CCLCMsg_ClientInfo {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.send_table_crc)
    pub send_table_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.server_count)
    pub server_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.is_hltv)
    pub is_hltv: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.is_replay)
    pub is_replay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.friends_id)
    pub friends_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.friends_name)
    pub friends_name: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CCLCMsg_ClientInfo.custom_files)
    pub custom_files: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_ClientInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_ClientInfo {
    fn default() -> &'a CCLCMsg_ClientInfo {
        <CCLCMsg_ClientInfo as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_ClientInfo {
    pub fn new() -> CCLCMsg_ClientInfo {
        ::std::default::Default::default()
    }

    // optional fixed32 send_table_crc = 1;

    pub fn send_table_crc(&self) -> u32 {
        self.send_table_crc.unwrap_or(0)
    }

    pub fn clear_send_table_crc(&mut self) {
        self.send_table_crc = ::std::option::Option::None;
    }

    pub fn has_send_table_crc(&self) -> bool {
        self.send_table_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_table_crc(&mut self, v: u32) {
        self.send_table_crc = ::std::option::Option::Some(v);
    }

    // optional uint32 server_count = 2;

    pub fn server_count(&self) -> u32 {
        self.server_count.unwrap_or(0)
    }

    pub fn clear_server_count(&mut self) {
        self.server_count = ::std::option::Option::None;
    }

    pub fn has_server_count(&self) -> bool {
        self.server_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_count(&mut self, v: u32) {
        self.server_count = ::std::option::Option::Some(v);
    }

    // optional bool is_hltv = 3;

    pub fn is_hltv(&self) -> bool {
        self.is_hltv.unwrap_or(false)
    }

    pub fn clear_is_hltv(&mut self) {
        self.is_hltv = ::std::option::Option::None;
    }

    pub fn has_is_hltv(&self) -> bool {
        self.is_hltv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hltv(&mut self, v: bool) {
        self.is_hltv = ::std::option::Option::Some(v);
    }

    // optional bool is_replay = 4;

    pub fn is_replay(&self) -> bool {
        self.is_replay.unwrap_or(false)
    }

    pub fn clear_is_replay(&mut self) {
        self.is_replay = ::std::option::Option::None;
    }

    pub fn has_is_replay(&self) -> bool {
        self.is_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_replay(&mut self, v: bool) {
        self.is_replay = ::std::option::Option::Some(v);
    }

    // optional uint32 friends_id = 5;

    pub fn friends_id(&self) -> u32 {
        self.friends_id.unwrap_or(0)
    }

    pub fn clear_friends_id(&mut self) {
        self.friends_id = ::std::option::Option::None;
    }

    pub fn has_friends_id(&self) -> bool {
        self.friends_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_id(&mut self, v: u32) {
        self.friends_id = ::std::option::Option::Some(v);
    }

    // optional string friends_name = 6;

    pub fn friends_name(&self) -> &str {
        match self.friends_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_friends_name(&mut self) {
        self.friends_name = ::std::option::Option::None;
    }

    pub fn has_friends_name(&self) -> bool {
        self.friends_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_name(&mut self, v: ::protobuf::Chars) {
        self.friends_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_friends_name(&mut self) -> &mut ::protobuf::Chars {
        if self.friends_name.is_none() {
            self.friends_name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.friends_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_friends_name(&mut self) -> ::protobuf::Chars {
        self.friends_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "send_table_crc",
            |m: &CCLCMsg_ClientInfo| { &m.send_table_crc },
            |m: &mut CCLCMsg_ClientInfo| { &mut m.send_table_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_count",
            |m: &CCLCMsg_ClientInfo| { &m.server_count },
            |m: &mut CCLCMsg_ClientInfo| { &mut m.server_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_hltv",
            |m: &CCLCMsg_ClientInfo| { &m.is_hltv },
            |m: &mut CCLCMsg_ClientInfo| { &mut m.is_hltv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_replay",
            |m: &CCLCMsg_ClientInfo| { &m.is_replay },
            |m: &mut CCLCMsg_ClientInfo| { &mut m.is_replay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "friends_id",
            |m: &CCLCMsg_ClientInfo| { &m.friends_id },
            |m: &mut CCLCMsg_ClientInfo| { &mut m.friends_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "friends_name",
            |m: &CCLCMsg_ClientInfo| { &m.friends_name },
            |m: &mut CCLCMsg_ClientInfo| { &mut m.friends_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "custom_files",
            |m: &CCLCMsg_ClientInfo| { &m.custom_files },
            |m: &mut CCLCMsg_ClientInfo| { &mut m.custom_files },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_ClientInfo>(
            "CCLCMsg_ClientInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_ClientInfo {
    const NAME: &'static str = "CCLCMsg_ClientInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.send_table_crc = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.server_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.is_hltv = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.is_replay = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.friends_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.friends_name = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                58 => {
                    is.read_repeated_packed_fixed32_into(&mut self.custom_files)?;
                },
                61 => {
                    self.custom_files.push(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.send_table_crc {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_count {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.is_hltv {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_replay {
            my_size += 1 + 1;
        }
        if let Some(v) = self.friends_id {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.friends_name.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += 5 * self.custom_files.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.send_table_crc {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.server_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.is_hltv {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.is_replay {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.friends_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.friends_name.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.custom_files {
            os.write_fixed32(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_ClientInfo {
        CCLCMsg_ClientInfo::new()
    }

    fn clear(&mut self) {
        self.send_table_crc = ::std::option::Option::None;
        self.server_count = ::std::option::Option::None;
        self.is_hltv = ::std::option::Option::None;
        self.is_replay = ::std::option::Option::None;
        self.friends_id = ::std::option::Option::None;
        self.friends_name = ::std::option::Option::None;
        self.custom_files.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_ClientInfo {
        static instance: CCLCMsg_ClientInfo = CCLCMsg_ClientInfo {
            send_table_crc: ::std::option::Option::None,
            server_count: ::std::option::Option::None,
            is_hltv: ::std::option::Option::None,
            is_replay: ::std::option::Option::None,
            friends_id: ::std::option::Option::None,
            friends_name: ::std::option::Option::None,
            custom_files: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_ClientInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_ClientInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_ClientInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_ClientInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CCLCMsg_Move)
pub struct CCLCMsg_Move {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_Move.num_backup_commands)
    pub num_backup_commands: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCLCMsg_Move.num_new_commands)
    pub num_new_commands: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCLCMsg_Move.data)
    pub data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_Move.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_Move {
    fn default() -> &'a CCLCMsg_Move {
        <CCLCMsg_Move as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_Move {
    pub fn new() -> CCLCMsg_Move {
        ::std::default::Default::default()
    }

    // optional uint32 num_backup_commands = 1;

    pub fn num_backup_commands(&self) -> u32 {
        self.num_backup_commands.unwrap_or(0)
    }

    pub fn clear_num_backup_commands(&mut self) {
        self.num_backup_commands = ::std::option::Option::None;
    }

    pub fn has_num_backup_commands(&self) -> bool {
        self.num_backup_commands.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_backup_commands(&mut self, v: u32) {
        self.num_backup_commands = ::std::option::Option::Some(v);
    }

    // optional uint32 num_new_commands = 2;

    pub fn num_new_commands(&self) -> u32 {
        self.num_new_commands.unwrap_or(0)
    }

    pub fn clear_num_new_commands(&mut self) {
        self.num_new_commands = ::std::option::Option::None;
    }

    pub fn has_num_new_commands(&self) -> bool {
        self.num_new_commands.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_new_commands(&mut self, v: u32) {
        self.num_new_commands = ::std::option::Option::Some(v);
    }

    // optional bytes data = 3;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_backup_commands",
            |m: &CCLCMsg_Move| { &m.num_backup_commands },
            |m: &mut CCLCMsg_Move| { &mut m.num_backup_commands },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_new_commands",
            |m: &CCLCMsg_Move| { &m.num_new_commands },
            |m: &mut CCLCMsg_Move| { &mut m.num_new_commands },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CCLCMsg_Move| { &m.data },
            |m: &mut CCLCMsg_Move| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_Move>(
            "CCLCMsg_Move",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_Move {
    const NAME: &'static str = "CCLCMsg_Move";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_backup_commands = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.num_new_commands = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.num_backup_commands {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.num_new_commands {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.num_backup_commands {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_new_commands {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_Move {
        CCLCMsg_Move::new()
    }

    fn clear(&mut self) {
        self.num_backup_commands = ::std::option::Option::None;
        self.num_new_commands = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_Move {
        static instance: CCLCMsg_Move = CCLCMsg_Move {
            num_backup_commands: ::std::option::Option::None,
            num_new_commands: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_Move {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_Move").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_Move {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_Move {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CCLCMsg_VoiceData)
pub struct CCLCMsg_VoiceData {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_VoiceData.data)
    pub data: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CCLCMsg_VoiceData.xuid)
    pub xuid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCLCMsg_VoiceData.format)
    pub format: ::std::option::Option<::protobuf::EnumOrUnknown<VoiceDataFormat_t>>,
    // @@protoc_insertion_point(field:CCLCMsg_VoiceData.sequence_bytes)
    pub sequence_bytes: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_VoiceData.section_number)
    pub section_number: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCLCMsg_VoiceData.uncompressed_sample_offset)
    pub uncompressed_sample_offset: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_VoiceData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_VoiceData {
    fn default() -> &'a CCLCMsg_VoiceData {
        <CCLCMsg_VoiceData as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_VoiceData {
    pub fn new() -> CCLCMsg_VoiceData {
        ::std::default::Default::default()
    }

    // optional bytes data = 1;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::bytes::Bytes) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::bytes::Bytes {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::bytes::Bytes {
        self.data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional fixed64 xuid = 2;

    pub fn xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }

    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional .VoiceDataFormat_t format = 3;

    pub fn format(&self) -> VoiceDataFormat_t {
        match self.format {
            Some(e) => e.enum_value_or(VoiceDataFormat_t::VOICEDATA_FORMAT_ENGINE),
            None => VoiceDataFormat_t::VOICEDATA_FORMAT_ENGINE,
        }
    }

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: VoiceDataFormat_t) {
        self.format = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 sequence_bytes = 4;

    pub fn sequence_bytes(&self) -> i32 {
        self.sequence_bytes.unwrap_or(0)
    }

    pub fn clear_sequence_bytes(&mut self) {
        self.sequence_bytes = ::std::option::Option::None;
    }

    pub fn has_sequence_bytes(&self) -> bool {
        self.sequence_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_bytes(&mut self, v: i32) {
        self.sequence_bytes = ::std::option::Option::Some(v);
    }

    // optional uint32 section_number = 5;

    pub fn section_number(&self) -> u32 {
        self.section_number.unwrap_or(0)
    }

    pub fn clear_section_number(&mut self) {
        self.section_number = ::std::option::Option::None;
    }

    pub fn has_section_number(&self) -> bool {
        self.section_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_section_number(&mut self, v: u32) {
        self.section_number = ::std::option::Option::Some(v);
    }

    // optional uint32 uncompressed_sample_offset = 6;

    pub fn uncompressed_sample_offset(&self) -> u32 {
        self.uncompressed_sample_offset.unwrap_or(0)
    }

    pub fn clear_uncompressed_sample_offset(&mut self) {
        self.uncompressed_sample_offset = ::std::option::Option::None;
    }

    pub fn has_uncompressed_sample_offset(&self) -> bool {
        self.uncompressed_sample_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uncompressed_sample_offset(&mut self, v: u32) {
        self.uncompressed_sample_offset = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "data",
            |m: &CCLCMsg_VoiceData| { &m.data },
            |m: &mut CCLCMsg_VoiceData| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xuid",
            |m: &CCLCMsg_VoiceData| { &m.xuid },
            |m: &mut CCLCMsg_VoiceData| { &mut m.xuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "format",
            |m: &CCLCMsg_VoiceData| { &m.format },
            |m: &mut CCLCMsg_VoiceData| { &mut m.format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequence_bytes",
            |m: &CCLCMsg_VoiceData| { &m.sequence_bytes },
            |m: &mut CCLCMsg_VoiceData| { &mut m.sequence_bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "section_number",
            |m: &CCLCMsg_VoiceData| { &m.section_number },
            |m: &mut CCLCMsg_VoiceData| { &mut m.section_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uncompressed_sample_offset",
            |m: &CCLCMsg_VoiceData| { &m.uncompressed_sample_offset },
            |m: &mut CCLCMsg_VoiceData| { &mut m.uncompressed_sample_offset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_VoiceData>(
            "CCLCMsg_VoiceData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_VoiceData {
    const NAME: &'static str = "CCLCMsg_VoiceData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                17 => {
                    self.xuid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.format = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.sequence_bytes = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.section_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.uncompressed_sample_offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.xuid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.format {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.sequence_bytes {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.section_number {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.uncompressed_sample_offset {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.xuid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.format {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.sequence_bytes {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.section_number {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.uncompressed_sample_offset {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_VoiceData {
        CCLCMsg_VoiceData::new()
    }

    fn clear(&mut self) {
        self.data = ::std::option::Option::None;
        self.xuid = ::std::option::Option::None;
        self.format = ::std::option::Option::None;
        self.sequence_bytes = ::std::option::Option::None;
        self.section_number = ::std::option::Option::None;
        self.uncompressed_sample_offset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_VoiceData {
        static instance: CCLCMsg_VoiceData = CCLCMsg_VoiceData {
            data: ::std::option::Option::None,
            xuid: ::std::option::Option::None,
            format: ::std::option::Option::None,
            sequence_bytes: ::std::option::Option::None,
            section_number: ::std::option::Option::None,
            uncompressed_sample_offset: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_VoiceData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_VoiceData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_VoiceData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_VoiceData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CCLCMsg_BaselineAck)
pub struct CCLCMsg_BaselineAck {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_BaselineAck.baseline_tick)
    pub baseline_tick: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_BaselineAck.baseline_nr)
    pub baseline_nr: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_BaselineAck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_BaselineAck {
    fn default() -> &'a CCLCMsg_BaselineAck {
        <CCLCMsg_BaselineAck as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_BaselineAck {
    pub fn new() -> CCLCMsg_BaselineAck {
        ::std::default::Default::default()
    }

    // optional int32 baseline_tick = 1;

    pub fn baseline_tick(&self) -> i32 {
        self.baseline_tick.unwrap_or(0)
    }

    pub fn clear_baseline_tick(&mut self) {
        self.baseline_tick = ::std::option::Option::None;
    }

    pub fn has_baseline_tick(&self) -> bool {
        self.baseline_tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseline_tick(&mut self, v: i32) {
        self.baseline_tick = ::std::option::Option::Some(v);
    }

    // optional int32 baseline_nr = 2;

    pub fn baseline_nr(&self) -> i32 {
        self.baseline_nr.unwrap_or(0)
    }

    pub fn clear_baseline_nr(&mut self) {
        self.baseline_nr = ::std::option::Option::None;
    }

    pub fn has_baseline_nr(&self) -> bool {
        self.baseline_nr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseline_nr(&mut self, v: i32) {
        self.baseline_nr = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "baseline_tick",
            |m: &CCLCMsg_BaselineAck| { &m.baseline_tick },
            |m: &mut CCLCMsg_BaselineAck| { &mut m.baseline_tick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "baseline_nr",
            |m: &CCLCMsg_BaselineAck| { &m.baseline_nr },
            |m: &mut CCLCMsg_BaselineAck| { &mut m.baseline_nr },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_BaselineAck>(
            "CCLCMsg_BaselineAck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_BaselineAck {
    const NAME: &'static str = "CCLCMsg_BaselineAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.baseline_tick = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.baseline_nr = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.baseline_tick {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.baseline_nr {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.baseline_tick {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.baseline_nr {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_BaselineAck {
        CCLCMsg_BaselineAck::new()
    }

    fn clear(&mut self) {
        self.baseline_tick = ::std::option::Option::None;
        self.baseline_nr = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_BaselineAck {
        static instance: CCLCMsg_BaselineAck = CCLCMsg_BaselineAck {
            baseline_tick: ::std::option::Option::None,
            baseline_nr: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_BaselineAck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_BaselineAck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_BaselineAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_BaselineAck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CCLCMsg_ListenEvents)
pub struct CCLCMsg_ListenEvents {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_ListenEvents.event_mask)
    pub event_mask: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_ListenEvents.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_ListenEvents {
    fn default() -> &'a CCLCMsg_ListenEvents {
        <CCLCMsg_ListenEvents as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_ListenEvents {
    pub fn new() -> CCLCMsg_ListenEvents {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "event_mask",
            |m: &CCLCMsg_ListenEvents| { &m.event_mask },
            |m: &mut CCLCMsg_ListenEvents| { &mut m.event_mask },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_ListenEvents>(
            "CCLCMsg_ListenEvents",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_ListenEvents {
    const NAME: &'static str = "CCLCMsg_ListenEvents";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed32_into(&mut self.event_mask)?;
                },
                13 => {
                    self.event_mask.push(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.event_mask.len() as u64;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.event_mask {
            os.write_fixed32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_ListenEvents {
        CCLCMsg_ListenEvents::new()
    }

    fn clear(&mut self) {
        self.event_mask.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_ListenEvents {
        static instance: CCLCMsg_ListenEvents = CCLCMsg_ListenEvents {
            event_mask: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_ListenEvents {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_ListenEvents").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_ListenEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_ListenEvents {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CCLCMsg_RespondCvarValue)
pub struct CCLCMsg_RespondCvarValue {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_RespondCvarValue.cookie)
    pub cookie: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_RespondCvarValue.status_code)
    pub status_code: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_RespondCvarValue.name)
    pub name: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CCLCMsg_RespondCvarValue.value)
    pub value: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_RespondCvarValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_RespondCvarValue {
    fn default() -> &'a CCLCMsg_RespondCvarValue {
        <CCLCMsg_RespondCvarValue as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_RespondCvarValue {
    pub fn new() -> CCLCMsg_RespondCvarValue {
        ::std::default::Default::default()
    }

    // optional int32 cookie = 1;

    pub fn cookie(&self) -> i32 {
        self.cookie.unwrap_or(0)
    }

    pub fn clear_cookie(&mut self) {
        self.cookie = ::std::option::Option::None;
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: i32) {
        self.cookie = ::std::option::Option::Some(v);
    }

    // optional int32 status_code = 2;

    pub fn status_code(&self) -> i32 {
        self.status_code.unwrap_or(0)
    }

    pub fn clear_status_code(&mut self) {
        self.status_code = ::std::option::Option::None;
    }

    pub fn has_status_code(&self) -> bool {
        self.status_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_code(&mut self, v: i32) {
        self.status_code = ::std::option::Option::Some(v);
    }

    // optional string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::protobuf::Chars) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::protobuf::Chars {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::protobuf::Chars {
        self.name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional string value = 4;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::protobuf::Chars) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::protobuf::Chars {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::protobuf::Chars {
        self.value.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cookie",
            |m: &CCLCMsg_RespondCvarValue| { &m.cookie },
            |m: &mut CCLCMsg_RespondCvarValue| { &mut m.cookie },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "status_code",
            |m: &CCLCMsg_RespondCvarValue| { &m.status_code },
            |m: &mut CCLCMsg_RespondCvarValue| { &mut m.status_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CCLCMsg_RespondCvarValue| { &m.name },
            |m: &mut CCLCMsg_RespondCvarValue| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CCLCMsg_RespondCvarValue| { &m.value },
            |m: &mut CCLCMsg_RespondCvarValue| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_RespondCvarValue>(
            "CCLCMsg_RespondCvarValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_RespondCvarValue {
    const NAME: &'static str = "CCLCMsg_RespondCvarValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cookie = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.status_code = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                34 => {
                    self.value = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cookie {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.status_code {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cookie {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.status_code {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.value.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_RespondCvarValue {
        CCLCMsg_RespondCvarValue::new()
    }

    fn clear(&mut self) {
        self.cookie = ::std::option::Option::None;
        self.status_code = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_RespondCvarValue {
        static instance: CCLCMsg_RespondCvarValue = CCLCMsg_RespondCvarValue {
            cookie: ::std::option::Option::None,
            status_code: ::std::option::Option::None,
            name: ::std::option::Option::None,
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_RespondCvarValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_RespondCvarValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_RespondCvarValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_RespondCvarValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CCLCMsg_FileCRCCheck)
pub struct CCLCMsg_FileCRCCheck {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.code_path)
    pub code_path: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.path)
    pub path: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.code_filename)
    pub code_filename: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.filename)
    pub filename: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.file_fraction)
    pub file_fraction: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.md5)
    pub md5: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.crc)
    pub crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.file_hash_type)
    pub file_hash_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.file_len)
    pub file_len: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.pack_file_id)
    pub pack_file_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_FileCRCCheck.pack_file_number)
    pub pack_file_number: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_FileCRCCheck.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_FileCRCCheck {
    fn default() -> &'a CCLCMsg_FileCRCCheck {
        <CCLCMsg_FileCRCCheck as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_FileCRCCheck {
    pub fn new() -> CCLCMsg_FileCRCCheck {
        ::std::default::Default::default()
    }

    // optional int32 code_path = 1;

    pub fn code_path(&self) -> i32 {
        self.code_path.unwrap_or(0)
    }

    pub fn clear_code_path(&mut self) {
        self.code_path = ::std::option::Option::None;
    }

    pub fn has_code_path(&self) -> bool {
        self.code_path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code_path(&mut self, v: i32) {
        self.code_path = ::std::option::Option::Some(v);
    }

    // optional string path = 2;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::protobuf::Chars) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::protobuf::Chars {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::protobuf::Chars {
        self.path.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional int32 code_filename = 3;

    pub fn code_filename(&self) -> i32 {
        self.code_filename.unwrap_or(0)
    }

    pub fn clear_code_filename(&mut self) {
        self.code_filename = ::std::option::Option::None;
    }

    pub fn has_code_filename(&self) -> bool {
        self.code_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code_filename(&mut self, v: i32) {
        self.code_filename = ::std::option::Option::Some(v);
    }

    // optional string filename = 4;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::protobuf::Chars) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::protobuf::Chars {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::protobuf::Chars {
        self.filename.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional int32 file_fraction = 5;

    pub fn file_fraction(&self) -> i32 {
        self.file_fraction.unwrap_or(0)
    }

    pub fn clear_file_fraction(&mut self) {
        self.file_fraction = ::std::option::Option::None;
    }

    pub fn has_file_fraction(&self) -> bool {
        self.file_fraction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_fraction(&mut self, v: i32) {
        self.file_fraction = ::std::option::Option::Some(v);
    }

    // optional bytes md5 = 6;

    pub fn md5(&self) -> &[u8] {
        match self.md5.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_md5(&mut self) {
        self.md5 = ::std::option::Option::None;
    }

    pub fn has_md5(&self) -> bool {
        self.md5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_md5(&mut self, v: ::bytes::Bytes) {
        self.md5 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_md5(&mut self) -> &mut ::bytes::Bytes {
        if self.md5.is_none() {
            self.md5 = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.md5.as_mut().unwrap()
    }

    // Take field
    pub fn take_md5(&mut self) -> ::bytes::Bytes {
        self.md5.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional uint32 crc = 7;

    pub fn crc(&self) -> u32 {
        self.crc.unwrap_or(0)
    }

    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: u32) {
        self.crc = ::std::option::Option::Some(v);
    }

    // optional int32 file_hash_type = 8;

    pub fn file_hash_type(&self) -> i32 {
        self.file_hash_type.unwrap_or(0)
    }

    pub fn clear_file_hash_type(&mut self) {
        self.file_hash_type = ::std::option::Option::None;
    }

    pub fn has_file_hash_type(&self) -> bool {
        self.file_hash_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_hash_type(&mut self, v: i32) {
        self.file_hash_type = ::std::option::Option::Some(v);
    }

    // optional int32 file_len = 9;

    pub fn file_len(&self) -> i32 {
        self.file_len.unwrap_or(0)
    }

    pub fn clear_file_len(&mut self) {
        self.file_len = ::std::option::Option::None;
    }

    pub fn has_file_len(&self) -> bool {
        self.file_len.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_len(&mut self, v: i32) {
        self.file_len = ::std::option::Option::Some(v);
    }

    // optional int32 pack_file_id = 10;

    pub fn pack_file_id(&self) -> i32 {
        self.pack_file_id.unwrap_or(0)
    }

    pub fn clear_pack_file_id(&mut self) {
        self.pack_file_id = ::std::option::Option::None;
    }

    pub fn has_pack_file_id(&self) -> bool {
        self.pack_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pack_file_id(&mut self, v: i32) {
        self.pack_file_id = ::std::option::Option::Some(v);
    }

    // optional int32 pack_file_number = 11;

    pub fn pack_file_number(&self) -> i32 {
        self.pack_file_number.unwrap_or(0)
    }

    pub fn clear_pack_file_number(&mut self) {
        self.pack_file_number = ::std::option::Option::None;
    }

    pub fn has_pack_file_number(&self) -> bool {
        self.pack_file_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pack_file_number(&mut self, v: i32) {
        self.pack_file_number = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "code_path",
            |m: &CCLCMsg_FileCRCCheck| { &m.code_path },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.code_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &CCLCMsg_FileCRCCheck| { &m.path },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "code_filename",
            |m: &CCLCMsg_FileCRCCheck| { &m.code_filename },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.code_filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filename",
            |m: &CCLCMsg_FileCRCCheck| { &m.filename },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.filename },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_fraction",
            |m: &CCLCMsg_FileCRCCheck| { &m.file_fraction },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.file_fraction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "md5",
            |m: &CCLCMsg_FileCRCCheck| { &m.md5 },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.md5 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crc",
            |m: &CCLCMsg_FileCRCCheck| { &m.crc },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_hash_type",
            |m: &CCLCMsg_FileCRCCheck| { &m.file_hash_type },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.file_hash_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file_len",
            |m: &CCLCMsg_FileCRCCheck| { &m.file_len },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.file_len },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pack_file_id",
            |m: &CCLCMsg_FileCRCCheck| { &m.pack_file_id },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.pack_file_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pack_file_number",
            |m: &CCLCMsg_FileCRCCheck| { &m.pack_file_number },
            |m: &mut CCLCMsg_FileCRCCheck| { &mut m.pack_file_number },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_FileCRCCheck>(
            "CCLCMsg_FileCRCCheck",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_FileCRCCheck {
    const NAME: &'static str = "CCLCMsg_FileCRCCheck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.code_path = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.path = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                24 => {
                    self.code_filename = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.filename = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                40 => {
                    self.file_fraction = ::std::option::Option::Some(is.read_int32()?);
                },
                50 => {
                    self.md5 = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                56 => {
                    self.crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.file_hash_type = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.file_len = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.pack_file_id = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.pack_file_number = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.code_path {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.code_filename {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.file_fraction {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.md5.as_ref() {
            my_size += ::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.crc {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.file_hash_type {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.file_len {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.pack_file_id {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.pack_file_number {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.code_path {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.code_filename {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.file_fraction {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.md5.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.crc {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.file_hash_type {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.file_len {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.pack_file_id {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.pack_file_number {
            os.write_int32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_FileCRCCheck {
        CCLCMsg_FileCRCCheck::new()
    }

    fn clear(&mut self) {
        self.code_path = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.code_filename = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.file_fraction = ::std::option::Option::None;
        self.md5 = ::std::option::Option::None;
        self.crc = ::std::option::Option::None;
        self.file_hash_type = ::std::option::Option::None;
        self.file_len = ::std::option::Option::None;
        self.pack_file_id = ::std::option::Option::None;
        self.pack_file_number = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_FileCRCCheck {
        static instance: CCLCMsg_FileCRCCheck = CCLCMsg_FileCRCCheck {
            code_path: ::std::option::Option::None,
            path: ::std::option::Option::None,
            code_filename: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            file_fraction: ::std::option::Option::None,
            md5: ::std::option::Option::None,
            crc: ::std::option::Option::None,
            file_hash_type: ::std::option::Option::None,
            file_len: ::std::option::Option::None,
            pack_file_id: ::std::option::Option::None,
            pack_file_number: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_FileCRCCheck {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_FileCRCCheck").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_FileCRCCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_FileCRCCheck {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CCLCMsg_LoadingProgress)
pub struct CCLCMsg_LoadingProgress {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_LoadingProgress.progress)
    pub progress: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_LoadingProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_LoadingProgress {
    fn default() -> &'a CCLCMsg_LoadingProgress {
        <CCLCMsg_LoadingProgress as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_LoadingProgress {
    pub fn new() -> CCLCMsg_LoadingProgress {
        ::std::default::Default::default()
    }

    // optional int32 progress = 1;

    pub fn progress(&self) -> i32 {
        self.progress.unwrap_or(0)
    }

    pub fn clear_progress(&mut self) {
        self.progress = ::std::option::Option::None;
    }

    pub fn has_progress(&self) -> bool {
        self.progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress(&mut self, v: i32) {
        self.progress = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "progress",
            |m: &CCLCMsg_LoadingProgress| { &m.progress },
            |m: &mut CCLCMsg_LoadingProgress| { &mut m.progress },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_LoadingProgress>(
            "CCLCMsg_LoadingProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_LoadingProgress {
    const NAME: &'static str = "CCLCMsg_LoadingProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.progress = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.progress {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.progress {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_LoadingProgress {
        CCLCMsg_LoadingProgress::new()
    }

    fn clear(&mut self) {
        self.progress = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_LoadingProgress {
        static instance: CCLCMsg_LoadingProgress = CCLCMsg_LoadingProgress {
            progress: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_LoadingProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_LoadingProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_LoadingProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_LoadingProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CCLCMsg_SplitPlayerConnect)
pub struct CCLCMsg_SplitPlayerConnect {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_SplitPlayerConnect.convars)
    pub convars: ::protobuf::MessageField<CMsg_CVars>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_SplitPlayerConnect.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_SplitPlayerConnect {
    fn default() -> &'a CCLCMsg_SplitPlayerConnect {
        <CCLCMsg_SplitPlayerConnect as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_SplitPlayerConnect {
    pub fn new() -> CCLCMsg_SplitPlayerConnect {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsg_CVars>(
            "convars",
            |m: &CCLCMsg_SplitPlayerConnect| { &m.convars },
            |m: &mut CCLCMsg_SplitPlayerConnect| { &mut m.convars },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_SplitPlayerConnect>(
            "CCLCMsg_SplitPlayerConnect",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_SplitPlayerConnect {
    const NAME: &'static str = "CCLCMsg_SplitPlayerConnect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.convars)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.convars.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.convars.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_SplitPlayerConnect {
        CCLCMsg_SplitPlayerConnect::new()
    }

    fn clear(&mut self) {
        self.convars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_SplitPlayerConnect {
        static instance: CCLCMsg_SplitPlayerConnect = CCLCMsg_SplitPlayerConnect {
            convars: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_SplitPlayerConnect {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_SplitPlayerConnect").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_SplitPlayerConnect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_SplitPlayerConnect {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CCLCMsg_CmdKeyValues)
pub struct CCLCMsg_CmdKeyValues {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_CmdKeyValues.keyvalues)
    pub keyvalues: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_CmdKeyValues.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_CmdKeyValues {
    fn default() -> &'a CCLCMsg_CmdKeyValues {
        <CCLCMsg_CmdKeyValues as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_CmdKeyValues {
    pub fn new() -> CCLCMsg_CmdKeyValues {
        ::std::default::Default::default()
    }

    // optional bytes keyvalues = 1;

    pub fn keyvalues(&self) -> &[u8] {
        match self.keyvalues.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_keyvalues(&mut self) {
        self.keyvalues = ::std::option::Option::None;
    }

    pub fn has_keyvalues(&self) -> bool {
        self.keyvalues.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyvalues(&mut self, v: ::bytes::Bytes) {
        self.keyvalues = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyvalues(&mut self) -> &mut ::bytes::Bytes {
        if self.keyvalues.is_none() {
            self.keyvalues = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.keyvalues.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyvalues(&mut self) -> ::bytes::Bytes {
        self.keyvalues.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyvalues",
            |m: &CCLCMsg_CmdKeyValues| { &m.keyvalues },
            |m: &mut CCLCMsg_CmdKeyValues| { &mut m.keyvalues },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_CmdKeyValues>(
            "CCLCMsg_CmdKeyValues",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_CmdKeyValues {
    const NAME: &'static str = "CCLCMsg_CmdKeyValues";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.keyvalues = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.keyvalues.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.keyvalues.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_CmdKeyValues {
        CCLCMsg_CmdKeyValues::new()
    }

    fn clear(&mut self) {
        self.keyvalues = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_CmdKeyValues {
        static instance: CCLCMsg_CmdKeyValues = CCLCMsg_CmdKeyValues {
            keyvalues: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_CmdKeyValues {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_CmdKeyValues").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_CmdKeyValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_CmdKeyValues {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_ServerInfo)
pub struct CSVCMsg_ServerInfo {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.protocol)
    pub protocol: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.server_count)
    pub server_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.is_dedicated)
    pub is_dedicated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.is_official_valve_server)
    pub is_official_valve_server: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.is_hltv)
    pub is_hltv: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.is_replay)
    pub is_replay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.is_redirecting_to_proxy_relay)
    pub is_redirecting_to_proxy_relay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.c_os)
    pub c_os: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.map_crc)
    pub map_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.client_crc)
    pub client_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.string_table_crc)
    pub string_table_crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.max_clients)
    pub max_clients: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.max_classes)
    pub max_classes: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.player_slot)
    pub player_slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.tick_interval)
    pub tick_interval: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.game_dir)
    pub game_dir: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.map_name)
    pub map_name: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.map_group_name)
    pub map_group_name: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.sky_name)
    pub sky_name: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.host_name)
    pub host_name: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.public_ip)
    pub public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_ServerInfo.ugc_map_id)
    pub ugc_map_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_ServerInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_ServerInfo {
    fn default() -> &'a CSVCMsg_ServerInfo {
        <CSVCMsg_ServerInfo as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_ServerInfo {
    pub fn new() -> CSVCMsg_ServerInfo {
        ::std::default::Default::default()
    }

    // optional int32 protocol = 1;

    pub fn protocol(&self) -> i32 {
        self.protocol.unwrap_or(0)
    }

    pub fn clear_protocol(&mut self) {
        self.protocol = ::std::option::Option::None;
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: i32) {
        self.protocol = ::std::option::Option::Some(v);
    }

    // optional int32 server_count = 2;

    pub fn server_count(&self) -> i32 {
        self.server_count.unwrap_or(0)
    }

    pub fn clear_server_count(&mut self) {
        self.server_count = ::std::option::Option::None;
    }

    pub fn has_server_count(&self) -> bool {
        self.server_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_count(&mut self, v: i32) {
        self.server_count = ::std::option::Option::Some(v);
    }

    // optional bool is_dedicated = 3;

    pub fn is_dedicated(&self) -> bool {
        self.is_dedicated.unwrap_or(false)
    }

    pub fn clear_is_dedicated(&mut self) {
        self.is_dedicated = ::std::option::Option::None;
    }

    pub fn has_is_dedicated(&self) -> bool {
        self.is_dedicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_dedicated(&mut self, v: bool) {
        self.is_dedicated = ::std::option::Option::Some(v);
    }

    // optional bool is_official_valve_server = 4;

    pub fn is_official_valve_server(&self) -> bool {
        self.is_official_valve_server.unwrap_or(false)
    }

    pub fn clear_is_official_valve_server(&mut self) {
        self.is_official_valve_server = ::std::option::Option::None;
    }

    pub fn has_is_official_valve_server(&self) -> bool {
        self.is_official_valve_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_official_valve_server(&mut self, v: bool) {
        self.is_official_valve_server = ::std::option::Option::Some(v);
    }

    // optional bool is_hltv = 5;

    pub fn is_hltv(&self) -> bool {
        self.is_hltv.unwrap_or(false)
    }

    pub fn clear_is_hltv(&mut self) {
        self.is_hltv = ::std::option::Option::None;
    }

    pub fn has_is_hltv(&self) -> bool {
        self.is_hltv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_hltv(&mut self, v: bool) {
        self.is_hltv = ::std::option::Option::Some(v);
    }

    // optional bool is_replay = 6;

    pub fn is_replay(&self) -> bool {
        self.is_replay.unwrap_or(false)
    }

    pub fn clear_is_replay(&mut self) {
        self.is_replay = ::std::option::Option::None;
    }

    pub fn has_is_replay(&self) -> bool {
        self.is_replay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_replay(&mut self, v: bool) {
        self.is_replay = ::std::option::Option::Some(v);
    }

    // optional bool is_redirecting_to_proxy_relay = 21;

    pub fn is_redirecting_to_proxy_relay(&self) -> bool {
        self.is_redirecting_to_proxy_relay.unwrap_or(false)
    }

    pub fn clear_is_redirecting_to_proxy_relay(&mut self) {
        self.is_redirecting_to_proxy_relay = ::std::option::Option::None;
    }

    pub fn has_is_redirecting_to_proxy_relay(&self) -> bool {
        self.is_redirecting_to_proxy_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_redirecting_to_proxy_relay(&mut self, v: bool) {
        self.is_redirecting_to_proxy_relay = ::std::option::Option::Some(v);
    }

    // optional int32 c_os = 7;

    pub fn c_os(&self) -> i32 {
        self.c_os.unwrap_or(0)
    }

    pub fn clear_c_os(&mut self) {
        self.c_os = ::std::option::Option::None;
    }

    pub fn has_c_os(&self) -> bool {
        self.c_os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_c_os(&mut self, v: i32) {
        self.c_os = ::std::option::Option::Some(v);
    }

    // optional fixed32 map_crc = 8;

    pub fn map_crc(&self) -> u32 {
        self.map_crc.unwrap_or(0)
    }

    pub fn clear_map_crc(&mut self) {
        self.map_crc = ::std::option::Option::None;
    }

    pub fn has_map_crc(&self) -> bool {
        self.map_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_crc(&mut self, v: u32) {
        self.map_crc = ::std::option::Option::Some(v);
    }

    // optional fixed32 client_crc = 9;

    pub fn client_crc(&self) -> u32 {
        self.client_crc.unwrap_or(0)
    }

    pub fn clear_client_crc(&mut self) {
        self.client_crc = ::std::option::Option::None;
    }

    pub fn has_client_crc(&self) -> bool {
        self.client_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_crc(&mut self, v: u32) {
        self.client_crc = ::std::option::Option::Some(v);
    }

    // optional fixed32 string_table_crc = 10;

    pub fn string_table_crc(&self) -> u32 {
        self.string_table_crc.unwrap_or(0)
    }

    pub fn clear_string_table_crc(&mut self) {
        self.string_table_crc = ::std::option::Option::None;
    }

    pub fn has_string_table_crc(&self) -> bool {
        self.string_table_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_table_crc(&mut self, v: u32) {
        self.string_table_crc = ::std::option::Option::Some(v);
    }

    // optional int32 max_clients = 11;

    pub fn max_clients(&self) -> i32 {
        self.max_clients.unwrap_or(0)
    }

    pub fn clear_max_clients(&mut self) {
        self.max_clients = ::std::option::Option::None;
    }

    pub fn has_max_clients(&self) -> bool {
        self.max_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_clients(&mut self, v: i32) {
        self.max_clients = ::std::option::Option::Some(v);
    }

    // optional int32 max_classes = 12;

    pub fn max_classes(&self) -> i32 {
        self.max_classes.unwrap_or(0)
    }

    pub fn clear_max_classes(&mut self) {
        self.max_classes = ::std::option::Option::None;
    }

    pub fn has_max_classes(&self) -> bool {
        self.max_classes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_classes(&mut self, v: i32) {
        self.max_classes = ::std::option::Option::Some(v);
    }

    // optional int32 player_slot = 13;

    pub fn player_slot(&self) -> i32 {
        self.player_slot.unwrap_or(0)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: i32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    // optional float tick_interval = 14;

    pub fn tick_interval(&self) -> f32 {
        self.tick_interval.unwrap_or(0.)
    }

    pub fn clear_tick_interval(&mut self) {
        self.tick_interval = ::std::option::Option::None;
    }

    pub fn has_tick_interval(&self) -> bool {
        self.tick_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick_interval(&mut self, v: f32) {
        self.tick_interval = ::std::option::Option::Some(v);
    }

    // optional string game_dir = 15;

    pub fn game_dir(&self) -> &str {
        match self.game_dir.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_dir(&mut self) {
        self.game_dir = ::std::option::Option::None;
    }

    pub fn has_game_dir(&self) -> bool {
        self.game_dir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_dir(&mut self, v: ::protobuf::Chars) {
        self.game_dir = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_dir(&mut self) -> &mut ::protobuf::Chars {
        if self.game_dir.is_none() {
            self.game_dir = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.game_dir.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_dir(&mut self) -> ::protobuf::Chars {
        self.game_dir.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional string map_name = 16;

    pub fn map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_name(&mut self) {
        self.map_name = ::std::option::Option::None;
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::protobuf::Chars) {
        self.map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::protobuf::Chars {
        if self.map_name.is_none() {
            self.map_name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::protobuf::Chars {
        self.map_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional string map_group_name = 17;

    pub fn map_group_name(&self) -> &str {
        match self.map_group_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_group_name(&mut self) {
        self.map_group_name = ::std::option::Option::None;
    }

    pub fn has_map_group_name(&self) -> bool {
        self.map_group_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_group_name(&mut self, v: ::protobuf::Chars) {
        self.map_group_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_group_name(&mut self) -> &mut ::protobuf::Chars {
        if self.map_group_name.is_none() {
            self.map_group_name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.map_group_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_group_name(&mut self) -> ::protobuf::Chars {
        self.map_group_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional string sky_name = 18;

    pub fn sky_name(&self) -> &str {
        match self.sky_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sky_name(&mut self) {
        self.sky_name = ::std::option::Option::None;
    }

    pub fn has_sky_name(&self) -> bool {
        self.sky_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sky_name(&mut self, v: ::protobuf::Chars) {
        self.sky_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sky_name(&mut self) -> &mut ::protobuf::Chars {
        if self.sky_name.is_none() {
            self.sky_name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.sky_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sky_name(&mut self) -> ::protobuf::Chars {
        self.sky_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional string host_name = 19;

    pub fn host_name(&self) -> &str {
        match self.host_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_host_name(&mut self) {
        self.host_name = ::std::option::Option::None;
    }

    pub fn has_host_name(&self) -> bool {
        self.host_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_name(&mut self, v: ::protobuf::Chars) {
        self.host_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_name(&mut self) -> &mut ::protobuf::Chars {
        if self.host_name.is_none() {
            self.host_name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.host_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_name(&mut self) -> ::protobuf::Chars {
        self.host_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional uint32 public_ip = 20;

    pub fn public_ip(&self) -> u32 {
        self.public_ip.unwrap_or(0)
    }

    pub fn clear_public_ip(&mut self) {
        self.public_ip = ::std::option::Option::None;
    }

    pub fn has_public_ip(&self) -> bool {
        self.public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip(&mut self, v: u32) {
        self.public_ip = ::std::option::Option::Some(v);
    }

    // optional uint64 ugc_map_id = 22;

    pub fn ugc_map_id(&self) -> u64 {
        self.ugc_map_id.unwrap_or(0)
    }

    pub fn clear_ugc_map_id(&mut self) {
        self.ugc_map_id = ::std::option::Option::None;
    }

    pub fn has_ugc_map_id(&self) -> bool {
        self.ugc_map_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ugc_map_id(&mut self, v: u64) {
        self.ugc_map_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(22);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "protocol",
            |m: &CSVCMsg_ServerInfo| { &m.protocol },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.protocol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_count",
            |m: &CSVCMsg_ServerInfo| { &m.server_count },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.server_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_dedicated",
            |m: &CSVCMsg_ServerInfo| { &m.is_dedicated },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.is_dedicated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_official_valve_server",
            |m: &CSVCMsg_ServerInfo| { &m.is_official_valve_server },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.is_official_valve_server },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_hltv",
            |m: &CSVCMsg_ServerInfo| { &m.is_hltv },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.is_hltv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_replay",
            |m: &CSVCMsg_ServerInfo| { &m.is_replay },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.is_replay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_redirecting_to_proxy_relay",
            |m: &CSVCMsg_ServerInfo| { &m.is_redirecting_to_proxy_relay },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.is_redirecting_to_proxy_relay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "c_os",
            |m: &CSVCMsg_ServerInfo| { &m.c_os },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.c_os },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_crc",
            |m: &CSVCMsg_ServerInfo| { &m.map_crc },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.map_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_crc",
            |m: &CSVCMsg_ServerInfo| { &m.client_crc },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.client_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_table_crc",
            |m: &CSVCMsg_ServerInfo| { &m.string_table_crc },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.string_table_crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_clients",
            |m: &CSVCMsg_ServerInfo| { &m.max_clients },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.max_clients },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_classes",
            |m: &CSVCMsg_ServerInfo| { &m.max_classes },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.max_classes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_slot",
            |m: &CSVCMsg_ServerInfo| { &m.player_slot },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.player_slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick_interval",
            |m: &CSVCMsg_ServerInfo| { &m.tick_interval },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.tick_interval },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_dir",
            |m: &CSVCMsg_ServerInfo| { &m.game_dir },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.game_dir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_name",
            |m: &CSVCMsg_ServerInfo| { &m.map_name },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.map_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_group_name",
            |m: &CSVCMsg_ServerInfo| { &m.map_group_name },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.map_group_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sky_name",
            |m: &CSVCMsg_ServerInfo| { &m.sky_name },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.sky_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "host_name",
            |m: &CSVCMsg_ServerInfo| { &m.host_name },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.host_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "public_ip",
            |m: &CSVCMsg_ServerInfo| { &m.public_ip },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.public_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ugc_map_id",
            |m: &CSVCMsg_ServerInfo| { &m.ugc_map_id },
            |m: &mut CSVCMsg_ServerInfo| { &mut m.ugc_map_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_ServerInfo>(
            "CSVCMsg_ServerInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_ServerInfo {
    const NAME: &'static str = "CSVCMsg_ServerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.protocol = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.server_count = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.is_dedicated = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.is_official_valve_server = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.is_hltv = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.is_replay = ::std::option::Option::Some(is.read_bool()?);
                },
                168 => {
                    self.is_redirecting_to_proxy_relay = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.c_os = ::std::option::Option::Some(is.read_int32()?);
                },
                69 => {
                    self.map_crc = ::std::option::Option::Some(is.read_fixed32()?);
                },
                77 => {
                    self.client_crc = ::std::option::Option::Some(is.read_fixed32()?);
                },
                85 => {
                    self.string_table_crc = ::std::option::Option::Some(is.read_fixed32()?);
                },
                88 => {
                    self.max_clients = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.max_classes = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.player_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                117 => {
                    self.tick_interval = ::std::option::Option::Some(is.read_float()?);
                },
                122 => {
                    self.game_dir = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                130 => {
                    self.map_name = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                138 => {
                    self.map_group_name = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                146 => {
                    self.sky_name = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                154 => {
                    self.host_name = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                160 => {
                    self.public_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.ugc_map_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.protocol {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.server_count {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.is_dedicated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_official_valve_server {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_hltv {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_replay {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_redirecting_to_proxy_relay {
            my_size += 2 + 1;
        }
        if let Some(v) = self.c_os {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.map_crc {
            my_size += 1 + 4;
        }
        if let Some(v) = self.client_crc {
            my_size += 1 + 4;
        }
        if let Some(v) = self.string_table_crc {
            my_size += 1 + 4;
        }
        if let Some(v) = self.max_clients {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.max_classes {
            my_size += ::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.player_slot {
            my_size += ::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.tick_interval {
            my_size += 1 + 4;
        }
        if let Some(v) = self.game_dir.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.map_name.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.map_group_name.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.sky_name.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.host_name.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        if let Some(v) = self.public_ip {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.ugc_map_id {
            my_size += ::protobuf::rt::uint64_size(22, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.protocol {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.server_count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.is_dedicated {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.is_official_valve_server {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.is_hltv {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.is_replay {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.is_redirecting_to_proxy_relay {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.c_os {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.map_crc {
            os.write_fixed32(8, v)?;
        }
        if let Some(v) = self.client_crc {
            os.write_fixed32(9, v)?;
        }
        if let Some(v) = self.string_table_crc {
            os.write_fixed32(10, v)?;
        }
        if let Some(v) = self.max_clients {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.max_classes {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.player_slot {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.tick_interval {
            os.write_float(14, v)?;
        }
        if let Some(v) = self.game_dir.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.map_name.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.map_group_name.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.sky_name.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.host_name.as_ref() {
            os.write_string(19, v)?;
        }
        if let Some(v) = self.public_ip {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.ugc_map_id {
            os.write_uint64(22, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_ServerInfo {
        CSVCMsg_ServerInfo::new()
    }

    fn clear(&mut self) {
        self.protocol = ::std::option::Option::None;
        self.server_count = ::std::option::Option::None;
        self.is_dedicated = ::std::option::Option::None;
        self.is_official_valve_server = ::std::option::Option::None;
        self.is_hltv = ::std::option::Option::None;
        self.is_replay = ::std::option::Option::None;
        self.is_redirecting_to_proxy_relay = ::std::option::Option::None;
        self.c_os = ::std::option::Option::None;
        self.map_crc = ::std::option::Option::None;
        self.client_crc = ::std::option::Option::None;
        self.string_table_crc = ::std::option::Option::None;
        self.max_clients = ::std::option::Option::None;
        self.max_classes = ::std::option::Option::None;
        self.player_slot = ::std::option::Option::None;
        self.tick_interval = ::std::option::Option::None;
        self.game_dir = ::std::option::Option::None;
        self.map_name = ::std::option::Option::None;
        self.map_group_name = ::std::option::Option::None;
        self.sky_name = ::std::option::Option::None;
        self.host_name = ::std::option::Option::None;
        self.public_ip = ::std::option::Option::None;
        self.ugc_map_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_ServerInfo {
        static instance: CSVCMsg_ServerInfo = CSVCMsg_ServerInfo {
            protocol: ::std::option::Option::None,
            server_count: ::std::option::Option::None,
            is_dedicated: ::std::option::Option::None,
            is_official_valve_server: ::std::option::Option::None,
            is_hltv: ::std::option::Option::None,
            is_replay: ::std::option::Option::None,
            is_redirecting_to_proxy_relay: ::std::option::Option::None,
            c_os: ::std::option::Option::None,
            map_crc: ::std::option::Option::None,
            client_crc: ::std::option::Option::None,
            string_table_crc: ::std::option::Option::None,
            max_clients: ::std::option::Option::None,
            max_classes: ::std::option::Option::None,
            player_slot: ::std::option::Option::None,
            tick_interval: ::std::option::Option::None,
            game_dir: ::std::option::Option::None,
            map_name: ::std::option::Option::None,
            map_group_name: ::std::option::Option::None,
            sky_name: ::std::option::Option::None,
            host_name: ::std::option::Option::None,
            public_ip: ::std::option::Option::None,
            ugc_map_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_ServerInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_ServerInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_ServerInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_ServerInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_ClassInfo)
pub struct CSVCMsg_ClassInfo {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_ClassInfo.create_on_client)
    pub create_on_client: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_ClassInfo.classes)
    pub classes: ::std::vec::Vec<csvcmsg_class_info::Class_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_ClassInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_ClassInfo {
    fn default() -> &'a CSVCMsg_ClassInfo {
        <CSVCMsg_ClassInfo as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_ClassInfo {
    pub fn new() -> CSVCMsg_ClassInfo {
        ::std::default::Default::default()
    }

    // optional bool create_on_client = 1;

    pub fn create_on_client(&self) -> bool {
        self.create_on_client.unwrap_or(false)
    }

    pub fn clear_create_on_client(&mut self) {
        self.create_on_client = ::std::option::Option::None;
    }

    pub fn has_create_on_client(&self) -> bool {
        self.create_on_client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_on_client(&mut self, v: bool) {
        self.create_on_client = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "create_on_client",
            |m: &CSVCMsg_ClassInfo| { &m.create_on_client },
            |m: &mut CSVCMsg_ClassInfo| { &mut m.create_on_client },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "classes",
            |m: &CSVCMsg_ClassInfo| { &m.classes },
            |m: &mut CSVCMsg_ClassInfo| { &mut m.classes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_ClassInfo>(
            "CSVCMsg_ClassInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_ClassInfo {
    const NAME: &'static str = "CSVCMsg_ClassInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.create_on_client = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.classes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.create_on_client {
            my_size += 1 + 1;
        }
        for value in &self.classes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.create_on_client {
            os.write_bool(1, v)?;
        }
        for v in &self.classes {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_ClassInfo {
        CSVCMsg_ClassInfo::new()
    }

    fn clear(&mut self) {
        self.create_on_client = ::std::option::Option::None;
        self.classes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_ClassInfo {
        static instance: CSVCMsg_ClassInfo = CSVCMsg_ClassInfo {
            create_on_client: ::std::option::Option::None,
            classes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_ClassInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_ClassInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_ClassInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_ClassInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSVCMsg_ClassInfo`
pub mod csvcmsg_class_info {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CSVCMsg_ClassInfo.class_t)
    pub struct Class_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_ClassInfo.class_t.class_id)
        pub class_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_ClassInfo.class_t.data_table_name)
        pub data_table_name: ::std::option::Option<::protobuf::Chars>,
        // @@protoc_insertion_point(field:CSVCMsg_ClassInfo.class_t.class_name)
        pub class_name: ::std::option::Option<::protobuf::Chars>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_ClassInfo.class_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Class_t {
        fn default() -> &'a Class_t {
            <Class_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Class_t {
        pub fn new() -> Class_t {
            ::std::default::Default::default()
        }

        // optional int32 class_id = 1;

        pub fn class_id(&self) -> i32 {
            self.class_id.unwrap_or(0)
        }

        pub fn clear_class_id(&mut self) {
            self.class_id = ::std::option::Option::None;
        }

        pub fn has_class_id(&self) -> bool {
            self.class_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_class_id(&mut self, v: i32) {
            self.class_id = ::std::option::Option::Some(v);
        }

        // optional string data_table_name = 2;

        pub fn data_table_name(&self) -> &str {
            match self.data_table_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_data_table_name(&mut self) {
            self.data_table_name = ::std::option::Option::None;
        }

        pub fn has_data_table_name(&self) -> bool {
            self.data_table_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data_table_name(&mut self, v: ::protobuf::Chars) {
            self.data_table_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_data_table_name(&mut self) -> &mut ::protobuf::Chars {
            if self.data_table_name.is_none() {
                self.data_table_name = ::std::option::Option::Some(::protobuf::Chars::new());
            }
            self.data_table_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_data_table_name(&mut self) -> ::protobuf::Chars {
            self.data_table_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
        }

        // optional string class_name = 3;

        pub fn class_name(&self) -> &str {
            match self.class_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_class_name(&mut self) {
            self.class_name = ::std::option::Option::None;
        }

        pub fn has_class_name(&self) -> bool {
            self.class_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_class_name(&mut self, v: ::protobuf::Chars) {
            self.class_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_class_name(&mut self) -> &mut ::protobuf::Chars {
            if self.class_name.is_none() {
                self.class_name = ::std::option::Option::Some(::protobuf::Chars::new());
            }
            self.class_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_class_name(&mut self) -> ::protobuf::Chars {
            self.class_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "class_id",
                |m: &Class_t| { &m.class_id },
                |m: &mut Class_t| { &mut m.class_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "data_table_name",
                |m: &Class_t| { &m.data_table_name },
                |m: &mut Class_t| { &mut m.data_table_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "class_name",
                |m: &Class_t| { &m.class_name },
                |m: &mut Class_t| { &mut m.class_name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Class_t>(
                "CSVCMsg_ClassInfo.class_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Class_t {
        const NAME: &'static str = "class_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.class_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.data_table_name = ::std::option::Option::Some(is.read_tokio_chars()?);
                    },
                    26 => {
                        self.class_name = ::std::option::Option::Some(is.read_tokio_chars()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.class_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.data_table_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.class_name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.class_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.data_table_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.class_name.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Class_t {
            Class_t::new()
        }

        fn clear(&mut self) {
            self.class_id = ::std::option::Option::None;
            self.data_table_name = ::std::option::Option::None;
            self.class_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Class_t {
            static instance: Class_t = Class_t {
                class_id: ::std::option::Option::None,
                data_table_name: ::std::option::Option::None,
                class_name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Class_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_ClassInfo.class_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Class_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Class_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_SendTable)
pub struct CSVCMsg_SendTable {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_SendTable.is_end)
    pub is_end: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_SendTable.net_table_name)
    pub net_table_name: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CSVCMsg_SendTable.needs_decoder)
    pub needs_decoder: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_SendTable.props)
    pub props: ::std::vec::Vec<csvcmsg_send_table::Sendprop_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_SendTable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_SendTable {
    fn default() -> &'a CSVCMsg_SendTable {
        <CSVCMsg_SendTable as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_SendTable {
    pub fn new() -> CSVCMsg_SendTable {
        ::std::default::Default::default()
    }

    // optional bool is_end = 1;

    pub fn is_end(&self) -> bool {
        self.is_end.unwrap_or(false)
    }

    pub fn clear_is_end(&mut self) {
        self.is_end = ::std::option::Option::None;
    }

    pub fn has_is_end(&self) -> bool {
        self.is_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_end(&mut self, v: bool) {
        self.is_end = ::std::option::Option::Some(v);
    }

    // optional string net_table_name = 2;

    pub fn net_table_name(&self) -> &str {
        match self.net_table_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_net_table_name(&mut self) {
        self.net_table_name = ::std::option::Option::None;
    }

    pub fn has_net_table_name(&self) -> bool {
        self.net_table_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_table_name(&mut self, v: ::protobuf::Chars) {
        self.net_table_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_table_name(&mut self) -> &mut ::protobuf::Chars {
        if self.net_table_name.is_none() {
            self.net_table_name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.net_table_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_table_name(&mut self) -> ::protobuf::Chars {
        self.net_table_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional bool needs_decoder = 3;

    pub fn needs_decoder(&self) -> bool {
        self.needs_decoder.unwrap_or(false)
    }

    pub fn clear_needs_decoder(&mut self) {
        self.needs_decoder = ::std::option::Option::None;
    }

    pub fn has_needs_decoder(&self) -> bool {
        self.needs_decoder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_decoder(&mut self, v: bool) {
        self.needs_decoder = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_end",
            |m: &CSVCMsg_SendTable| { &m.is_end },
            |m: &mut CSVCMsg_SendTable| { &mut m.is_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "net_table_name",
            |m: &CSVCMsg_SendTable| { &m.net_table_name },
            |m: &mut CSVCMsg_SendTable| { &mut m.net_table_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "needs_decoder",
            |m: &CSVCMsg_SendTable| { &m.needs_decoder },
            |m: &mut CSVCMsg_SendTable| { &mut m.needs_decoder },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "props",
            |m: &CSVCMsg_SendTable| { &m.props },
            |m: &mut CSVCMsg_SendTable| { &mut m.props },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_SendTable>(
            "CSVCMsg_SendTable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_SendTable {
    const NAME: &'static str = "CSVCMsg_SendTable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_end = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.net_table_name = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                24 => {
                    self.needs_decoder = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.props.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_end {
            my_size += 1 + 1;
        }
        if let Some(v) = self.net_table_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.needs_decoder {
            my_size += 1 + 1;
        }
        for value in &self.props {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.is_end {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.net_table_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.needs_decoder {
            os.write_bool(3, v)?;
        }
        for v in &self.props {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_SendTable {
        CSVCMsg_SendTable::new()
    }

    fn clear(&mut self) {
        self.is_end = ::std::option::Option::None;
        self.net_table_name = ::std::option::Option::None;
        self.needs_decoder = ::std::option::Option::None;
        self.props.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_SendTable {
        static instance: CSVCMsg_SendTable = CSVCMsg_SendTable {
            is_end: ::std::option::Option::None,
            net_table_name: ::std::option::Option::None,
            needs_decoder: ::std::option::Option::None,
            props: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_SendTable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_SendTable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_SendTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_SendTable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSVCMsg_SendTable`
pub mod csvcmsg_send_table {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CSVCMsg_SendTable.sendprop_t)
    pub struct Sendprop_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.var_name)
        pub var_name: ::std::option::Option<::protobuf::Chars>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.flags)
        pub flags: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.priority)
        pub priority: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.dt_name)
        pub dt_name: ::std::option::Option<::protobuf::Chars>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.num_elements)
        pub num_elements: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.low_value)
        pub low_value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.high_value)
        pub high_value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CSVCMsg_SendTable.sendprop_t.num_bits)
        pub num_bits: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_SendTable.sendprop_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Sendprop_t {
        fn default() -> &'a Sendprop_t {
            <Sendprop_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Sendprop_t {
        pub fn new() -> Sendprop_t {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional string var_name = 2;

        pub fn var_name(&self) -> &str {
            match self.var_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_var_name(&mut self) {
            self.var_name = ::std::option::Option::None;
        }

        pub fn has_var_name(&self) -> bool {
            self.var_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_var_name(&mut self, v: ::protobuf::Chars) {
            self.var_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_var_name(&mut self) -> &mut ::protobuf::Chars {
            if self.var_name.is_none() {
                self.var_name = ::std::option::Option::Some(::protobuf::Chars::new());
            }
            self.var_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_var_name(&mut self) -> ::protobuf::Chars {
            self.var_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
        }

        // optional int32 flags = 3;

        pub fn flags(&self) -> i32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: i32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional int32 priority = 4;

        pub fn priority(&self) -> i32 {
            self.priority.unwrap_or(0)
        }

        pub fn clear_priority(&mut self) {
            self.priority = ::std::option::Option::None;
        }

        pub fn has_priority(&self) -> bool {
            self.priority.is_some()
        }

        // Param is passed by value, moved
        pub fn set_priority(&mut self, v: i32) {
            self.priority = ::std::option::Option::Some(v);
        }

        // optional string dt_name = 5;

        pub fn dt_name(&self) -> &str {
            match self.dt_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_dt_name(&mut self) {
            self.dt_name = ::std::option::Option::None;
        }

        pub fn has_dt_name(&self) -> bool {
            self.dt_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_dt_name(&mut self, v: ::protobuf::Chars) {
            self.dt_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_dt_name(&mut self) -> &mut ::protobuf::Chars {
            if self.dt_name.is_none() {
                self.dt_name = ::std::option::Option::Some(::protobuf::Chars::new());
            }
            self.dt_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_dt_name(&mut self) -> ::protobuf::Chars {
            self.dt_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
        }

        // optional int32 num_elements = 6;

        pub fn num_elements(&self) -> i32 {
            self.num_elements.unwrap_or(0)
        }

        pub fn clear_num_elements(&mut self) {
            self.num_elements = ::std::option::Option::None;
        }

        pub fn has_num_elements(&self) -> bool {
            self.num_elements.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_elements(&mut self, v: i32) {
            self.num_elements = ::std::option::Option::Some(v);
        }

        // optional float low_value = 7;

        pub fn low_value(&self) -> f32 {
            self.low_value.unwrap_or(0.)
        }

        pub fn clear_low_value(&mut self) {
            self.low_value = ::std::option::Option::None;
        }

        pub fn has_low_value(&self) -> bool {
            self.low_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_low_value(&mut self, v: f32) {
            self.low_value = ::std::option::Option::Some(v);
        }

        // optional float high_value = 8;

        pub fn high_value(&self) -> f32 {
            self.high_value.unwrap_or(0.)
        }

        pub fn clear_high_value(&mut self) {
            self.high_value = ::std::option::Option::None;
        }

        pub fn has_high_value(&self) -> bool {
            self.high_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_high_value(&mut self, v: f32) {
            self.high_value = ::std::option::Option::Some(v);
        }

        // optional int32 num_bits = 9;

        pub fn num_bits(&self) -> i32 {
            self.num_bits.unwrap_or(0)
        }

        pub fn clear_num_bits(&mut self) {
            self.num_bits = ::std::option::Option::None;
        }

        pub fn has_num_bits(&self) -> bool {
            self.num_bits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_bits(&mut self, v: i32) {
            self.num_bits = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Sendprop_t| { &m.type_ },
                |m: &mut Sendprop_t| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "var_name",
                |m: &Sendprop_t| { &m.var_name },
                |m: &mut Sendprop_t| { &mut m.var_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "flags",
                |m: &Sendprop_t| { &m.flags },
                |m: &mut Sendprop_t| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "priority",
                |m: &Sendprop_t| { &m.priority },
                |m: &mut Sendprop_t| { &mut m.priority },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "dt_name",
                |m: &Sendprop_t| { &m.dt_name },
                |m: &mut Sendprop_t| { &mut m.dt_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_elements",
                |m: &Sendprop_t| { &m.num_elements },
                |m: &mut Sendprop_t| { &mut m.num_elements },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "low_value",
                |m: &Sendprop_t| { &m.low_value },
                |m: &mut Sendprop_t| { &mut m.low_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "high_value",
                |m: &Sendprop_t| { &m.high_value },
                |m: &mut Sendprop_t| { &mut m.high_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "num_bits",
                |m: &Sendprop_t| { &m.num_bits },
                |m: &mut Sendprop_t| { &mut m.num_bits },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sendprop_t>(
                "CSVCMsg_SendTable.sendprop_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Sendprop_t {
        const NAME: &'static str = "sendprop_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.var_name = ::std::option::Option::Some(is.read_tokio_chars()?);
                    },
                    24 => {
                        self.flags = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.priority = ::std::option::Option::Some(is.read_int32()?);
                    },
                    42 => {
                        self.dt_name = ::std::option::Option::Some(is.read_tokio_chars()?);
                    },
                    48 => {
                        self.num_elements = ::std::option::Option::Some(is.read_int32()?);
                    },
                    61 => {
                        self.low_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    69 => {
                        self.high_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    72 => {
                        self.num_bits = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.var_name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.flags {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.priority {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.dt_name.as_ref() {
                my_size += ::protobuf::rt::string_size(5, &v);
            }
            if let Some(v) = self.num_elements {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.low_value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.high_value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.num_bits {
                my_size += ::protobuf::rt::int32_size(9, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.var_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.flags {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.priority {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.dt_name.as_ref() {
                os.write_string(5, v)?;
            }
            if let Some(v) = self.num_elements {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.low_value {
                os.write_float(7, v)?;
            }
            if let Some(v) = self.high_value {
                os.write_float(8, v)?;
            }
            if let Some(v) = self.num_bits {
                os.write_int32(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Sendprop_t {
            Sendprop_t::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.var_name = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.priority = ::std::option::Option::None;
            self.dt_name = ::std::option::Option::None;
            self.num_elements = ::std::option::Option::None;
            self.low_value = ::std::option::Option::None;
            self.high_value = ::std::option::Option::None;
            self.num_bits = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Sendprop_t {
            static instance: Sendprop_t = Sendprop_t {
                type_: ::std::option::Option::None,
                var_name: ::std::option::Option::None,
                flags: ::std::option::Option::None,
                priority: ::std::option::Option::None,
                dt_name: ::std::option::Option::None,
                num_elements: ::std::option::Option::None,
                low_value: ::std::option::Option::None,
                high_value: ::std::option::Option::None,
                num_bits: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Sendprop_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_SendTable.sendprop_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Sendprop_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Sendprop_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_Print)
pub struct CSVCMsg_Print {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Print.text)
    pub text: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Print.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Print {
    fn default() -> &'a CSVCMsg_Print {
        <CSVCMsg_Print as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Print {
    pub fn new() -> CSVCMsg_Print {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::protobuf::Chars) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::protobuf::Chars {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::protobuf::Chars {
        self.text.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CSVCMsg_Print| { &m.text },
            |m: &mut CSVCMsg_Print| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_Print>(
            "CSVCMsg_Print",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_Print {
    const NAME: &'static str = "CSVCMsg_Print";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Print {
        CSVCMsg_Print::new()
    }

    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Print {
        static instance: CSVCMsg_Print = CSVCMsg_Print {
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_Print {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_Print").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_Print {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_Print {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_SetPause)
pub struct CSVCMsg_SetPause {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_SetPause.paused)
    pub paused: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_SetPause.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_SetPause {
    fn default() -> &'a CSVCMsg_SetPause {
        <CSVCMsg_SetPause as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_SetPause {
    pub fn new() -> CSVCMsg_SetPause {
        ::std::default::Default::default()
    }

    // optional bool paused = 1;

    pub fn paused(&self) -> bool {
        self.paused.unwrap_or(false)
    }

    pub fn clear_paused(&mut self) {
        self.paused = ::std::option::Option::None;
    }

    pub fn has_paused(&self) -> bool {
        self.paused.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paused(&mut self, v: bool) {
        self.paused = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paused",
            |m: &CSVCMsg_SetPause| { &m.paused },
            |m: &mut CSVCMsg_SetPause| { &mut m.paused },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_SetPause>(
            "CSVCMsg_SetPause",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_SetPause {
    const NAME: &'static str = "CSVCMsg_SetPause";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.paused = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.paused {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.paused {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_SetPause {
        CSVCMsg_SetPause::new()
    }

    fn clear(&mut self) {
        self.paused = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_SetPause {
        static instance: CSVCMsg_SetPause = CSVCMsg_SetPause {
            paused: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_SetPause {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_SetPause").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_SetPause {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_SetPause {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_SetView)
pub struct CSVCMsg_SetView {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_SetView.entity_index)
    pub entity_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_SetView.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_SetView {
    fn default() -> &'a CSVCMsg_SetView {
        <CSVCMsg_SetView as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_SetView {
    pub fn new() -> CSVCMsg_SetView {
        ::std::default::Default::default()
    }

    // optional int32 entity_index = 1;

    pub fn entity_index(&self) -> i32 {
        self.entity_index.unwrap_or(0)
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = ::std::option::Option::None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_index",
            |m: &CSVCMsg_SetView| { &m.entity_index },
            |m: &mut CSVCMsg_SetView| { &mut m.entity_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_SetView>(
            "CSVCMsg_SetView",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_SetView {
    const NAME: &'static str = "CSVCMsg_SetView";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entity_index {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_SetView {
        CSVCMsg_SetView::new()
    }

    fn clear(&mut self) {
        self.entity_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_SetView {
        static instance: CSVCMsg_SetView = CSVCMsg_SetView {
            entity_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_SetView {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_SetView").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_SetView {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_SetView {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_CreateStringTable)
pub struct CSVCMsg_CreateStringTable {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.name)
    pub name: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.max_entries)
    pub max_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.num_entries)
    pub num_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.user_data_fixed_size)
    pub user_data_fixed_size: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.user_data_size)
    pub user_data_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.user_data_size_bits)
    pub user_data_size_bits: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.flags)
    pub flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_CreateStringTable.string_data)
    pub string_data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_CreateStringTable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_CreateStringTable {
    fn default() -> &'a CSVCMsg_CreateStringTable {
        <CSVCMsg_CreateStringTable as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_CreateStringTable {
    pub fn new() -> CSVCMsg_CreateStringTable {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::protobuf::Chars) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::protobuf::Chars {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::protobuf::Chars {
        self.name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional int32 max_entries = 2;

    pub fn max_entries(&self) -> i32 {
        self.max_entries.unwrap_or(0)
    }

    pub fn clear_max_entries(&mut self) {
        self.max_entries = ::std::option::Option::None;
    }

    pub fn has_max_entries(&self) -> bool {
        self.max_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_entries(&mut self, v: i32) {
        self.max_entries = ::std::option::Option::Some(v);
    }

    // optional int32 num_entries = 3;

    pub fn num_entries(&self) -> i32 {
        self.num_entries.unwrap_or(0)
    }

    pub fn clear_num_entries(&mut self) {
        self.num_entries = ::std::option::Option::None;
    }

    pub fn has_num_entries(&self) -> bool {
        self.num_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_entries(&mut self, v: i32) {
        self.num_entries = ::std::option::Option::Some(v);
    }

    // optional bool user_data_fixed_size = 4;

    pub fn user_data_fixed_size(&self) -> bool {
        self.user_data_fixed_size.unwrap_or(false)
    }

    pub fn clear_user_data_fixed_size(&mut self) {
        self.user_data_fixed_size = ::std::option::Option::None;
    }

    pub fn has_user_data_fixed_size(&self) -> bool {
        self.user_data_fixed_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_data_fixed_size(&mut self, v: bool) {
        self.user_data_fixed_size = ::std::option::Option::Some(v);
    }

    // optional int32 user_data_size = 5;

    pub fn user_data_size(&self) -> i32 {
        self.user_data_size.unwrap_or(0)
    }

    pub fn clear_user_data_size(&mut self) {
        self.user_data_size = ::std::option::Option::None;
    }

    pub fn has_user_data_size(&self) -> bool {
        self.user_data_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_data_size(&mut self, v: i32) {
        self.user_data_size = ::std::option::Option::Some(v);
    }

    // optional int32 user_data_size_bits = 6;

    pub fn user_data_size_bits(&self) -> i32 {
        self.user_data_size_bits.unwrap_or(0)
    }

    pub fn clear_user_data_size_bits(&mut self) {
        self.user_data_size_bits = ::std::option::Option::None;
    }

    pub fn has_user_data_size_bits(&self) -> bool {
        self.user_data_size_bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_data_size_bits(&mut self, v: i32) {
        self.user_data_size_bits = ::std::option::Option::Some(v);
    }

    // optional int32 flags = 7;

    pub fn flags(&self) -> i32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional bytes string_data = 8;

    pub fn string_data(&self) -> &[u8] {
        match self.string_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_string_data(&mut self) {
        self.string_data = ::std::option::Option::None;
    }

    pub fn has_string_data(&self) -> bool {
        self.string_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_data(&mut self, v: ::bytes::Bytes) {
        self.string_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_data(&mut self) -> &mut ::bytes::Bytes {
        if self.string_data.is_none() {
            self.string_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.string_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_data(&mut self) -> ::bytes::Bytes {
        self.string_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CSVCMsg_CreateStringTable| { &m.name },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_entries",
            |m: &CSVCMsg_CreateStringTable| { &m.max_entries },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.max_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_entries",
            |m: &CSVCMsg_CreateStringTable| { &m.num_entries },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.num_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_data_fixed_size",
            |m: &CSVCMsg_CreateStringTable| { &m.user_data_fixed_size },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.user_data_fixed_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_data_size",
            |m: &CSVCMsg_CreateStringTable| { &m.user_data_size },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.user_data_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "user_data_size_bits",
            |m: &CSVCMsg_CreateStringTable| { &m.user_data_size_bits },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.user_data_size_bits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "flags",
            |m: &CSVCMsg_CreateStringTable| { &m.flags },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_data",
            |m: &CSVCMsg_CreateStringTable| { &m.string_data },
            |m: &mut CSVCMsg_CreateStringTable| { &mut m.string_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_CreateStringTable>(
            "CSVCMsg_CreateStringTable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_CreateStringTable {
    const NAME: &'static str = "CSVCMsg_CreateStringTable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                16 => {
                    self.max_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.num_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.user_data_fixed_size = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.user_data_size = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.user_data_size_bits = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.flags = ::std::option::Option::Some(is.read_int32()?);
                },
                66 => {
                    self.string_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.max_entries {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.num_entries {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.user_data_fixed_size {
            my_size += 1 + 1;
        }
        if let Some(v) = self.user_data_size {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.user_data_size_bits {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.flags {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.string_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.max_entries {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.num_entries {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.user_data_fixed_size {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.user_data_size {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.user_data_size_bits {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.flags {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.string_data.as_ref() {
            os.write_bytes(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_CreateStringTable {
        CSVCMsg_CreateStringTable::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.max_entries = ::std::option::Option::None;
        self.num_entries = ::std::option::Option::None;
        self.user_data_fixed_size = ::std::option::Option::None;
        self.user_data_size = ::std::option::Option::None;
        self.user_data_size_bits = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.string_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_CreateStringTable {
        static instance: CSVCMsg_CreateStringTable = CSVCMsg_CreateStringTable {
            name: ::std::option::Option::None,
            max_entries: ::std::option::Option::None,
            num_entries: ::std::option::Option::None,
            user_data_fixed_size: ::std::option::Option::None,
            user_data_size: ::std::option::Option::None,
            user_data_size_bits: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            string_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_CreateStringTable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_CreateStringTable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_CreateStringTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_CreateStringTable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_UpdateStringTable)
pub struct CSVCMsg_UpdateStringTable {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_UpdateStringTable.table_id)
    pub table_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_UpdateStringTable.num_changed_entries)
    pub num_changed_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_UpdateStringTable.string_data)
    pub string_data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_UpdateStringTable.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_UpdateStringTable {
    fn default() -> &'a CSVCMsg_UpdateStringTable {
        <CSVCMsg_UpdateStringTable as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_UpdateStringTable {
    pub fn new() -> CSVCMsg_UpdateStringTable {
        ::std::default::Default::default()
    }

    // optional int32 table_id = 1;

    pub fn table_id(&self) -> i32 {
        self.table_id.unwrap_or(0)
    }

    pub fn clear_table_id(&mut self) {
        self.table_id = ::std::option::Option::None;
    }

    pub fn has_table_id(&self) -> bool {
        self.table_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_table_id(&mut self, v: i32) {
        self.table_id = ::std::option::Option::Some(v);
    }

    // optional int32 num_changed_entries = 2;

    pub fn num_changed_entries(&self) -> i32 {
        self.num_changed_entries.unwrap_or(0)
    }

    pub fn clear_num_changed_entries(&mut self) {
        self.num_changed_entries = ::std::option::Option::None;
    }

    pub fn has_num_changed_entries(&self) -> bool {
        self.num_changed_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_changed_entries(&mut self, v: i32) {
        self.num_changed_entries = ::std::option::Option::Some(v);
    }

    // optional bytes string_data = 3;

    pub fn string_data(&self) -> &[u8] {
        match self.string_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_string_data(&mut self) {
        self.string_data = ::std::option::Option::None;
    }

    pub fn has_string_data(&self) -> bool {
        self.string_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_data(&mut self, v: ::bytes::Bytes) {
        self.string_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_data(&mut self) -> &mut ::bytes::Bytes {
        if self.string_data.is_none() {
            self.string_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.string_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_data(&mut self) -> ::bytes::Bytes {
        self.string_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "table_id",
            |m: &CSVCMsg_UpdateStringTable| { &m.table_id },
            |m: &mut CSVCMsg_UpdateStringTable| { &mut m.table_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_changed_entries",
            |m: &CSVCMsg_UpdateStringTable| { &m.num_changed_entries },
            |m: &mut CSVCMsg_UpdateStringTable| { &mut m.num_changed_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_data",
            |m: &CSVCMsg_UpdateStringTable| { &m.string_data },
            |m: &mut CSVCMsg_UpdateStringTable| { &mut m.string_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_UpdateStringTable>(
            "CSVCMsg_UpdateStringTable",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_UpdateStringTable {
    const NAME: &'static str = "CSVCMsg_UpdateStringTable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.table_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.num_changed_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.string_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.table_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.num_changed_entries {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.string_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.table_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.num_changed_entries {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.string_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_UpdateStringTable {
        CSVCMsg_UpdateStringTable::new()
    }

    fn clear(&mut self) {
        self.table_id = ::std::option::Option::None;
        self.num_changed_entries = ::std::option::Option::None;
        self.string_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_UpdateStringTable {
        static instance: CSVCMsg_UpdateStringTable = CSVCMsg_UpdateStringTable {
            table_id: ::std::option::Option::None,
            num_changed_entries: ::std::option::Option::None,
            string_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_UpdateStringTable {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_UpdateStringTable").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_UpdateStringTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_UpdateStringTable {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_VoiceInit)
pub struct CSVCMsg_VoiceInit {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_VoiceInit.quality)
    pub quality: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceInit.codec)
    pub codec: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceInit.version)
    pub version: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_VoiceInit.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_VoiceInit {
    fn default() -> &'a CSVCMsg_VoiceInit {
        <CSVCMsg_VoiceInit as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_VoiceInit {
    pub fn new() -> CSVCMsg_VoiceInit {
        ::std::default::Default::default()
    }

    // optional int32 quality = 1;

    pub fn quality(&self) -> i32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: i32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional string codec = 2;

    pub fn codec(&self) -> &str {
        match self.codec.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_codec(&mut self) {
        self.codec = ::std::option::Option::None;
    }

    pub fn has_codec(&self) -> bool {
        self.codec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_codec(&mut self, v: ::protobuf::Chars) {
        self.codec = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_codec(&mut self) -> &mut ::protobuf::Chars {
        if self.codec.is_none() {
            self.codec = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.codec.as_mut().unwrap()
    }

    // Take field
    pub fn take_codec(&mut self) -> ::protobuf::Chars {
        self.codec.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional int32 version = 3;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0i32)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality",
            |m: &CSVCMsg_VoiceInit| { &m.quality },
            |m: &mut CSVCMsg_VoiceInit| { &mut m.quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "codec",
            |m: &CSVCMsg_VoiceInit| { &m.codec },
            |m: &mut CSVCMsg_VoiceInit| { &mut m.codec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CSVCMsg_VoiceInit| { &m.version },
            |m: &mut CSVCMsg_VoiceInit| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_VoiceInit>(
            "CSVCMsg_VoiceInit",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_VoiceInit {
    const NAME: &'static str = "CSVCMsg_VoiceInit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quality = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.codec = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                24 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.codec.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quality {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.codec.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.version {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_VoiceInit {
        CSVCMsg_VoiceInit::new()
    }

    fn clear(&mut self) {
        self.quality = ::std::option::Option::None;
        self.codec = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_VoiceInit {
        static instance: CSVCMsg_VoiceInit = CSVCMsg_VoiceInit {
            quality: ::std::option::Option::None,
            codec: ::std::option::Option::None,
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_VoiceInit {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_VoiceInit").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_VoiceInit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_VoiceInit {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_VoiceData)
pub struct CSVCMsg_VoiceData {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.client)
    pub client: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.proximity)
    pub proximity: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.xuid)
    pub xuid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.audible_mask)
    pub audible_mask: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.voice_data)
    pub voice_data: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.caster)
    pub caster: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.format)
    pub format: ::std::option::Option<::protobuf::EnumOrUnknown<VoiceDataFormat_t>>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.sequence_bytes)
    pub sequence_bytes: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.section_number)
    pub section_number: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSVCMsg_VoiceData.uncompressed_sample_offset)
    pub uncompressed_sample_offset: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_VoiceData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_VoiceData {
    fn default() -> &'a CSVCMsg_VoiceData {
        <CSVCMsg_VoiceData as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_VoiceData {
    pub fn new() -> CSVCMsg_VoiceData {
        ::std::default::Default::default()
    }

    // optional int32 client = 1;

    pub fn client(&self) -> i32 {
        self.client.unwrap_or(0)
    }

    pub fn clear_client(&mut self) {
        self.client = ::std::option::Option::None;
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: i32) {
        self.client = ::std::option::Option::Some(v);
    }

    // optional bool proximity = 2;

    pub fn proximity(&self) -> bool {
        self.proximity.unwrap_or(false)
    }

    pub fn clear_proximity(&mut self) {
        self.proximity = ::std::option::Option::None;
    }

    pub fn has_proximity(&self) -> bool {
        self.proximity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proximity(&mut self, v: bool) {
        self.proximity = ::std::option::Option::Some(v);
    }

    // optional fixed64 xuid = 3;

    pub fn xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }

    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional int32 audible_mask = 4;

    pub fn audible_mask(&self) -> i32 {
        self.audible_mask.unwrap_or(0)
    }

    pub fn clear_audible_mask(&mut self) {
        self.audible_mask = ::std::option::Option::None;
    }

    pub fn has_audible_mask(&self) -> bool {
        self.audible_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audible_mask(&mut self, v: i32) {
        self.audible_mask = ::std::option::Option::Some(v);
    }

    // optional bytes voice_data = 5;

    pub fn voice_data(&self) -> &[u8] {
        match self.voice_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_voice_data(&mut self) {
        self.voice_data = ::std::option::Option::None;
    }

    pub fn has_voice_data(&self) -> bool {
        self.voice_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_data(&mut self, v: ::bytes::Bytes) {
        self.voice_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voice_data(&mut self) -> &mut ::bytes::Bytes {
        if self.voice_data.is_none() {
            self.voice_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.voice_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_voice_data(&mut self) -> ::bytes::Bytes {
        self.voice_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional bool caster = 6;

    pub fn caster(&self) -> bool {
        self.caster.unwrap_or(false)
    }

    pub fn clear_caster(&mut self) {
        self.caster = ::std::option::Option::None;
    }

    pub fn has_caster(&self) -> bool {
        self.caster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caster(&mut self, v: bool) {
        self.caster = ::std::option::Option::Some(v);
    }

    // optional .VoiceDataFormat_t format = 7;

    pub fn format(&self) -> VoiceDataFormat_t {
        match self.format {
            Some(e) => e.enum_value_or(VoiceDataFormat_t::VOICEDATA_FORMAT_ENGINE),
            None => VoiceDataFormat_t::VOICEDATA_FORMAT_ENGINE,
        }
    }

    pub fn clear_format(&mut self) {
        self.format = ::std::option::Option::None;
    }

    pub fn has_format(&self) -> bool {
        self.format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: VoiceDataFormat_t) {
        self.format = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 sequence_bytes = 8;

    pub fn sequence_bytes(&self) -> i32 {
        self.sequence_bytes.unwrap_or(0)
    }

    pub fn clear_sequence_bytes(&mut self) {
        self.sequence_bytes = ::std::option::Option::None;
    }

    pub fn has_sequence_bytes(&self) -> bool {
        self.sequence_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_bytes(&mut self, v: i32) {
        self.sequence_bytes = ::std::option::Option::Some(v);
    }

    // optional uint32 section_number = 9;

    pub fn section_number(&self) -> u32 {
        self.section_number.unwrap_or(0)
    }

    pub fn clear_section_number(&mut self) {
        self.section_number = ::std::option::Option::None;
    }

    pub fn has_section_number(&self) -> bool {
        self.section_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_section_number(&mut self, v: u32) {
        self.section_number = ::std::option::Option::Some(v);
    }

    // optional uint32 uncompressed_sample_offset = 10;

    pub fn uncompressed_sample_offset(&self) -> u32 {
        self.uncompressed_sample_offset.unwrap_or(0)
    }

    pub fn clear_uncompressed_sample_offset(&mut self) {
        self.uncompressed_sample_offset = ::std::option::Option::None;
    }

    pub fn has_uncompressed_sample_offset(&self) -> bool {
        self.uncompressed_sample_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uncompressed_sample_offset(&mut self, v: u32) {
        self.uncompressed_sample_offset = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client",
            |m: &CSVCMsg_VoiceData| { &m.client },
            |m: &mut CSVCMsg_VoiceData| { &mut m.client },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "proximity",
            |m: &CSVCMsg_VoiceData| { &m.proximity },
            |m: &mut CSVCMsg_VoiceData| { &mut m.proximity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xuid",
            |m: &CSVCMsg_VoiceData| { &m.xuid },
            |m: &mut CSVCMsg_VoiceData| { &mut m.xuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "audible_mask",
            |m: &CSVCMsg_VoiceData| { &m.audible_mask },
            |m: &mut CSVCMsg_VoiceData| { &mut m.audible_mask },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "voice_data",
            |m: &CSVCMsg_VoiceData| { &m.voice_data },
            |m: &mut CSVCMsg_VoiceData| { &mut m.voice_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caster",
            |m: &CSVCMsg_VoiceData| { &m.caster },
            |m: &mut CSVCMsg_VoiceData| { &mut m.caster },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "format",
            |m: &CSVCMsg_VoiceData| { &m.format },
            |m: &mut CSVCMsg_VoiceData| { &mut m.format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sequence_bytes",
            |m: &CSVCMsg_VoiceData| { &m.sequence_bytes },
            |m: &mut CSVCMsg_VoiceData| { &mut m.sequence_bytes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "section_number",
            |m: &CSVCMsg_VoiceData| { &m.section_number },
            |m: &mut CSVCMsg_VoiceData| { &mut m.section_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uncompressed_sample_offset",
            |m: &CSVCMsg_VoiceData| { &m.uncompressed_sample_offset },
            |m: &mut CSVCMsg_VoiceData| { &mut m.uncompressed_sample_offset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_VoiceData>(
            "CSVCMsg_VoiceData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_VoiceData {
    const NAME: &'static str = "CSVCMsg_VoiceData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.client = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.proximity = ::std::option::Option::Some(is.read_bool()?);
                },
                25 => {
                    self.xuid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.audible_mask = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    self.voice_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                48 => {
                    self.caster = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.format = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                64 => {
                    self.sequence_bytes = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.section_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.uncompressed_sample_offset = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.proximity {
            my_size += 1 + 1;
        }
        if let Some(v) = self.xuid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.audible_mask {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.voice_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.caster {
            my_size += 1 + 1;
        }
        if let Some(v) = self.format {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.sequence_bytes {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.section_number {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.uncompressed_sample_offset {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.client {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.proximity {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.xuid {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.audible_mask {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.voice_data.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.caster {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.format {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.sequence_bytes {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.section_number {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.uncompressed_sample_offset {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_VoiceData {
        CSVCMsg_VoiceData::new()
    }

    fn clear(&mut self) {
        self.client = ::std::option::Option::None;
        self.proximity = ::std::option::Option::None;
        self.xuid = ::std::option::Option::None;
        self.audible_mask = ::std::option::Option::None;
        self.voice_data = ::std::option::Option::None;
        self.caster = ::std::option::Option::None;
        self.format = ::std::option::Option::None;
        self.sequence_bytes = ::std::option::Option::None;
        self.section_number = ::std::option::Option::None;
        self.uncompressed_sample_offset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_VoiceData {
        static instance: CSVCMsg_VoiceData = CSVCMsg_VoiceData {
            client: ::std::option::Option::None,
            proximity: ::std::option::Option::None,
            xuid: ::std::option::Option::None,
            audible_mask: ::std::option::Option::None,
            voice_data: ::std::option::Option::None,
            caster: ::std::option::Option::None,
            format: ::std::option::Option::None,
            sequence_bytes: ::std::option::Option::None,
            section_number: ::std::option::Option::None,
            uncompressed_sample_offset: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_VoiceData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_VoiceData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_VoiceData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_VoiceData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_FixAngle)
pub struct CSVCMsg_FixAngle {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_FixAngle.relative)
    pub relative: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_FixAngle.angle)
    pub angle: ::protobuf::MessageField<CMsgQAngle>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_FixAngle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_FixAngle {
    fn default() -> &'a CSVCMsg_FixAngle {
        <CSVCMsg_FixAngle as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_FixAngle {
    pub fn new() -> CSVCMsg_FixAngle {
        ::std::default::Default::default()
    }

    // optional bool relative = 1;

    pub fn relative(&self) -> bool {
        self.relative.unwrap_or(false)
    }

    pub fn clear_relative(&mut self) {
        self.relative = ::std::option::Option::None;
    }

    pub fn has_relative(&self) -> bool {
        self.relative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relative(&mut self, v: bool) {
        self.relative = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relative",
            |m: &CSVCMsg_FixAngle| { &m.relative },
            |m: &mut CSVCMsg_FixAngle| { &mut m.relative },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgQAngle>(
            "angle",
            |m: &CSVCMsg_FixAngle| { &m.angle },
            |m: &mut CSVCMsg_FixAngle| { &mut m.angle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_FixAngle>(
            "CSVCMsg_FixAngle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_FixAngle {
    const NAME: &'static str = "CSVCMsg_FixAngle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.relative = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.angle)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.relative {
            my_size += 1 + 1;
        }
        if let Some(v) = self.angle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.relative {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.angle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_FixAngle {
        CSVCMsg_FixAngle::new()
    }

    fn clear(&mut self) {
        self.relative = ::std::option::Option::None;
        self.angle.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_FixAngle {
        static instance: CSVCMsg_FixAngle = CSVCMsg_FixAngle {
            relative: ::std::option::Option::None,
            angle: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_FixAngle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_FixAngle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_FixAngle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_FixAngle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_CrosshairAngle)
pub struct CSVCMsg_CrosshairAngle {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_CrosshairAngle.angle)
    pub angle: ::protobuf::MessageField<CMsgQAngle>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_CrosshairAngle.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_CrosshairAngle {
    fn default() -> &'a CSVCMsg_CrosshairAngle {
        <CSVCMsg_CrosshairAngle as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_CrosshairAngle {
    pub fn new() -> CSVCMsg_CrosshairAngle {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgQAngle>(
            "angle",
            |m: &CSVCMsg_CrosshairAngle| { &m.angle },
            |m: &mut CSVCMsg_CrosshairAngle| { &mut m.angle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_CrosshairAngle>(
            "CSVCMsg_CrosshairAngle",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_CrosshairAngle {
    const NAME: &'static str = "CSVCMsg_CrosshairAngle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.angle)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.angle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.angle.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_CrosshairAngle {
        CSVCMsg_CrosshairAngle::new()
    }

    fn clear(&mut self) {
        self.angle.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_CrosshairAngle {
        static instance: CSVCMsg_CrosshairAngle = CSVCMsg_CrosshairAngle {
            angle: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_CrosshairAngle {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_CrosshairAngle").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_CrosshairAngle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_CrosshairAngle {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_Prefetch)
pub struct CSVCMsg_Prefetch {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Prefetch.sound_index)
    pub sound_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Prefetch.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Prefetch {
    fn default() -> &'a CSVCMsg_Prefetch {
        <CSVCMsg_Prefetch as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Prefetch {
    pub fn new() -> CSVCMsg_Prefetch {
        ::std::default::Default::default()
    }

    // optional int32 sound_index = 1;

    pub fn sound_index(&self) -> i32 {
        self.sound_index.unwrap_or(0)
    }

    pub fn clear_sound_index(&mut self) {
        self.sound_index = ::std::option::Option::None;
    }

    pub fn has_sound_index(&self) -> bool {
        self.sound_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sound_index(&mut self, v: i32) {
        self.sound_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sound_index",
            |m: &CSVCMsg_Prefetch| { &m.sound_index },
            |m: &mut CSVCMsg_Prefetch| { &mut m.sound_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_Prefetch>(
            "CSVCMsg_Prefetch",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_Prefetch {
    const NAME: &'static str = "CSVCMsg_Prefetch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sound_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sound_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sound_index {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Prefetch {
        CSVCMsg_Prefetch::new()
    }

    fn clear(&mut self) {
        self.sound_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Prefetch {
        static instance: CSVCMsg_Prefetch = CSVCMsg_Prefetch {
            sound_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_Prefetch {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_Prefetch").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_Prefetch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_Prefetch {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_BSPDecal)
pub struct CSVCMsg_BSPDecal {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.pos)
    pub pos: ::protobuf::MessageField<CMsgVector>,
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.decal_texture_index)
    pub decal_texture_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.entity_index)
    pub entity_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.model_index)
    pub model_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_BSPDecal.low_priority)
    pub low_priority: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_BSPDecal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_BSPDecal {
    fn default() -> &'a CSVCMsg_BSPDecal {
        <CSVCMsg_BSPDecal as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_BSPDecal {
    pub fn new() -> CSVCMsg_BSPDecal {
        ::std::default::Default::default()
    }

    // optional int32 decal_texture_index = 2;

    pub fn decal_texture_index(&self) -> i32 {
        self.decal_texture_index.unwrap_or(0)
    }

    pub fn clear_decal_texture_index(&mut self) {
        self.decal_texture_index = ::std::option::Option::None;
    }

    pub fn has_decal_texture_index(&self) -> bool {
        self.decal_texture_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decal_texture_index(&mut self, v: i32) {
        self.decal_texture_index = ::std::option::Option::Some(v);
    }

    // optional int32 entity_index = 3;

    pub fn entity_index(&self) -> i32 {
        self.entity_index.unwrap_or(0)
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = ::std::option::Option::None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = ::std::option::Option::Some(v);
    }

    // optional int32 model_index = 4;

    pub fn model_index(&self) -> i32 {
        self.model_index.unwrap_or(0)
    }

    pub fn clear_model_index(&mut self) {
        self.model_index = ::std::option::Option::None;
    }

    pub fn has_model_index(&self) -> bool {
        self.model_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_model_index(&mut self, v: i32) {
        self.model_index = ::std::option::Option::Some(v);
    }

    // optional bool low_priority = 5;

    pub fn low_priority(&self) -> bool {
        self.low_priority.unwrap_or(false)
    }

    pub fn clear_low_priority(&mut self) {
        self.low_priority = ::std::option::Option::None;
    }

    pub fn has_low_priority(&self) -> bool {
        self.low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority(&mut self, v: bool) {
        self.low_priority = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgVector>(
            "pos",
            |m: &CSVCMsg_BSPDecal| { &m.pos },
            |m: &mut CSVCMsg_BSPDecal| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "decal_texture_index",
            |m: &CSVCMsg_BSPDecal| { &m.decal_texture_index },
            |m: &mut CSVCMsg_BSPDecal| { &mut m.decal_texture_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_index",
            |m: &CSVCMsg_BSPDecal| { &m.entity_index },
            |m: &mut CSVCMsg_BSPDecal| { &mut m.entity_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "model_index",
            |m: &CSVCMsg_BSPDecal| { &m.model_index },
            |m: &mut CSVCMsg_BSPDecal| { &mut m.model_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "low_priority",
            |m: &CSVCMsg_BSPDecal| { &m.low_priority },
            |m: &mut CSVCMsg_BSPDecal| { &mut m.low_priority },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_BSPDecal>(
            "CSVCMsg_BSPDecal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_BSPDecal {
    const NAME: &'static str = "CSVCMsg_BSPDecal";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                16 => {
                    self.decal_texture_index = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.model_index = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.low_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.decal_texture_index {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.entity_index {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.model_index {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.low_priority {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pos.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.decal_texture_index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.entity_index {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.model_index {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.low_priority {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_BSPDecal {
        CSVCMsg_BSPDecal::new()
    }

    fn clear(&mut self) {
        self.pos.clear();
        self.decal_texture_index = ::std::option::Option::None;
        self.entity_index = ::std::option::Option::None;
        self.model_index = ::std::option::Option::None;
        self.low_priority = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_BSPDecal {
        static instance: CSVCMsg_BSPDecal = CSVCMsg_BSPDecal {
            pos: ::protobuf::MessageField::none(),
            decal_texture_index: ::std::option::Option::None,
            entity_index: ::std::option::Option::None,
            model_index: ::std::option::Option::None,
            low_priority: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_BSPDecal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_BSPDecal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_BSPDecal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_BSPDecal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_SplitScreen)
pub struct CSVCMsg_SplitScreen {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_SplitScreen.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<ESplitScreenMessageType>>,
    // @@protoc_insertion_point(field:CSVCMsg_SplitScreen.slot)
    pub slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_SplitScreen.player_index)
    pub player_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_SplitScreen.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_SplitScreen {
    fn default() -> &'a CSVCMsg_SplitScreen {
        <CSVCMsg_SplitScreen as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_SplitScreen {
    pub fn new() -> CSVCMsg_SplitScreen {
        ::std::default::Default::default()
    }

    // optional .ESplitScreenMessageType type = 1;

    pub fn type_(&self) -> ESplitScreenMessageType {
        match self.type_ {
            Some(e) => e.enum_value_or(ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER),
            None => ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ESplitScreenMessageType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 slot = 2;

    pub fn slot(&self) -> i32 {
        self.slot.unwrap_or(0)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: i32) {
        self.slot = ::std::option::Option::Some(v);
    }

    // optional int32 player_index = 3;

    pub fn player_index(&self) -> i32 {
        self.player_index.unwrap_or(0)
    }

    pub fn clear_player_index(&mut self) {
        self.player_index = ::std::option::Option::None;
    }

    pub fn has_player_index(&self) -> bool {
        self.player_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_index(&mut self, v: i32) {
        self.player_index = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CSVCMsg_SplitScreen| { &m.type_ },
            |m: &mut CSVCMsg_SplitScreen| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slot",
            |m: &CSVCMsg_SplitScreen| { &m.slot },
            |m: &mut CSVCMsg_SplitScreen| { &mut m.slot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_index",
            |m: &CSVCMsg_SplitScreen| { &m.player_index },
            |m: &mut CSVCMsg_SplitScreen| { &mut m.player_index },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_SplitScreen>(
            "CSVCMsg_SplitScreen",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_SplitScreen {
    const NAME: &'static str = "CSVCMsg_SplitScreen";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.slot = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.player_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.slot {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.player_index {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.slot {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.player_index {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_SplitScreen {
        CSVCMsg_SplitScreen::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.slot = ::std::option::Option::None;
        self.player_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_SplitScreen {
        static instance: CSVCMsg_SplitScreen = CSVCMsg_SplitScreen {
            type_: ::std::option::Option::None,
            slot: ::std::option::Option::None,
            player_index: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_SplitScreen {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_SplitScreen").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_SplitScreen {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_SplitScreen {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_GetCvarValue)
pub struct CSVCMsg_GetCvarValue {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_GetCvarValue.cookie)
    pub cookie: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_GetCvarValue.cvar_name)
    pub cvar_name: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_GetCvarValue.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_GetCvarValue {
    fn default() -> &'a CSVCMsg_GetCvarValue {
        <CSVCMsg_GetCvarValue as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_GetCvarValue {
    pub fn new() -> CSVCMsg_GetCvarValue {
        ::std::default::Default::default()
    }

    // optional int32 cookie = 1;

    pub fn cookie(&self) -> i32 {
        self.cookie.unwrap_or(0)
    }

    pub fn clear_cookie(&mut self) {
        self.cookie = ::std::option::Option::None;
    }

    pub fn has_cookie(&self) -> bool {
        self.cookie.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: i32) {
        self.cookie = ::std::option::Option::Some(v);
    }

    // optional string cvar_name = 2;

    pub fn cvar_name(&self) -> &str {
        match self.cvar_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cvar_name(&mut self) {
        self.cvar_name = ::std::option::Option::None;
    }

    pub fn has_cvar_name(&self) -> bool {
        self.cvar_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cvar_name(&mut self, v: ::protobuf::Chars) {
        self.cvar_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cvar_name(&mut self) -> &mut ::protobuf::Chars {
        if self.cvar_name.is_none() {
            self.cvar_name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.cvar_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_cvar_name(&mut self) -> ::protobuf::Chars {
        self.cvar_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cookie",
            |m: &CSVCMsg_GetCvarValue| { &m.cookie },
            |m: &mut CSVCMsg_GetCvarValue| { &mut m.cookie },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cvar_name",
            |m: &CSVCMsg_GetCvarValue| { &m.cvar_name },
            |m: &mut CSVCMsg_GetCvarValue| { &mut m.cvar_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_GetCvarValue>(
            "CSVCMsg_GetCvarValue",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_GetCvarValue {
    const NAME: &'static str = "CSVCMsg_GetCvarValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cookie = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.cvar_name = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cookie {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.cvar_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cookie {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.cvar_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_GetCvarValue {
        CSVCMsg_GetCvarValue::new()
    }

    fn clear(&mut self) {
        self.cookie = ::std::option::Option::None;
        self.cvar_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_GetCvarValue {
        static instance: CSVCMsg_GetCvarValue = CSVCMsg_GetCvarValue {
            cookie: ::std::option::Option::None,
            cvar_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_GetCvarValue {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_GetCvarValue").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_GetCvarValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_GetCvarValue {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_Menu)
pub struct CSVCMsg_Menu {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Menu.dialog_type)
    pub dialog_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_Menu.menu_key_values)
    pub menu_key_values: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Menu.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Menu {
    fn default() -> &'a CSVCMsg_Menu {
        <CSVCMsg_Menu as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Menu {
    pub fn new() -> CSVCMsg_Menu {
        ::std::default::Default::default()
    }

    // optional int32 dialog_type = 1;

    pub fn dialog_type(&self) -> i32 {
        self.dialog_type.unwrap_or(0)
    }

    pub fn clear_dialog_type(&mut self) {
        self.dialog_type = ::std::option::Option::None;
    }

    pub fn has_dialog_type(&self) -> bool {
        self.dialog_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dialog_type(&mut self, v: i32) {
        self.dialog_type = ::std::option::Option::Some(v);
    }

    // optional bytes menu_key_values = 2;

    pub fn menu_key_values(&self) -> &[u8] {
        match self.menu_key_values.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_menu_key_values(&mut self) {
        self.menu_key_values = ::std::option::Option::None;
    }

    pub fn has_menu_key_values(&self) -> bool {
        self.menu_key_values.is_some()
    }

    // Param is passed by value, moved
    pub fn set_menu_key_values(&mut self, v: ::bytes::Bytes) {
        self.menu_key_values = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_menu_key_values(&mut self) -> &mut ::bytes::Bytes {
        if self.menu_key_values.is_none() {
            self.menu_key_values = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.menu_key_values.as_mut().unwrap()
    }

    // Take field
    pub fn take_menu_key_values(&mut self) -> ::bytes::Bytes {
        self.menu_key_values.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dialog_type",
            |m: &CSVCMsg_Menu| { &m.dialog_type },
            |m: &mut CSVCMsg_Menu| { &mut m.dialog_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "menu_key_values",
            |m: &CSVCMsg_Menu| { &m.menu_key_values },
            |m: &mut CSVCMsg_Menu| { &mut m.menu_key_values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_Menu>(
            "CSVCMsg_Menu",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_Menu {
    const NAME: &'static str = "CSVCMsg_Menu";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dialog_type = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.menu_key_values = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dialog_type {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.menu_key_values.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dialog_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.menu_key_values.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Menu {
        CSVCMsg_Menu::new()
    }

    fn clear(&mut self) {
        self.dialog_type = ::std::option::Option::None;
        self.menu_key_values = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Menu {
        static instance: CSVCMsg_Menu = CSVCMsg_Menu {
            dialog_type: ::std::option::Option::None,
            menu_key_values: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_Menu {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_Menu").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_Menu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_Menu {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_UserMessage)
pub struct CSVCMsg_UserMessage {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_UserMessage.msg_type)
    pub msg_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_UserMessage.msg_data)
    pub msg_data: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CSVCMsg_UserMessage.passthrough)
    pub passthrough: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_UserMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_UserMessage {
    fn default() -> &'a CSVCMsg_UserMessage {
        <CSVCMsg_UserMessage as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_UserMessage {
    pub fn new() -> CSVCMsg_UserMessage {
        ::std::default::Default::default()
    }

    // optional int32 msg_type = 1;

    pub fn msg_type(&self) -> i32 {
        self.msg_type.unwrap_or(0)
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: i32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional bytes msg_data = 2;

    pub fn msg_data(&self) -> &[u8] {
        match self.msg_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_msg_data(&mut self) {
        self.msg_data = ::std::option::Option::None;
    }

    pub fn has_msg_data(&self) -> bool {
        self.msg_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_data(&mut self, v: ::bytes::Bytes) {
        self.msg_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_data(&mut self) -> &mut ::bytes::Bytes {
        if self.msg_data.is_none() {
            self.msg_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.msg_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg_data(&mut self) -> ::bytes::Bytes {
        self.msg_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional int32 passthrough = 3;

    pub fn passthrough(&self) -> i32 {
        self.passthrough.unwrap_or(0)
    }

    pub fn clear_passthrough(&mut self) {
        self.passthrough = ::std::option::Option::None;
    }

    pub fn has_passthrough(&self) -> bool {
        self.passthrough.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passthrough(&mut self, v: i32) {
        self.passthrough = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_type",
            |m: &CSVCMsg_UserMessage| { &m.msg_type },
            |m: &mut CSVCMsg_UserMessage| { &mut m.msg_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_data",
            |m: &CSVCMsg_UserMessage| { &m.msg_data },
            |m: &mut CSVCMsg_UserMessage| { &mut m.msg_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passthrough",
            |m: &CSVCMsg_UserMessage| { &m.passthrough },
            |m: &mut CSVCMsg_UserMessage| { &mut m.passthrough },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_UserMessage>(
            "CSVCMsg_UserMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_UserMessage {
    const NAME: &'static str = "CSVCMsg_UserMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.msg_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                24 => {
                    self.passthrough = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.msg_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.passthrough {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.msg_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.passthrough {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_UserMessage {
        CSVCMsg_UserMessage::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.msg_data = ::std::option::Option::None;
        self.passthrough = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_UserMessage {
        static instance: CSVCMsg_UserMessage = CSVCMsg_UserMessage {
            msg_type: ::std::option::Option::None,
            msg_data: ::std::option::Option::None,
            passthrough: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_UserMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_UserMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_UserMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_UserMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_PaintmapData)
pub struct CSVCMsg_PaintmapData {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_PaintmapData.paintmap)
    pub paintmap: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_PaintmapData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_PaintmapData {
    fn default() -> &'a CSVCMsg_PaintmapData {
        <CSVCMsg_PaintmapData as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_PaintmapData {
    pub fn new() -> CSVCMsg_PaintmapData {
        ::std::default::Default::default()
    }

    // optional bytes paintmap = 1;

    pub fn paintmap(&self) -> &[u8] {
        match self.paintmap.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_paintmap(&mut self) {
        self.paintmap = ::std::option::Option::None;
    }

    pub fn has_paintmap(&self) -> bool {
        self.paintmap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paintmap(&mut self, v: ::bytes::Bytes) {
        self.paintmap = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_paintmap(&mut self) -> &mut ::bytes::Bytes {
        if self.paintmap.is_none() {
            self.paintmap = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.paintmap.as_mut().unwrap()
    }

    // Take field
    pub fn take_paintmap(&mut self) -> ::bytes::Bytes {
        self.paintmap.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paintmap",
            |m: &CSVCMsg_PaintmapData| { &m.paintmap },
            |m: &mut CSVCMsg_PaintmapData| { &mut m.paintmap },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_PaintmapData>(
            "CSVCMsg_PaintmapData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_PaintmapData {
    const NAME: &'static str = "CSVCMsg_PaintmapData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.paintmap = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.paintmap.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.paintmap.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_PaintmapData {
        CSVCMsg_PaintmapData::new()
    }

    fn clear(&mut self) {
        self.paintmap = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_PaintmapData {
        static instance: CSVCMsg_PaintmapData = CSVCMsg_PaintmapData {
            paintmap: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_PaintmapData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_PaintmapData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_PaintmapData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_PaintmapData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_GameEvent)
pub struct CSVCMsg_GameEvent {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_GameEvent.event_name)
    pub event_name: ::std::option::Option<::protobuf::Chars>,
    // @@protoc_insertion_point(field:CSVCMsg_GameEvent.eventid)
    pub eventid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_GameEvent.keys)
    pub keys: ::std::vec::Vec<csvcmsg_game_event::Key_t>,
    // @@protoc_insertion_point(field:CSVCMsg_GameEvent.passthrough)
    pub passthrough: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_GameEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_GameEvent {
    fn default() -> &'a CSVCMsg_GameEvent {
        <CSVCMsg_GameEvent as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_GameEvent {
    pub fn new() -> CSVCMsg_GameEvent {
        ::std::default::Default::default()
    }

    // optional string event_name = 1;

    pub fn event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_name(&mut self) {
        self.event_name = ::std::option::Option::None;
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::protobuf::Chars) {
        self.event_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::protobuf::Chars {
        if self.event_name.is_none() {
            self.event_name = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::protobuf::Chars {
        self.event_name.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    // optional int32 eventid = 2;

    pub fn eventid(&self) -> i32 {
        self.eventid.unwrap_or(0)
    }

    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: i32) {
        self.eventid = ::std::option::Option::Some(v);
    }

    // optional int32 passthrough = 4;

    pub fn passthrough(&self) -> i32 {
        self.passthrough.unwrap_or(0)
    }

    pub fn clear_passthrough(&mut self) {
        self.passthrough = ::std::option::Option::None;
    }

    pub fn has_passthrough(&self) -> bool {
        self.passthrough.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passthrough(&mut self, v: i32) {
        self.passthrough = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_name",
            |m: &CSVCMsg_GameEvent| { &m.event_name },
            |m: &mut CSVCMsg_GameEvent| { &mut m.event_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eventid",
            |m: &CSVCMsg_GameEvent| { &m.eventid },
            |m: &mut CSVCMsg_GameEvent| { &mut m.eventid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "keys",
            |m: &CSVCMsg_GameEvent| { &m.keys },
            |m: &mut CSVCMsg_GameEvent| { &mut m.keys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "passthrough",
            |m: &CSVCMsg_GameEvent| { &m.passthrough },
            |m: &mut CSVCMsg_GameEvent| { &mut m.passthrough },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_GameEvent>(
            "CSVCMsg_GameEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_GameEvent {
    const NAME: &'static str = "CSVCMsg_GameEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.event_name = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                16 => {
                    self.eventid = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.keys.push(is.read_message()?);
                },
                32 => {
                    self.passthrough = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.eventid {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.passthrough {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.eventid {
            os.write_int32(2, v)?;
        }
        for v in &self.keys {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.passthrough {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_GameEvent {
        CSVCMsg_GameEvent::new()
    }

    fn clear(&mut self) {
        self.event_name = ::std::option::Option::None;
        self.eventid = ::std::option::Option::None;
        self.keys.clear();
        self.passthrough = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_GameEvent {
        static instance: CSVCMsg_GameEvent = CSVCMsg_GameEvent {
            event_name: ::std::option::Option::None,
            eventid: ::std::option::Option::None,
            keys: ::std::vec::Vec::new(),
            passthrough: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_GameEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_GameEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_GameEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_GameEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSVCMsg_GameEvent`
pub mod csvcmsg_game_event {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CSVCMsg_GameEvent.key_t)
    pub struct Key_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_string)
        pub val_string: ::std::option::Option<::protobuf::Chars>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_float)
        pub val_float: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_long)
        pub val_long: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_short)
        pub val_short: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_byte)
        pub val_byte: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_bool)
        pub val_bool: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_uint64)
        pub val_uint64: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEvent.key_t.val_wstring)
        pub val_wstring: ::std::option::Option<::bytes::Bytes>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_GameEvent.key_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Key_t {
        fn default() -> &'a Key_t {
            <Key_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Key_t {
        pub fn new() -> Key_t {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional string val_string = 2;

        pub fn val_string(&self) -> &str {
            match self.val_string.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_val_string(&mut self) {
            self.val_string = ::std::option::Option::None;
        }

        pub fn has_val_string(&self) -> bool {
            self.val_string.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_string(&mut self, v: ::protobuf::Chars) {
            self.val_string = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_val_string(&mut self) -> &mut ::protobuf::Chars {
            if self.val_string.is_none() {
                self.val_string = ::std::option::Option::Some(::protobuf::Chars::new());
            }
            self.val_string.as_mut().unwrap()
        }

        // Take field
        pub fn take_val_string(&mut self) -> ::protobuf::Chars {
            self.val_string.take().unwrap_or_else(|| ::protobuf::Chars::new())
        }

        // optional float val_float = 3;

        pub fn val_float(&self) -> f32 {
            self.val_float.unwrap_or(0.)
        }

        pub fn clear_val_float(&mut self) {
            self.val_float = ::std::option::Option::None;
        }

        pub fn has_val_float(&self) -> bool {
            self.val_float.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_float(&mut self, v: f32) {
            self.val_float = ::std::option::Option::Some(v);
        }

        // optional int32 val_long = 4;

        pub fn val_long(&self) -> i32 {
            self.val_long.unwrap_or(0)
        }

        pub fn clear_val_long(&mut self) {
            self.val_long = ::std::option::Option::None;
        }

        pub fn has_val_long(&self) -> bool {
            self.val_long.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_long(&mut self, v: i32) {
            self.val_long = ::std::option::Option::Some(v);
        }

        // optional int32 val_short = 5;

        pub fn val_short(&self) -> i32 {
            self.val_short.unwrap_or(0)
        }

        pub fn clear_val_short(&mut self) {
            self.val_short = ::std::option::Option::None;
        }

        pub fn has_val_short(&self) -> bool {
            self.val_short.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_short(&mut self, v: i32) {
            self.val_short = ::std::option::Option::Some(v);
        }

        // optional int32 val_byte = 6;

        pub fn val_byte(&self) -> i32 {
            self.val_byte.unwrap_or(0)
        }

        pub fn clear_val_byte(&mut self) {
            self.val_byte = ::std::option::Option::None;
        }

        pub fn has_val_byte(&self) -> bool {
            self.val_byte.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_byte(&mut self, v: i32) {
            self.val_byte = ::std::option::Option::Some(v);
        }

        // optional bool val_bool = 7;

        pub fn val_bool(&self) -> bool {
            self.val_bool.unwrap_or(false)
        }

        pub fn clear_val_bool(&mut self) {
            self.val_bool = ::std::option::Option::None;
        }

        pub fn has_val_bool(&self) -> bool {
            self.val_bool.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_bool(&mut self, v: bool) {
            self.val_bool = ::std::option::Option::Some(v);
        }

        // optional uint64 val_uint64 = 8;

        pub fn val_uint64(&self) -> u64 {
            self.val_uint64.unwrap_or(0)
        }

        pub fn clear_val_uint64(&mut self) {
            self.val_uint64 = ::std::option::Option::None;
        }

        pub fn has_val_uint64(&self) -> bool {
            self.val_uint64.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_uint64(&mut self, v: u64) {
            self.val_uint64 = ::std::option::Option::Some(v);
        }

        // optional bytes val_wstring = 9;

        pub fn val_wstring(&self) -> &[u8] {
            match self.val_wstring.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_val_wstring(&mut self) {
            self.val_wstring = ::std::option::Option::None;
        }

        pub fn has_val_wstring(&self) -> bool {
            self.val_wstring.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val_wstring(&mut self, v: ::bytes::Bytes) {
            self.val_wstring = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_val_wstring(&mut self) -> &mut ::bytes::Bytes {
            if self.val_wstring.is_none() {
                self.val_wstring = ::std::option::Option::Some(::bytes::Bytes::new());
            }
            self.val_wstring.as_mut().unwrap()
        }

        // Take field
        pub fn take_val_wstring(&mut self) -> ::bytes::Bytes {
            self.val_wstring.take().unwrap_or_else(|| ::bytes::Bytes::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(9);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Key_t| { &m.type_ },
                |m: &mut Key_t| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_string",
                |m: &Key_t| { &m.val_string },
                |m: &mut Key_t| { &mut m.val_string },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_float",
                |m: &Key_t| { &m.val_float },
                |m: &mut Key_t| { &mut m.val_float },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_long",
                |m: &Key_t| { &m.val_long },
                |m: &mut Key_t| { &mut m.val_long },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_short",
                |m: &Key_t| { &m.val_short },
                |m: &mut Key_t| { &mut m.val_short },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_byte",
                |m: &Key_t| { &m.val_byte },
                |m: &mut Key_t| { &mut m.val_byte },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_bool",
                |m: &Key_t| { &m.val_bool },
                |m: &mut Key_t| { &mut m.val_bool },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_uint64",
                |m: &Key_t| { &m.val_uint64 },
                |m: &mut Key_t| { &mut m.val_uint64 },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val_wstring",
                |m: &Key_t| { &m.val_wstring },
                |m: &mut Key_t| { &mut m.val_wstring },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Key_t>(
                "CSVCMsg_GameEvent.key_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Key_t {
        const NAME: &'static str = "key_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.val_string = ::std::option::Option::Some(is.read_tokio_chars()?);
                    },
                    29 => {
                        self.val_float = ::std::option::Option::Some(is.read_float()?);
                    },
                    32 => {
                        self.val_long = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.val_short = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.val_byte = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.val_bool = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.val_uint64 = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    74 => {
                        self.val_wstring = ::std::option::Option::Some(is.read_tokio_bytes()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.val_string.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.val_float {
                my_size += 1 + 4;
            }
            if let Some(v) = self.val_long {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.val_short {
                my_size += ::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.val_byte {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.val_bool {
                my_size += 1 + 1;
            }
            if let Some(v) = self.val_uint64 {
                my_size += ::protobuf::rt::uint64_size(8, v);
            }
            if let Some(v) = self.val_wstring.as_ref() {
                my_size += ::protobuf::rt::bytes_size(9, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.val_string.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.val_float {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.val_long {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.val_short {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.val_byte {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.val_bool {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.val_uint64 {
                os.write_uint64(8, v)?;
            }
            if let Some(v) = self.val_wstring.as_ref() {
                os.write_bytes(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Key_t {
            Key_t::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.val_string = ::std::option::Option::None;
            self.val_float = ::std::option::Option::None;
            self.val_long = ::std::option::Option::None;
            self.val_short = ::std::option::Option::None;
            self.val_byte = ::std::option::Option::None;
            self.val_bool = ::std::option::Option::None;
            self.val_uint64 = ::std::option::Option::None;
            self.val_wstring = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Key_t {
            static instance: Key_t = Key_t {
                type_: ::std::option::Option::None,
                val_string: ::std::option::Option::None,
                val_float: ::std::option::Option::None,
                val_long: ::std::option::Option::None,
                val_short: ::std::option::Option::None,
                val_byte: ::std::option::Option::None,
                val_bool: ::std::option::Option::None,
                val_uint64: ::std::option::Option::None,
                val_wstring: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Key_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_GameEvent.key_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Key_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Key_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_GameEventList)
pub struct CSVCMsg_GameEventList {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_GameEventList.descriptors)
    pub descriptors: ::std::vec::Vec<csvcmsg_game_event_list::Descriptor_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_GameEventList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_GameEventList {
    fn default() -> &'a CSVCMsg_GameEventList {
        <CSVCMsg_GameEventList as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_GameEventList {
    pub fn new() -> CSVCMsg_GameEventList {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "descriptors",
            |m: &CSVCMsg_GameEventList| { &m.descriptors },
            |m: &mut CSVCMsg_GameEventList| { &mut m.descriptors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_GameEventList>(
            "CSVCMsg_GameEventList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_GameEventList {
    const NAME: &'static str = "CSVCMsg_GameEventList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.descriptors.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.descriptors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.descriptors {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_GameEventList {
        CSVCMsg_GameEventList::new()
    }

    fn clear(&mut self) {
        self.descriptors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_GameEventList {
        static instance: CSVCMsg_GameEventList = CSVCMsg_GameEventList {
            descriptors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_GameEventList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_GameEventList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_GameEventList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_GameEventList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSVCMsg_GameEventList`
pub mod csvcmsg_game_event_list {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CSVCMsg_GameEventList.key_t)
    pub struct Key_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.key_t.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.key_t.name)
        pub name: ::std::option::Option<::protobuf::Chars>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_GameEventList.key_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Key_t {
        fn default() -> &'a Key_t {
            <Key_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Key_t {
        pub fn new() -> Key_t {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::protobuf::Chars) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::protobuf::Chars {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::protobuf::Chars::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::protobuf::Chars {
            self.name.take().unwrap_or_else(|| ::protobuf::Chars::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Key_t| { &m.type_ },
                |m: &mut Key_t| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Key_t| { &m.name },
                |m: &mut Key_t| { &mut m.name },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Key_t>(
                "CSVCMsg_GameEventList.key_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Key_t {
        const NAME: &'static str = "key_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_tokio_chars()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Key_t {
            Key_t::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Key_t {
            static instance: Key_t = Key_t {
                type_: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Key_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_GameEventList.key_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Key_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Key_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CSVCMsg_GameEventList.descriptor_t)
    pub struct Descriptor_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.descriptor_t.eventid)
        pub eventid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.descriptor_t.name)
        pub name: ::std::option::Option<::protobuf::Chars>,
        // @@protoc_insertion_point(field:CSVCMsg_GameEventList.descriptor_t.keys)
        pub keys: ::std::vec::Vec<Key_t>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_GameEventList.descriptor_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Descriptor_t {
        fn default() -> &'a Descriptor_t {
            <Descriptor_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Descriptor_t {
        pub fn new() -> Descriptor_t {
            ::std::default::Default::default()
        }

        // optional int32 eventid = 1;

        pub fn eventid(&self) -> i32 {
            self.eventid.unwrap_or(0)
        }

        pub fn clear_eventid(&mut self) {
            self.eventid = ::std::option::Option::None;
        }

        pub fn has_eventid(&self) -> bool {
            self.eventid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eventid(&mut self, v: i32) {
            self.eventid = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::protobuf::Chars) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::protobuf::Chars {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::protobuf::Chars::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::protobuf::Chars {
            self.name.take().unwrap_or_else(|| ::protobuf::Chars::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "eventid",
                |m: &Descriptor_t| { &m.eventid },
                |m: &mut Descriptor_t| { &mut m.eventid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &Descriptor_t| { &m.name },
                |m: &mut Descriptor_t| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "keys",
                |m: &Descriptor_t| { &m.keys },
                |m: &mut Descriptor_t| { &mut m.keys },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Descriptor_t>(
                "CSVCMsg_GameEventList.descriptor_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Descriptor_t {
        const NAME: &'static str = "descriptor_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.eventid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_tokio_chars()?);
                    },
                    26 => {
                        self.keys.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.eventid {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            for value in &self.keys {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.eventid {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            for v in &self.keys {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Descriptor_t {
            Descriptor_t::new()
        }

        fn clear(&mut self) {
            self.eventid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.keys.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Descriptor_t {
            static instance: Descriptor_t = Descriptor_t {
                eventid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                keys: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Descriptor_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_GameEventList.descriptor_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Descriptor_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Descriptor_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_TempEntities)
pub struct CSVCMsg_TempEntities {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_TempEntities.reliable)
    pub reliable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_TempEntities.num_entries)
    pub num_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_TempEntities.entity_data)
    pub entity_data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_TempEntities.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_TempEntities {
    fn default() -> &'a CSVCMsg_TempEntities {
        <CSVCMsg_TempEntities as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_TempEntities {
    pub fn new() -> CSVCMsg_TempEntities {
        ::std::default::Default::default()
    }

    // optional bool reliable = 1;

    pub fn reliable(&self) -> bool {
        self.reliable.unwrap_or(false)
    }

    pub fn clear_reliable(&mut self) {
        self.reliable = ::std::option::Option::None;
    }

    pub fn has_reliable(&self) -> bool {
        self.reliable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable(&mut self, v: bool) {
        self.reliable = ::std::option::Option::Some(v);
    }

    // optional int32 num_entries = 2;

    pub fn num_entries(&self) -> i32 {
        self.num_entries.unwrap_or(0)
    }

    pub fn clear_num_entries(&mut self) {
        self.num_entries = ::std::option::Option::None;
    }

    pub fn has_num_entries(&self) -> bool {
        self.num_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_entries(&mut self, v: i32) {
        self.num_entries = ::std::option::Option::Some(v);
    }

    // optional bytes entity_data = 3;

    pub fn entity_data(&self) -> &[u8] {
        match self.entity_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_entity_data(&mut self) {
        self.entity_data = ::std::option::Option::None;
    }

    pub fn has_entity_data(&self) -> bool {
        self.entity_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_data(&mut self, v: ::bytes::Bytes) {
        self.entity_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_data(&mut self) -> &mut ::bytes::Bytes {
        if self.entity_data.is_none() {
            self.entity_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.entity_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_entity_data(&mut self) -> ::bytes::Bytes {
        self.entity_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reliable",
            |m: &CSVCMsg_TempEntities| { &m.reliable },
            |m: &mut CSVCMsg_TempEntities| { &mut m.reliable },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "num_entries",
            |m: &CSVCMsg_TempEntities| { &m.num_entries },
            |m: &mut CSVCMsg_TempEntities| { &mut m.num_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_data",
            |m: &CSVCMsg_TempEntities| { &m.entity_data },
            |m: &mut CSVCMsg_TempEntities| { &mut m.entity_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_TempEntities>(
            "CSVCMsg_TempEntities",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_TempEntities {
    const NAME: &'static str = "CSVCMsg_TempEntities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reliable = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.num_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.entity_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reliable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.num_entries {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.entity_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reliable {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.num_entries {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.entity_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_TempEntities {
        CSVCMsg_TempEntities::new()
    }

    fn clear(&mut self) {
        self.reliable = ::std::option::Option::None;
        self.num_entries = ::std::option::Option::None;
        self.entity_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_TempEntities {
        static instance: CSVCMsg_TempEntities = CSVCMsg_TempEntities {
            reliable: ::std::option::Option::None,
            num_entries: ::std::option::Option::None,
            entity_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_TempEntities {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_TempEntities").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_TempEntities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_TempEntities {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_PacketEntities)
pub struct CSVCMsg_PacketEntities {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.max_entries)
    pub max_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.updated_entries)
    pub updated_entries: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.is_delta)
    pub is_delta: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.update_baseline)
    pub update_baseline: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.baseline)
    pub baseline: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.delta_from)
    pub delta_from: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_PacketEntities.entity_data)
    pub entity_data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_PacketEntities.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_PacketEntities {
    fn default() -> &'a CSVCMsg_PacketEntities {
        <CSVCMsg_PacketEntities as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_PacketEntities {
    pub fn new() -> CSVCMsg_PacketEntities {
        ::std::default::Default::default()
    }

    // optional int32 max_entries = 1;

    pub fn max_entries(&self) -> i32 {
        self.max_entries.unwrap_or(0)
    }

    pub fn clear_max_entries(&mut self) {
        self.max_entries = ::std::option::Option::None;
    }

    pub fn has_max_entries(&self) -> bool {
        self.max_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_entries(&mut self, v: i32) {
        self.max_entries = ::std::option::Option::Some(v);
    }

    // optional int32 updated_entries = 2;

    pub fn updated_entries(&self) -> i32 {
        self.updated_entries.unwrap_or(0)
    }

    pub fn clear_updated_entries(&mut self) {
        self.updated_entries = ::std::option::Option::None;
    }

    pub fn has_updated_entries(&self) -> bool {
        self.updated_entries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updated_entries(&mut self, v: i32) {
        self.updated_entries = ::std::option::Option::Some(v);
    }

    // optional bool is_delta = 3;

    pub fn is_delta(&self) -> bool {
        self.is_delta.unwrap_or(false)
    }

    pub fn clear_is_delta(&mut self) {
        self.is_delta = ::std::option::Option::None;
    }

    pub fn has_is_delta(&self) -> bool {
        self.is_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_delta(&mut self, v: bool) {
        self.is_delta = ::std::option::Option::Some(v);
    }

    // optional bool update_baseline = 4;

    pub fn update_baseline(&self) -> bool {
        self.update_baseline.unwrap_or(false)
    }

    pub fn clear_update_baseline(&mut self) {
        self.update_baseline = ::std::option::Option::None;
    }

    pub fn has_update_baseline(&self) -> bool {
        self.update_baseline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_baseline(&mut self, v: bool) {
        self.update_baseline = ::std::option::Option::Some(v);
    }

    // optional int32 baseline = 5;

    pub fn baseline(&self) -> i32 {
        self.baseline.unwrap_or(0)
    }

    pub fn clear_baseline(&mut self) {
        self.baseline = ::std::option::Option::None;
    }

    pub fn has_baseline(&self) -> bool {
        self.baseline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseline(&mut self, v: i32) {
        self.baseline = ::std::option::Option::Some(v);
    }

    // optional int32 delta_from = 6;

    pub fn delta_from(&self) -> i32 {
        self.delta_from.unwrap_or(0)
    }

    pub fn clear_delta_from(&mut self) {
        self.delta_from = ::std::option::Option::None;
    }

    pub fn has_delta_from(&self) -> bool {
        self.delta_from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta_from(&mut self, v: i32) {
        self.delta_from = ::std::option::Option::Some(v);
    }

    // optional bytes entity_data = 7;

    pub fn entity_data(&self) -> &[u8] {
        match self.entity_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_entity_data(&mut self) {
        self.entity_data = ::std::option::Option::None;
    }

    pub fn has_entity_data(&self) -> bool {
        self.entity_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_data(&mut self, v: ::bytes::Bytes) {
        self.entity_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity_data(&mut self) -> &mut ::bytes::Bytes {
        if self.entity_data.is_none() {
            self.entity_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.entity_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_entity_data(&mut self) -> ::bytes::Bytes {
        self.entity_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "max_entries",
            |m: &CSVCMsg_PacketEntities| { &m.max_entries },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.max_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "updated_entries",
            |m: &CSVCMsg_PacketEntities| { &m.updated_entries },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.updated_entries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "is_delta",
            |m: &CSVCMsg_PacketEntities| { &m.is_delta },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.is_delta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "update_baseline",
            |m: &CSVCMsg_PacketEntities| { &m.update_baseline },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.update_baseline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "baseline",
            |m: &CSVCMsg_PacketEntities| { &m.baseline },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.baseline },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delta_from",
            |m: &CSVCMsg_PacketEntities| { &m.delta_from },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.delta_from },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entity_data",
            |m: &CSVCMsg_PacketEntities| { &m.entity_data },
            |m: &mut CSVCMsg_PacketEntities| { &mut m.entity_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_PacketEntities>(
            "CSVCMsg_PacketEntities",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_PacketEntities {
    const NAME: &'static str = "CSVCMsg_PacketEntities";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.max_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.updated_entries = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.is_delta = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.update_baseline = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.baseline = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.delta_from = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    self.entity_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.max_entries {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.updated_entries {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.is_delta {
            my_size += 1 + 1;
        }
        if let Some(v) = self.update_baseline {
            my_size += 1 + 1;
        }
        if let Some(v) = self.baseline {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.delta_from {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.entity_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.max_entries {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.updated_entries {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.is_delta {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.update_baseline {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.baseline {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.delta_from {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.entity_data.as_ref() {
            os.write_bytes(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_PacketEntities {
        CSVCMsg_PacketEntities::new()
    }

    fn clear(&mut self) {
        self.max_entries = ::std::option::Option::None;
        self.updated_entries = ::std::option::Option::None;
        self.is_delta = ::std::option::Option::None;
        self.update_baseline = ::std::option::Option::None;
        self.baseline = ::std::option::Option::None;
        self.delta_from = ::std::option::Option::None;
        self.entity_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_PacketEntities {
        static instance: CSVCMsg_PacketEntities = CSVCMsg_PacketEntities {
            max_entries: ::std::option::Option::None,
            updated_entries: ::std::option::Option::None,
            is_delta: ::std::option::Option::None,
            update_baseline: ::std::option::Option::None,
            baseline: ::std::option::Option::None,
            delta_from: ::std::option::Option::None,
            entity_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_PacketEntities {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_PacketEntities").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_PacketEntities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_PacketEntities {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_Sounds)
pub struct CSVCMsg_Sounds {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_Sounds.reliable_sound)
    pub reliable_sound: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounds)
    pub sounds: ::std::vec::Vec<csvcmsg_sounds::Sounddata_t>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_Sounds.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_Sounds {
    fn default() -> &'a CSVCMsg_Sounds {
        <CSVCMsg_Sounds as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_Sounds {
    pub fn new() -> CSVCMsg_Sounds {
        ::std::default::Default::default()
    }

    // optional bool reliable_sound = 1;

    pub fn reliable_sound(&self) -> bool {
        self.reliable_sound.unwrap_or(false)
    }

    pub fn clear_reliable_sound(&mut self) {
        self.reliable_sound = ::std::option::Option::None;
    }

    pub fn has_reliable_sound(&self) -> bool {
        self.reliable_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reliable_sound(&mut self, v: bool) {
        self.reliable_sound = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reliable_sound",
            |m: &CSVCMsg_Sounds| { &m.reliable_sound },
            |m: &mut CSVCMsg_Sounds| { &mut m.reliable_sound },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sounds",
            |m: &CSVCMsg_Sounds| { &m.sounds },
            |m: &mut CSVCMsg_Sounds| { &mut m.sounds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_Sounds>(
            "CSVCMsg_Sounds",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_Sounds {
    const NAME: &'static str = "CSVCMsg_Sounds";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reliable_sound = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.sounds.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reliable_sound {
            my_size += 1 + 1;
        }
        for value in &self.sounds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reliable_sound {
            os.write_bool(1, v)?;
        }
        for v in &self.sounds {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_Sounds {
        CSVCMsg_Sounds::new()
    }

    fn clear(&mut self) {
        self.reliable_sound = ::std::option::Option::None;
        self.sounds.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_Sounds {
        static instance: CSVCMsg_Sounds = CSVCMsg_Sounds {
            reliable_sound: ::std::option::Option::None,
            sounds: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_Sounds {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_Sounds").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_Sounds {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_Sounds {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CSVCMsg_Sounds`
pub mod csvcmsg_sounds {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CSVCMsg_Sounds.sounddata_t)
    pub struct Sounddata_t {
        // message fields
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.origin_x)
        pub origin_x: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.origin_y)
        pub origin_y: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.origin_z)
        pub origin_z: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.volume)
        pub volume: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.delay_value)
        pub delay_value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sequence_number)
        pub sequence_number: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.entity_index)
        pub entity_index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.channel)
        pub channel: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.pitch)
        pub pitch: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.flags)
        pub flags: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sound_num)
        pub sound_num: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sound_num_handle)
        pub sound_num_handle: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.speaker_entity)
        pub speaker_entity: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.random_seed)
        pub random_seed: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.sound_level)
        pub sound_level: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.is_sentence)
        pub is_sentence: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CSVCMsg_Sounds.sounddata_t.is_ambient)
        pub is_ambient: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CSVCMsg_Sounds.sounddata_t.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Sounddata_t {
        fn default() -> &'a Sounddata_t {
            <Sounddata_t as ::protobuf::Message>::default_instance()
        }
    }

    impl Sounddata_t {
        pub fn new() -> Sounddata_t {
            ::std::default::Default::default()
        }

        // optional sint32 origin_x = 1;

        pub fn origin_x(&self) -> i32 {
            self.origin_x.unwrap_or(0)
        }

        pub fn clear_origin_x(&mut self) {
            self.origin_x = ::std::option::Option::None;
        }

        pub fn has_origin_x(&self) -> bool {
            self.origin_x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_x(&mut self, v: i32) {
            self.origin_x = ::std::option::Option::Some(v);
        }

        // optional sint32 origin_y = 2;

        pub fn origin_y(&self) -> i32 {
            self.origin_y.unwrap_or(0)
        }

        pub fn clear_origin_y(&mut self) {
            self.origin_y = ::std::option::Option::None;
        }

        pub fn has_origin_y(&self) -> bool {
            self.origin_y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_y(&mut self, v: i32) {
            self.origin_y = ::std::option::Option::Some(v);
        }

        // optional sint32 origin_z = 3;

        pub fn origin_z(&self) -> i32 {
            self.origin_z.unwrap_or(0)
        }

        pub fn clear_origin_z(&mut self) {
            self.origin_z = ::std::option::Option::None;
        }

        pub fn has_origin_z(&self) -> bool {
            self.origin_z.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_z(&mut self, v: i32) {
            self.origin_z = ::std::option::Option::Some(v);
        }

        // optional uint32 volume = 4;

        pub fn volume(&self) -> u32 {
            self.volume.unwrap_or(0)
        }

        pub fn clear_volume(&mut self) {
            self.volume = ::std::option::Option::None;
        }

        pub fn has_volume(&self) -> bool {
            self.volume.is_some()
        }

        // Param is passed by value, moved
        pub fn set_volume(&mut self, v: u32) {
            self.volume = ::std::option::Option::Some(v);
        }

        // optional float delay_value = 5;

        pub fn delay_value(&self) -> f32 {
            self.delay_value.unwrap_or(0.)
        }

        pub fn clear_delay_value(&mut self) {
            self.delay_value = ::std::option::Option::None;
        }

        pub fn has_delay_value(&self) -> bool {
            self.delay_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_delay_value(&mut self, v: f32) {
            self.delay_value = ::std::option::Option::Some(v);
        }

        // optional int32 sequence_number = 6;

        pub fn sequence_number(&self) -> i32 {
            self.sequence_number.unwrap_or(0)
        }

        pub fn clear_sequence_number(&mut self) {
            self.sequence_number = ::std::option::Option::None;
        }

        pub fn has_sequence_number(&self) -> bool {
            self.sequence_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sequence_number(&mut self, v: i32) {
            self.sequence_number = ::std::option::Option::Some(v);
        }

        // optional int32 entity_index = 7;

        pub fn entity_index(&self) -> i32 {
            self.entity_index.unwrap_or(0)
        }

        pub fn clear_entity_index(&mut self) {
            self.entity_index = ::std::option::Option::None;
        }

        pub fn has_entity_index(&self) -> bool {
            self.entity_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_index(&mut self, v: i32) {
            self.entity_index = ::std::option::Option::Some(v);
        }

        // optional int32 channel = 8;

        pub fn channel(&self) -> i32 {
            self.channel.unwrap_or(0)
        }

        pub fn clear_channel(&mut self) {
            self.channel = ::std::option::Option::None;
        }

        pub fn has_channel(&self) -> bool {
            self.channel.is_some()
        }

        // Param is passed by value, moved
        pub fn set_channel(&mut self, v: i32) {
            self.channel = ::std::option::Option::Some(v);
        }

        // optional int32 pitch = 9;

        pub fn pitch(&self) -> i32 {
            self.pitch.unwrap_or(0)
        }

        pub fn clear_pitch(&mut self) {
            self.pitch = ::std::option::Option::None;
        }

        pub fn has_pitch(&self) -> bool {
            self.pitch.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pitch(&mut self, v: i32) {
            self.pitch = ::std::option::Option::Some(v);
        }

        // optional int32 flags = 10;

        pub fn flags(&self) -> i32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: i32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional uint32 sound_num = 11;

        pub fn sound_num(&self) -> u32 {
            self.sound_num.unwrap_or(0)
        }

        pub fn clear_sound_num(&mut self) {
            self.sound_num = ::std::option::Option::None;
        }

        pub fn has_sound_num(&self) -> bool {
            self.sound_num.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sound_num(&mut self, v: u32) {
            self.sound_num = ::std::option::Option::Some(v);
        }

        // optional fixed32 sound_num_handle = 12;

        pub fn sound_num_handle(&self) -> u32 {
            self.sound_num_handle.unwrap_or(0)
        }

        pub fn clear_sound_num_handle(&mut self) {
            self.sound_num_handle = ::std::option::Option::None;
        }

        pub fn has_sound_num_handle(&self) -> bool {
            self.sound_num_handle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sound_num_handle(&mut self, v: u32) {
            self.sound_num_handle = ::std::option::Option::Some(v);
        }

        // optional int32 speaker_entity = 13;

        pub fn speaker_entity(&self) -> i32 {
            self.speaker_entity.unwrap_or(0)
        }

        pub fn clear_speaker_entity(&mut self) {
            self.speaker_entity = ::std::option::Option::None;
        }

        pub fn has_speaker_entity(&self) -> bool {
            self.speaker_entity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_speaker_entity(&mut self, v: i32) {
            self.speaker_entity = ::std::option::Option::Some(v);
        }

        // optional int32 random_seed = 14;

        pub fn random_seed(&self) -> i32 {
            self.random_seed.unwrap_or(0)
        }

        pub fn clear_random_seed(&mut self) {
            self.random_seed = ::std::option::Option::None;
        }

        pub fn has_random_seed(&self) -> bool {
            self.random_seed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_random_seed(&mut self, v: i32) {
            self.random_seed = ::std::option::Option::Some(v);
        }

        // optional int32 sound_level = 15;

        pub fn sound_level(&self) -> i32 {
            self.sound_level.unwrap_or(0)
        }

        pub fn clear_sound_level(&mut self) {
            self.sound_level = ::std::option::Option::None;
        }

        pub fn has_sound_level(&self) -> bool {
            self.sound_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sound_level(&mut self, v: i32) {
            self.sound_level = ::std::option::Option::Some(v);
        }

        // optional bool is_sentence = 16;

        pub fn is_sentence(&self) -> bool {
            self.is_sentence.unwrap_or(false)
        }

        pub fn clear_is_sentence(&mut self) {
            self.is_sentence = ::std::option::Option::None;
        }

        pub fn has_is_sentence(&self) -> bool {
            self.is_sentence.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_sentence(&mut self, v: bool) {
            self.is_sentence = ::std::option::Option::Some(v);
        }

        // optional bool is_ambient = 17;

        pub fn is_ambient(&self) -> bool {
            self.is_ambient.unwrap_or(false)
        }

        pub fn clear_is_ambient(&mut self) {
            self.is_ambient = ::std::option::Option::None;
        }

        pub fn has_is_ambient(&self) -> bool {
            self.is_ambient.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_ambient(&mut self, v: bool) {
            self.is_ambient = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(17);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "origin_x",
                |m: &Sounddata_t| { &m.origin_x },
                |m: &mut Sounddata_t| { &mut m.origin_x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "origin_y",
                |m: &Sounddata_t| { &m.origin_y },
                |m: &mut Sounddata_t| { &mut m.origin_y },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "origin_z",
                |m: &Sounddata_t| { &m.origin_z },
                |m: &mut Sounddata_t| { &mut m.origin_z },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "volume",
                |m: &Sounddata_t| { &m.volume },
                |m: &mut Sounddata_t| { &mut m.volume },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "delay_value",
                |m: &Sounddata_t| { &m.delay_value },
                |m: &mut Sounddata_t| { &mut m.delay_value },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sequence_number",
                |m: &Sounddata_t| { &m.sequence_number },
                |m: &mut Sounddata_t| { &mut m.sequence_number },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "entity_index",
                |m: &Sounddata_t| { &m.entity_index },
                |m: &mut Sounddata_t| { &mut m.entity_index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "channel",
                |m: &Sounddata_t| { &m.channel },
                |m: &mut Sounddata_t| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pitch",
                |m: &Sounddata_t| { &m.pitch },
                |m: &mut Sounddata_t| { &mut m.pitch },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "flags",
                |m: &Sounddata_t| { &m.flags },
                |m: &mut Sounddata_t| { &mut m.flags },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sound_num",
                |m: &Sounddata_t| { &m.sound_num },
                |m: &mut Sounddata_t| { &mut m.sound_num },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sound_num_handle",
                |m: &Sounddata_t| { &m.sound_num_handle },
                |m: &mut Sounddata_t| { &mut m.sound_num_handle },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "speaker_entity",
                |m: &Sounddata_t| { &m.speaker_entity },
                |m: &mut Sounddata_t| { &mut m.speaker_entity },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "random_seed",
                |m: &Sounddata_t| { &m.random_seed },
                |m: &mut Sounddata_t| { &mut m.random_seed },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sound_level",
                |m: &Sounddata_t| { &m.sound_level },
                |m: &mut Sounddata_t| { &mut m.sound_level },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_sentence",
                |m: &Sounddata_t| { &m.is_sentence },
                |m: &mut Sounddata_t| { &mut m.is_sentence },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_ambient",
                |m: &Sounddata_t| { &m.is_ambient },
                |m: &mut Sounddata_t| { &mut m.is_ambient },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sounddata_t>(
                "CSVCMsg_Sounds.sounddata_t",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Sounddata_t {
        const NAME: &'static str = "sounddata_t";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.origin_x = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    16 => {
                        self.origin_y = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    24 => {
                        self.origin_z = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    32 => {
                        self.volume = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    45 => {
                        self.delay_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    48 => {
                        self.sequence_number = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.channel = ::std::option::Option::Some(is.read_int32()?);
                    },
                    72 => {
                        self.pitch = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.flags = ::std::option::Option::Some(is.read_int32()?);
                    },
                    88 => {
                        self.sound_num = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    101 => {
                        self.sound_num_handle = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    104 => {
                        self.speaker_entity = ::std::option::Option::Some(is.read_int32()?);
                    },
                    112 => {
                        self.random_seed = ::std::option::Option::Some(is.read_int32()?);
                    },
                    120 => {
                        self.sound_level = ::std::option::Option::Some(is.read_int32()?);
                    },
                    128 => {
                        self.is_sentence = ::std::option::Option::Some(is.read_bool()?);
                    },
                    136 => {
                        self.is_ambient = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.origin_x {
                my_size += ::protobuf::rt::sint32_size(1, v);
            }
            if let Some(v) = self.origin_y {
                my_size += ::protobuf::rt::sint32_size(2, v);
            }
            if let Some(v) = self.origin_z {
                my_size += ::protobuf::rt::sint32_size(3, v);
            }
            if let Some(v) = self.volume {
                my_size += ::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.delay_value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.sequence_number {
                my_size += ::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.entity_index {
                my_size += ::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.channel {
                my_size += ::protobuf::rt::int32_size(8, v);
            }
            if let Some(v) = self.pitch {
                my_size += ::protobuf::rt::int32_size(9, v);
            }
            if let Some(v) = self.flags {
                my_size += ::protobuf::rt::int32_size(10, v);
            }
            if let Some(v) = self.sound_num {
                my_size += ::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.sound_num_handle {
                my_size += 1 + 4;
            }
            if let Some(v) = self.speaker_entity {
                my_size += ::protobuf::rt::int32_size(13, v);
            }
            if let Some(v) = self.random_seed {
                my_size += ::protobuf::rt::int32_size(14, v);
            }
            if let Some(v) = self.sound_level {
                my_size += ::protobuf::rt::int32_size(15, v);
            }
            if let Some(v) = self.is_sentence {
                my_size += 2 + 1;
            }
            if let Some(v) = self.is_ambient {
                my_size += 2 + 1;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.origin_x {
                os.write_sint32(1, v)?;
            }
            if let Some(v) = self.origin_y {
                os.write_sint32(2, v)?;
            }
            if let Some(v) = self.origin_z {
                os.write_sint32(3, v)?;
            }
            if let Some(v) = self.volume {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.delay_value {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.sequence_number {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.entity_index {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.channel {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.pitch {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.flags {
                os.write_int32(10, v)?;
            }
            if let Some(v) = self.sound_num {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.sound_num_handle {
                os.write_fixed32(12, v)?;
            }
            if let Some(v) = self.speaker_entity {
                os.write_int32(13, v)?;
            }
            if let Some(v) = self.random_seed {
                os.write_int32(14, v)?;
            }
            if let Some(v) = self.sound_level {
                os.write_int32(15, v)?;
            }
            if let Some(v) = self.is_sentence {
                os.write_bool(16, v)?;
            }
            if let Some(v) = self.is_ambient {
                os.write_bool(17, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Sounddata_t {
            Sounddata_t::new()
        }

        fn clear(&mut self) {
            self.origin_x = ::std::option::Option::None;
            self.origin_y = ::std::option::Option::None;
            self.origin_z = ::std::option::Option::None;
            self.volume = ::std::option::Option::None;
            self.delay_value = ::std::option::Option::None;
            self.sequence_number = ::std::option::Option::None;
            self.entity_index = ::std::option::Option::None;
            self.channel = ::std::option::Option::None;
            self.pitch = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.sound_num = ::std::option::Option::None;
            self.sound_num_handle = ::std::option::Option::None;
            self.speaker_entity = ::std::option::Option::None;
            self.random_seed = ::std::option::Option::None;
            self.sound_level = ::std::option::Option::None;
            self.is_sentence = ::std::option::Option::None;
            self.is_ambient = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Sounddata_t {
            static instance: Sounddata_t = Sounddata_t {
                origin_x: ::std::option::Option::None,
                origin_y: ::std::option::Option::None,
                origin_z: ::std::option::Option::None,
                volume: ::std::option::Option::None,
                delay_value: ::std::option::Option::None,
                sequence_number: ::std::option::Option::None,
                entity_index: ::std::option::Option::None,
                channel: ::std::option::Option::None,
                pitch: ::std::option::Option::None,
                flags: ::std::option::Option::None,
                sound_num: ::std::option::Option::None,
                sound_num_handle: ::std::option::Option::None,
                speaker_entity: ::std::option::Option::None,
                random_seed: ::std::option::Option::None,
                sound_level: ::std::option::Option::None,
                is_sentence: ::std::option::Option::None,
                is_ambient: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Sounddata_t {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CSVCMsg_Sounds.sounddata_t").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Sounddata_t {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Sounddata_t {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_EntityMessage)
pub struct CSVCMsg_EntityMessage {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_EntityMessage.ent_index)
    pub ent_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_EntityMessage.class_id)
    pub class_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_EntityMessage.ent_data)
    pub ent_data: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_EntityMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_EntityMessage {
    fn default() -> &'a CSVCMsg_EntityMessage {
        <CSVCMsg_EntityMessage as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_EntityMessage {
    pub fn new() -> CSVCMsg_EntityMessage {
        ::std::default::Default::default()
    }

    // optional int32 ent_index = 1;

    pub fn ent_index(&self) -> i32 {
        self.ent_index.unwrap_or(0)
    }

    pub fn clear_ent_index(&mut self) {
        self.ent_index = ::std::option::Option::None;
    }

    pub fn has_ent_index(&self) -> bool {
        self.ent_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_index(&mut self, v: i32) {
        self.ent_index = ::std::option::Option::Some(v);
    }

    // optional int32 class_id = 2;

    pub fn class_id(&self) -> i32 {
        self.class_id.unwrap_or(0)
    }

    pub fn clear_class_id(&mut self) {
        self.class_id = ::std::option::Option::None;
    }

    pub fn has_class_id(&self) -> bool {
        self.class_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_class_id(&mut self, v: i32) {
        self.class_id = ::std::option::Option::Some(v);
    }

    // optional bytes ent_data = 3;

    pub fn ent_data(&self) -> &[u8] {
        match self.ent_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_ent_data(&mut self) {
        self.ent_data = ::std::option::Option::None;
    }

    pub fn has_ent_data(&self) -> bool {
        self.ent_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_data(&mut self, v: ::bytes::Bytes) {
        self.ent_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ent_data(&mut self) -> &mut ::bytes::Bytes {
        if self.ent_data.is_none() {
            self.ent_data = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.ent_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_ent_data(&mut self) -> ::bytes::Bytes {
        self.ent_data.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ent_index",
            |m: &CSVCMsg_EntityMessage| { &m.ent_index },
            |m: &mut CSVCMsg_EntityMessage| { &mut m.ent_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "class_id",
            |m: &CSVCMsg_EntityMessage| { &m.class_id },
            |m: &mut CSVCMsg_EntityMessage| { &mut m.class_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ent_data",
            |m: &CSVCMsg_EntityMessage| { &m.ent_data },
            |m: &mut CSVCMsg_EntityMessage| { &mut m.ent_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_EntityMessage>(
            "CSVCMsg_EntityMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_EntityMessage {
    const NAME: &'static str = "CSVCMsg_EntityMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ent_index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.class_id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.ent_data = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ent_index {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.class_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.ent_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ent_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.class_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ent_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_EntityMessage {
        CSVCMsg_EntityMessage::new()
    }

    fn clear(&mut self) {
        self.ent_index = ::std::option::Option::None;
        self.class_id = ::std::option::Option::None;
        self.ent_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_EntityMessage {
        static instance: CSVCMsg_EntityMessage = CSVCMsg_EntityMessage {
            ent_index: ::std::option::Option::None,
            class_id: ::std::option::Option::None,
            ent_data: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_EntityMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_EntityMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_EntityMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_EntityMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_CmdKeyValues)
pub struct CSVCMsg_CmdKeyValues {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_CmdKeyValues.keyvalues)
    pub keyvalues: ::std::option::Option<::bytes::Bytes>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_CmdKeyValues.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_CmdKeyValues {
    fn default() -> &'a CSVCMsg_CmdKeyValues {
        <CSVCMsg_CmdKeyValues as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_CmdKeyValues {
    pub fn new() -> CSVCMsg_CmdKeyValues {
        ::std::default::Default::default()
    }

    // optional bytes keyvalues = 1;

    pub fn keyvalues(&self) -> &[u8] {
        match self.keyvalues.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_keyvalues(&mut self) {
        self.keyvalues = ::std::option::Option::None;
    }

    pub fn has_keyvalues(&self) -> bool {
        self.keyvalues.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyvalues(&mut self, v: ::bytes::Bytes) {
        self.keyvalues = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyvalues(&mut self) -> &mut ::bytes::Bytes {
        if self.keyvalues.is_none() {
            self.keyvalues = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.keyvalues.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyvalues(&mut self) -> ::bytes::Bytes {
        self.keyvalues.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "keyvalues",
            |m: &CSVCMsg_CmdKeyValues| { &m.keyvalues },
            |m: &mut CSVCMsg_CmdKeyValues| { &mut m.keyvalues },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_CmdKeyValues>(
            "CSVCMsg_CmdKeyValues",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_CmdKeyValues {
    const NAME: &'static str = "CSVCMsg_CmdKeyValues";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.keyvalues = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.keyvalues.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.keyvalues.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_CmdKeyValues {
        CSVCMsg_CmdKeyValues::new()
    }

    fn clear(&mut self) {
        self.keyvalues = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_CmdKeyValues {
        static instance: CSVCMsg_CmdKeyValues = CSVCMsg_CmdKeyValues {
            keyvalues: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_CmdKeyValues {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_CmdKeyValues").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_CmdKeyValues {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_CmdKeyValues {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_EncryptedData)
pub struct CSVCMsg_EncryptedData {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_EncryptedData.encrypted)
    pub encrypted: ::std::option::Option<::bytes::Bytes>,
    // @@protoc_insertion_point(field:CSVCMsg_EncryptedData.key_type)
    pub key_type: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_EncryptedData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_EncryptedData {
    fn default() -> &'a CSVCMsg_EncryptedData {
        <CSVCMsg_EncryptedData as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_EncryptedData {
    pub fn new() -> CSVCMsg_EncryptedData {
        ::std::default::Default::default()
    }

    // optional bytes encrypted = 1;

    pub fn encrypted(&self) -> &[u8] {
        match self.encrypted.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_encrypted(&mut self) {
        self.encrypted = ::std::option::Option::None;
    }

    pub fn has_encrypted(&self) -> bool {
        self.encrypted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted(&mut self, v: ::bytes::Bytes) {
        self.encrypted = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted(&mut self) -> &mut ::bytes::Bytes {
        if self.encrypted.is_none() {
            self.encrypted = ::std::option::Option::Some(::bytes::Bytes::new());
        }
        self.encrypted.as_mut().unwrap()
    }

    // Take field
    pub fn take_encrypted(&mut self) -> ::bytes::Bytes {
        self.encrypted.take().unwrap_or_else(|| ::bytes::Bytes::new())
    }

    // optional int32 key_type = 2;

    pub fn key_type(&self) -> i32 {
        self.key_type.unwrap_or(0)
    }

    pub fn clear_key_type(&mut self) {
        self.key_type = ::std::option::Option::None;
    }

    pub fn has_key_type(&self) -> bool {
        self.key_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_type(&mut self, v: i32) {
        self.key_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encrypted",
            |m: &CSVCMsg_EncryptedData| { &m.encrypted },
            |m: &mut CSVCMsg_EncryptedData| { &mut m.encrypted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "key_type",
            |m: &CSVCMsg_EncryptedData| { &m.key_type },
            |m: &mut CSVCMsg_EncryptedData| { &mut m.key_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_EncryptedData>(
            "CSVCMsg_EncryptedData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_EncryptedData {
    const NAME: &'static str = "CSVCMsg_EncryptedData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.encrypted = ::std::option::Option::Some(is.read_tokio_bytes()?);
                },
                16 => {
                    self.key_type = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.encrypted.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.key_type {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.encrypted.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.key_type {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_EncryptedData {
        CSVCMsg_EncryptedData::new()
    }

    fn clear(&mut self) {
        self.encrypted = ::std::option::Option::None;
        self.key_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_EncryptedData {
        static instance: CSVCMsg_EncryptedData = CSVCMsg_EncryptedData {
            encrypted: ::std::option::Option::None,
            key_type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_EncryptedData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_EncryptedData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_EncryptedData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_EncryptedData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_HltvReplay)
pub struct CSVCMsg_HltvReplay {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.delay)
    pub delay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.primary_target)
    pub primary_target: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_stop_at)
    pub replay_stop_at: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_start_at)
    pub replay_start_at: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_slowdown_begin)
    pub replay_slowdown_begin: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_slowdown_end)
    pub replay_slowdown_end: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSVCMsg_HltvReplay.replay_slowdown_rate)
    pub replay_slowdown_rate: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_HltvReplay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_HltvReplay {
    fn default() -> &'a CSVCMsg_HltvReplay {
        <CSVCMsg_HltvReplay as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_HltvReplay {
    pub fn new() -> CSVCMsg_HltvReplay {
        ::std::default::Default::default()
    }

    // optional int32 delay = 1;

    pub fn delay(&self) -> i32 {
        self.delay.unwrap_or(0)
    }

    pub fn clear_delay(&mut self) {
        self.delay = ::std::option::Option::None;
    }

    pub fn has_delay(&self) -> bool {
        self.delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delay(&mut self, v: i32) {
        self.delay = ::std::option::Option::Some(v);
    }

    // optional int32 primary_target = 2;

    pub fn primary_target(&self) -> i32 {
        self.primary_target.unwrap_or(0)
    }

    pub fn clear_primary_target(&mut self) {
        self.primary_target = ::std::option::Option::None;
    }

    pub fn has_primary_target(&self) -> bool {
        self.primary_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_target(&mut self, v: i32) {
        self.primary_target = ::std::option::Option::Some(v);
    }

    // optional int32 replay_stop_at = 3;

    pub fn replay_stop_at(&self) -> i32 {
        self.replay_stop_at.unwrap_or(0)
    }

    pub fn clear_replay_stop_at(&mut self) {
        self.replay_stop_at = ::std::option::Option::None;
    }

    pub fn has_replay_stop_at(&self) -> bool {
        self.replay_stop_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_stop_at(&mut self, v: i32) {
        self.replay_stop_at = ::std::option::Option::Some(v);
    }

    // optional int32 replay_start_at = 4;

    pub fn replay_start_at(&self) -> i32 {
        self.replay_start_at.unwrap_or(0)
    }

    pub fn clear_replay_start_at(&mut self) {
        self.replay_start_at = ::std::option::Option::None;
    }

    pub fn has_replay_start_at(&self) -> bool {
        self.replay_start_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_start_at(&mut self, v: i32) {
        self.replay_start_at = ::std::option::Option::Some(v);
    }

    // optional int32 replay_slowdown_begin = 5;

    pub fn replay_slowdown_begin(&self) -> i32 {
        self.replay_slowdown_begin.unwrap_or(0)
    }

    pub fn clear_replay_slowdown_begin(&mut self) {
        self.replay_slowdown_begin = ::std::option::Option::None;
    }

    pub fn has_replay_slowdown_begin(&self) -> bool {
        self.replay_slowdown_begin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_slowdown_begin(&mut self, v: i32) {
        self.replay_slowdown_begin = ::std::option::Option::Some(v);
    }

    // optional int32 replay_slowdown_end = 6;

    pub fn replay_slowdown_end(&self) -> i32 {
        self.replay_slowdown_end.unwrap_or(0)
    }

    pub fn clear_replay_slowdown_end(&mut self) {
        self.replay_slowdown_end = ::std::option::Option::None;
    }

    pub fn has_replay_slowdown_end(&self) -> bool {
        self.replay_slowdown_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_slowdown_end(&mut self, v: i32) {
        self.replay_slowdown_end = ::std::option::Option::Some(v);
    }

    // optional float replay_slowdown_rate = 7;

    pub fn replay_slowdown_rate(&self) -> f32 {
        self.replay_slowdown_rate.unwrap_or(0.)
    }

    pub fn clear_replay_slowdown_rate(&mut self) {
        self.replay_slowdown_rate = ::std::option::Option::None;
    }

    pub fn has_replay_slowdown_rate(&self) -> bool {
        self.replay_slowdown_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_slowdown_rate(&mut self, v: f32) {
        self.replay_slowdown_rate = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delay",
            |m: &CSVCMsg_HltvReplay| { &m.delay },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.delay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "primary_target",
            |m: &CSVCMsg_HltvReplay| { &m.primary_target },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.primary_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_stop_at",
            |m: &CSVCMsg_HltvReplay| { &m.replay_stop_at },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.replay_stop_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_start_at",
            |m: &CSVCMsg_HltvReplay| { &m.replay_start_at },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.replay_start_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_slowdown_begin",
            |m: &CSVCMsg_HltvReplay| { &m.replay_slowdown_begin },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.replay_slowdown_begin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_slowdown_end",
            |m: &CSVCMsg_HltvReplay| { &m.replay_slowdown_end },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.replay_slowdown_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_slowdown_rate",
            |m: &CSVCMsg_HltvReplay| { &m.replay_slowdown_rate },
            |m: &mut CSVCMsg_HltvReplay| { &mut m.replay_slowdown_rate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_HltvReplay>(
            "CSVCMsg_HltvReplay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_HltvReplay {
    const NAME: &'static str = "CSVCMsg_HltvReplay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.delay = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.primary_target = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.replay_stop_at = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.replay_start_at = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.replay_slowdown_begin = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.replay_slowdown_end = ::std::option::Option::Some(is.read_int32()?);
                },
                61 => {
                    self.replay_slowdown_rate = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.delay {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.primary_target {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.replay_stop_at {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.replay_start_at {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.replay_slowdown_begin {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.replay_slowdown_end {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.replay_slowdown_rate {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.delay {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.primary_target {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.replay_stop_at {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.replay_start_at {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.replay_slowdown_begin {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.replay_slowdown_end {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.replay_slowdown_rate {
            os.write_float(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_HltvReplay {
        CSVCMsg_HltvReplay::new()
    }

    fn clear(&mut self) {
        self.delay = ::std::option::Option::None;
        self.primary_target = ::std::option::Option::None;
        self.replay_stop_at = ::std::option::Option::None;
        self.replay_start_at = ::std::option::Option::None;
        self.replay_slowdown_begin = ::std::option::Option::None;
        self.replay_slowdown_end = ::std::option::Option::None;
        self.replay_slowdown_rate = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_HltvReplay {
        static instance: CSVCMsg_HltvReplay = CSVCMsg_HltvReplay {
            delay: ::std::option::Option::None,
            primary_target: ::std::option::Option::None,
            replay_stop_at: ::std::option::Option::None,
            replay_start_at: ::std::option::Option::None,
            replay_slowdown_begin: ::std::option::Option::None,
            replay_slowdown_end: ::std::option::Option::None,
            replay_slowdown_rate: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_HltvReplay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_HltvReplay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_HltvReplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_HltvReplay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CCLCMsg_HltvReplay)
pub struct CCLCMsg_HltvReplay {
    // message fields
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.request)
    pub request: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.slowdown_length)
    pub slowdown_length: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.slowdown_rate)
    pub slowdown_rate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.primary_target_ent_index)
    pub primary_target_ent_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCLCMsg_HltvReplay.event_time)
    pub event_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCLCMsg_HltvReplay.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCLCMsg_HltvReplay {
    fn default() -> &'a CCLCMsg_HltvReplay {
        <CCLCMsg_HltvReplay as ::protobuf::Message>::default_instance()
    }
}

impl CCLCMsg_HltvReplay {
    pub fn new() -> CCLCMsg_HltvReplay {
        ::std::default::Default::default()
    }

    // optional int32 request = 1;

    pub fn request(&self) -> i32 {
        self.request.unwrap_or(0)
    }

    pub fn clear_request(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_request(&self) -> bool {
        self.request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: i32) {
        self.request = ::std::option::Option::Some(v);
    }

    // optional float slowdown_length = 2;

    pub fn slowdown_length(&self) -> f32 {
        self.slowdown_length.unwrap_or(0.)
    }

    pub fn clear_slowdown_length(&mut self) {
        self.slowdown_length = ::std::option::Option::None;
    }

    pub fn has_slowdown_length(&self) -> bool {
        self.slowdown_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slowdown_length(&mut self, v: f32) {
        self.slowdown_length = ::std::option::Option::Some(v);
    }

    // optional float slowdown_rate = 3;

    pub fn slowdown_rate(&self) -> f32 {
        self.slowdown_rate.unwrap_or(0.)
    }

    pub fn clear_slowdown_rate(&mut self) {
        self.slowdown_rate = ::std::option::Option::None;
    }

    pub fn has_slowdown_rate(&self) -> bool {
        self.slowdown_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slowdown_rate(&mut self, v: f32) {
        self.slowdown_rate = ::std::option::Option::Some(v);
    }

    // optional int32 primary_target_ent_index = 4;

    pub fn primary_target_ent_index(&self) -> i32 {
        self.primary_target_ent_index.unwrap_or(0)
    }

    pub fn clear_primary_target_ent_index(&mut self) {
        self.primary_target_ent_index = ::std::option::Option::None;
    }

    pub fn has_primary_target_ent_index(&self) -> bool {
        self.primary_target_ent_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_primary_target_ent_index(&mut self, v: i32) {
        self.primary_target_ent_index = ::std::option::Option::Some(v);
    }

    // optional float event_time = 5;

    pub fn event_time(&self) -> f32 {
        self.event_time.unwrap_or(0.)
    }

    pub fn clear_event_time(&mut self) {
        self.event_time = ::std::option::Option::None;
    }

    pub fn has_event_time(&self) -> bool {
        self.event_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time(&mut self, v: f32) {
        self.event_time = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request",
            |m: &CCLCMsg_HltvReplay| { &m.request },
            |m: &mut CCLCMsg_HltvReplay| { &mut m.request },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slowdown_length",
            |m: &CCLCMsg_HltvReplay| { &m.slowdown_length },
            |m: &mut CCLCMsg_HltvReplay| { &mut m.slowdown_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slowdown_rate",
            |m: &CCLCMsg_HltvReplay| { &m.slowdown_rate },
            |m: &mut CCLCMsg_HltvReplay| { &mut m.slowdown_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "primary_target_ent_index",
            |m: &CCLCMsg_HltvReplay| { &m.primary_target_ent_index },
            |m: &mut CCLCMsg_HltvReplay| { &mut m.primary_target_ent_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_time",
            |m: &CCLCMsg_HltvReplay| { &m.event_time },
            |m: &mut CCLCMsg_HltvReplay| { &mut m.event_time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CCLCMsg_HltvReplay>(
            "CCLCMsg_HltvReplay",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CCLCMsg_HltvReplay {
    const NAME: &'static str = "CCLCMsg_HltvReplay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.slowdown_length = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.slowdown_rate = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.primary_target_ent_index = ::std::option::Option::Some(is.read_int32()?);
                },
                45 => {
                    self.event_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.slowdown_length {
            my_size += 1 + 4;
        }
        if let Some(v) = self.slowdown_rate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.primary_target_ent_index {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.event_time {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.slowdown_length {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.slowdown_rate {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.primary_target_ent_index {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.event_time {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCLCMsg_HltvReplay {
        CCLCMsg_HltvReplay::new()
    }

    fn clear(&mut self) {
        self.request = ::std::option::Option::None;
        self.slowdown_length = ::std::option::Option::None;
        self.slowdown_rate = ::std::option::Option::None;
        self.primary_target_ent_index = ::std::option::Option::None;
        self.event_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCLCMsg_HltvReplay {
        static instance: CCLCMsg_HltvReplay = CCLCMsg_HltvReplay {
            request: ::std::option::Option::None,
            slowdown_length: ::std::option::Option::None,
            slowdown_rate: ::std::option::Option::None,
            primary_target_ent_index: ::std::option::Option::None,
            event_time: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CCLCMsg_HltvReplay {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CCLCMsg_HltvReplay").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CCLCMsg_HltvReplay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCLCMsg_HltvReplay {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSVCMsg_BroadcastCommand)
pub struct CSVCMsg_BroadcastCommand {
    // message fields
    // @@protoc_insertion_point(field:CSVCMsg_BroadcastCommand.cmd)
    pub cmd: ::std::option::Option<::protobuf::Chars>,
    // special fields
    // @@protoc_insertion_point(special_field:CSVCMsg_BroadcastCommand.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSVCMsg_BroadcastCommand {
    fn default() -> &'a CSVCMsg_BroadcastCommand {
        <CSVCMsg_BroadcastCommand as ::protobuf::Message>::default_instance()
    }
}

impl CSVCMsg_BroadcastCommand {
    pub fn new() -> CSVCMsg_BroadcastCommand {
        ::std::default::Default::default()
    }

    // optional string cmd = 1;

    pub fn cmd(&self) -> &str {
        match self.cmd.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cmd(&mut self) {
        self.cmd = ::std::option::Option::None;
    }

    pub fn has_cmd(&self) -> bool {
        self.cmd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd(&mut self, v: ::protobuf::Chars) {
        self.cmd = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cmd(&mut self) -> &mut ::protobuf::Chars {
        if self.cmd.is_none() {
            self.cmd = ::std::option::Option::Some(::protobuf::Chars::new());
        }
        self.cmd.as_mut().unwrap()
    }

    // Take field
    pub fn take_cmd(&mut self) -> ::protobuf::Chars {
        self.cmd.take().unwrap_or_else(|| ::protobuf::Chars::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cmd",
            |m: &CSVCMsg_BroadcastCommand| { &m.cmd },
            |m: &mut CSVCMsg_BroadcastCommand| { &mut m.cmd },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSVCMsg_BroadcastCommand>(
            "CSVCMsg_BroadcastCommand",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSVCMsg_BroadcastCommand {
    const NAME: &'static str = "CSVCMsg_BroadcastCommand";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cmd = ::std::option::Option::Some(is.read_tokio_chars()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cmd.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cmd.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSVCMsg_BroadcastCommand {
        CSVCMsg_BroadcastCommand::new()
    }

    fn clear(&mut self) {
        self.cmd = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSVCMsg_BroadcastCommand {
        static instance: CSVCMsg_BroadcastCommand = CSVCMsg_BroadcastCommand {
            cmd: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSVCMsg_BroadcastCommand {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSVCMsg_BroadcastCommand").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSVCMsg_BroadcastCommand {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSVCMsg_BroadcastCommand {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:NET_Messages)
pub enum NET_Messages {
    // @@protoc_insertion_point(enum_value:NET_Messages.net_NOP)
    net_NOP = 0,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_Disconnect)
    net_Disconnect = 1,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_File)
    net_File = 2,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SplitScreenUser)
    net_SplitScreenUser = 3,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_Tick)
    net_Tick = 4,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_StringCmd)
    net_StringCmd = 5,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SetConVar)
    net_SetConVar = 6,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_SignonState)
    net_SignonState = 7,
    // @@protoc_insertion_point(enum_value:NET_Messages.net_PlayerAvatarData)
    net_PlayerAvatarData = 100,
}

impl ::protobuf::Enum for NET_Messages {
    const NAME: &'static str = "NET_Messages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NET_Messages> {
        match value {
            0 => ::std::option::Option::Some(NET_Messages::net_NOP),
            1 => ::std::option::Option::Some(NET_Messages::net_Disconnect),
            2 => ::std::option::Option::Some(NET_Messages::net_File),
            3 => ::std::option::Option::Some(NET_Messages::net_SplitScreenUser),
            4 => ::std::option::Option::Some(NET_Messages::net_Tick),
            5 => ::std::option::Option::Some(NET_Messages::net_StringCmd),
            6 => ::std::option::Option::Some(NET_Messages::net_SetConVar),
            7 => ::std::option::Option::Some(NET_Messages::net_SignonState),
            100 => ::std::option::Option::Some(NET_Messages::net_PlayerAvatarData),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [NET_Messages] = &[
        NET_Messages::net_NOP,
        NET_Messages::net_Disconnect,
        NET_Messages::net_File,
        NET_Messages::net_SplitScreenUser,
        NET_Messages::net_Tick,
        NET_Messages::net_StringCmd,
        NET_Messages::net_SetConVar,
        NET_Messages::net_SignonState,
        NET_Messages::net_PlayerAvatarData,
    ];
}

impl ::protobuf::EnumFull for NET_Messages {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("NET_Messages").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            NET_Messages::net_NOP => 0,
            NET_Messages::net_Disconnect => 1,
            NET_Messages::net_File => 2,
            NET_Messages::net_SplitScreenUser => 3,
            NET_Messages::net_Tick => 4,
            NET_Messages::net_StringCmd => 5,
            NET_Messages::net_SetConVar => 6,
            NET_Messages::net_SignonState => 7,
            NET_Messages::net_PlayerAvatarData => 8,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for NET_Messages {
    fn default() -> Self {
        NET_Messages::net_NOP
    }
}

impl NET_Messages {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NET_Messages>("NET_Messages")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CLC_Messages)
pub enum CLC_Messages {
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_ClientInfo)
    clc_ClientInfo = 8,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_Move)
    clc_Move = 9,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_VoiceData)
    clc_VoiceData = 10,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_BaselineAck)
    clc_BaselineAck = 11,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_ListenEvents)
    clc_ListenEvents = 12,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_RespondCvarValue)
    clc_RespondCvarValue = 13,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_FileCRCCheck)
    clc_FileCRCCheck = 14,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_LoadingProgress)
    clc_LoadingProgress = 15,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_SplitPlayerConnect)
    clc_SplitPlayerConnect = 16,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_ClientMessage)
    clc_ClientMessage = 17,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_CmdKeyValues)
    clc_CmdKeyValues = 18,
    // @@protoc_insertion_point(enum_value:CLC_Messages.clc_HltvReplay)
    clc_HltvReplay = 20,
}

impl ::protobuf::Enum for CLC_Messages {
    const NAME: &'static str = "CLC_Messages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CLC_Messages> {
        match value {
            8 => ::std::option::Option::Some(CLC_Messages::clc_ClientInfo),
            9 => ::std::option::Option::Some(CLC_Messages::clc_Move),
            10 => ::std::option::Option::Some(CLC_Messages::clc_VoiceData),
            11 => ::std::option::Option::Some(CLC_Messages::clc_BaselineAck),
            12 => ::std::option::Option::Some(CLC_Messages::clc_ListenEvents),
            13 => ::std::option::Option::Some(CLC_Messages::clc_RespondCvarValue),
            14 => ::std::option::Option::Some(CLC_Messages::clc_FileCRCCheck),
            15 => ::std::option::Option::Some(CLC_Messages::clc_LoadingProgress),
            16 => ::std::option::Option::Some(CLC_Messages::clc_SplitPlayerConnect),
            17 => ::std::option::Option::Some(CLC_Messages::clc_ClientMessage),
            18 => ::std::option::Option::Some(CLC_Messages::clc_CmdKeyValues),
            20 => ::std::option::Option::Some(CLC_Messages::clc_HltvReplay),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CLC_Messages] = &[
        CLC_Messages::clc_ClientInfo,
        CLC_Messages::clc_Move,
        CLC_Messages::clc_VoiceData,
        CLC_Messages::clc_BaselineAck,
        CLC_Messages::clc_ListenEvents,
        CLC_Messages::clc_RespondCvarValue,
        CLC_Messages::clc_FileCRCCheck,
        CLC_Messages::clc_LoadingProgress,
        CLC_Messages::clc_SplitPlayerConnect,
        CLC_Messages::clc_ClientMessage,
        CLC_Messages::clc_CmdKeyValues,
        CLC_Messages::clc_HltvReplay,
    ];
}

impl ::protobuf::EnumFull for CLC_Messages {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CLC_Messages").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            CLC_Messages::clc_ClientInfo => 0,
            CLC_Messages::clc_Move => 1,
            CLC_Messages::clc_VoiceData => 2,
            CLC_Messages::clc_BaselineAck => 3,
            CLC_Messages::clc_ListenEvents => 4,
            CLC_Messages::clc_RespondCvarValue => 5,
            CLC_Messages::clc_FileCRCCheck => 6,
            CLC_Messages::clc_LoadingProgress => 7,
            CLC_Messages::clc_SplitPlayerConnect => 8,
            CLC_Messages::clc_ClientMessage => 9,
            CLC_Messages::clc_CmdKeyValues => 10,
            CLC_Messages::clc_HltvReplay => 11,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CLC_Messages {
    fn default() -> Self {
        CLC_Messages::clc_ClientInfo
    }
}

impl CLC_Messages {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CLC_Messages>("CLC_Messages")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:VoiceDataFormat_t)
pub enum VoiceDataFormat_t {
    // @@protoc_insertion_point(enum_value:VoiceDataFormat_t.VOICEDATA_FORMAT_STEAM)
    VOICEDATA_FORMAT_STEAM = 0,
    // @@protoc_insertion_point(enum_value:VoiceDataFormat_t.VOICEDATA_FORMAT_ENGINE)
    VOICEDATA_FORMAT_ENGINE = 1,
}

impl ::protobuf::Enum for VoiceDataFormat_t {
    const NAME: &'static str = "VoiceDataFormat_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VoiceDataFormat_t> {
        match value {
            0 => ::std::option::Option::Some(VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM),
            1 => ::std::option::Option::Some(VoiceDataFormat_t::VOICEDATA_FORMAT_ENGINE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VoiceDataFormat_t] = &[
        VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM,
        VoiceDataFormat_t::VOICEDATA_FORMAT_ENGINE,
    ];
}

impl ::protobuf::EnumFull for VoiceDataFormat_t {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("VoiceDataFormat_t").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for VoiceDataFormat_t {
    fn default() -> Self {
        VoiceDataFormat_t::VOICEDATA_FORMAT_STEAM
    }
}

impl VoiceDataFormat_t {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VoiceDataFormat_t>("VoiceDataFormat_t")
    }
}

// Note: you cannot use pattern matching for enums with allow_alias option
#[derive(Clone,Copy,Eq,Debug)]
// @@protoc_insertion_point(enum:ESplitScreenMessageType)
pub enum ESplitScreenMessageType {
    // @@protoc_insertion_point(enum_value:ESplitScreenMessageType.MSG_SPLITSCREEN_ADDUSER)
    MSG_SPLITSCREEN_ADDUSER, // 0
    // @@protoc_insertion_point(enum_value:ESplitScreenMessageType.MSG_SPLITSCREEN_REMOVEUSER)
    MSG_SPLITSCREEN_REMOVEUSER, // 1
    // @@protoc_insertion_point(enum_value:ESplitScreenMessageType.MSG_SPLITSCREEN_TYPE_BITS)
    MSG_SPLITSCREEN_TYPE_BITS, // 1
}

impl ::std::cmp::PartialEq for ESplitScreenMessageType {
    fn eq(&self, other: &Self) -> bool {
        ::protobuf::Enum::value(self) == ::protobuf::Enum::value(other)
    }
}

impl ::std::hash::Hash for ESplitScreenMessageType {
    fn hash<H : ::std::hash::Hasher>(&self, state: &mut H) {
        state.write_i32(::protobuf::Enum::value(self))
    }
}

impl ::protobuf::Enum for ESplitScreenMessageType {
    const NAME: &'static str = "ESplitScreenMessageType";

    fn value(&self) -> i32 {
        match *self {
            ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER => 0,
            ESplitScreenMessageType::MSG_SPLITSCREEN_REMOVEUSER => 1,
            ESplitScreenMessageType::MSG_SPLITSCREEN_TYPE_BITS => 1,
        }
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESplitScreenMessageType> {
        match value {
            0 => ::std::option::Option::Some(ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER),
            1 => ::std::option::Option::Some(ESplitScreenMessageType::MSG_SPLITSCREEN_REMOVEUSER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESplitScreenMessageType] = &[
        ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER,
        ESplitScreenMessageType::MSG_SPLITSCREEN_REMOVEUSER,
        ESplitScreenMessageType::MSG_SPLITSCREEN_TYPE_BITS,
    ];
}

impl ::protobuf::EnumFull for ESplitScreenMessageType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ESplitScreenMessageType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER => 0,
            ESplitScreenMessageType::MSG_SPLITSCREEN_REMOVEUSER => 1,
            ESplitScreenMessageType::MSG_SPLITSCREEN_TYPE_BITS => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ESplitScreenMessageType {
    fn default() -> Self {
        ESplitScreenMessageType::MSG_SPLITSCREEN_ADDUSER
    }
}

impl ESplitScreenMessageType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ESplitScreenMessageType>("ESplitScreenMessageType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SVC_Messages)
pub enum SVC_Messages {
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_ServerInfo)
    svc_ServerInfo = 8,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_SendTable)
    svc_SendTable = 9,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_ClassInfo)
    svc_ClassInfo = 10,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_SetPause)
    svc_SetPause = 11,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_CreateStringTable)
    svc_CreateStringTable = 12,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_UpdateStringTable)
    svc_UpdateStringTable = 13,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_VoiceInit)
    svc_VoiceInit = 14,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_VoiceData)
    svc_VoiceData = 15,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Print)
    svc_Print = 16,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Sounds)
    svc_Sounds = 17,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_SetView)
    svc_SetView = 18,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_FixAngle)
    svc_FixAngle = 19,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_CrosshairAngle)
    svc_CrosshairAngle = 20,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_BSPDecal)
    svc_BSPDecal = 21,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_SplitScreen)
    svc_SplitScreen = 22,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_UserMessage)
    svc_UserMessage = 23,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_EntityMessage)
    svc_EntityMessage = 24,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_GameEvent)
    svc_GameEvent = 25,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_PacketEntities)
    svc_PacketEntities = 26,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_TempEntities)
    svc_TempEntities = 27,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Prefetch)
    svc_Prefetch = 28,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_Menu)
    svc_Menu = 29,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_GameEventList)
    svc_GameEventList = 30,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_GetCvarValue)
    svc_GetCvarValue = 31,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_PaintmapData)
    svc_PaintmapData = 33,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_CmdKeyValues)
    svc_CmdKeyValues = 34,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_EncryptedData)
    svc_EncryptedData = 35,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_HltvReplay)
    svc_HltvReplay = 36,
    // @@protoc_insertion_point(enum_value:SVC_Messages.svc_BroadcastCommand)
    svc_BroadcastCommand = 38,
}

impl ::protobuf::Enum for SVC_Messages {
    const NAME: &'static str = "SVC_Messages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SVC_Messages> {
        match value {
            8 => ::std::option::Option::Some(SVC_Messages::svc_ServerInfo),
            9 => ::std::option::Option::Some(SVC_Messages::svc_SendTable),
            10 => ::std::option::Option::Some(SVC_Messages::svc_ClassInfo),
            11 => ::std::option::Option::Some(SVC_Messages::svc_SetPause),
            12 => ::std::option::Option::Some(SVC_Messages::svc_CreateStringTable),
            13 => ::std::option::Option::Some(SVC_Messages::svc_UpdateStringTable),
            14 => ::std::option::Option::Some(SVC_Messages::svc_VoiceInit),
            15 => ::std::option::Option::Some(SVC_Messages::svc_VoiceData),
            16 => ::std::option::Option::Some(SVC_Messages::svc_Print),
            17 => ::std::option::Option::Some(SVC_Messages::svc_Sounds),
            18 => ::std::option::Option::Some(SVC_Messages::svc_SetView),
            19 => ::std::option::Option::Some(SVC_Messages::svc_FixAngle),
            20 => ::std::option::Option::Some(SVC_Messages::svc_CrosshairAngle),
            21 => ::std::option::Option::Some(SVC_Messages::svc_BSPDecal),
            22 => ::std::option::Option::Some(SVC_Messages::svc_SplitScreen),
            23 => ::std::option::Option::Some(SVC_Messages::svc_UserMessage),
            24 => ::std::option::Option::Some(SVC_Messages::svc_EntityMessage),
            25 => ::std::option::Option::Some(SVC_Messages::svc_GameEvent),
            26 => ::std::option::Option::Some(SVC_Messages::svc_PacketEntities),
            27 => ::std::option::Option::Some(SVC_Messages::svc_TempEntities),
            28 => ::std::option::Option::Some(SVC_Messages::svc_Prefetch),
            29 => ::std::option::Option::Some(SVC_Messages::svc_Menu),
            30 => ::std::option::Option::Some(SVC_Messages::svc_GameEventList),
            31 => ::std::option::Option::Some(SVC_Messages::svc_GetCvarValue),
            33 => ::std::option::Option::Some(SVC_Messages::svc_PaintmapData),
            34 => ::std::option::Option::Some(SVC_Messages::svc_CmdKeyValues),
            35 => ::std::option::Option::Some(SVC_Messages::svc_EncryptedData),
            36 => ::std::option::Option::Some(SVC_Messages::svc_HltvReplay),
            38 => ::std::option::Option::Some(SVC_Messages::svc_BroadcastCommand),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SVC_Messages] = &[
        SVC_Messages::svc_ServerInfo,
        SVC_Messages::svc_SendTable,
        SVC_Messages::svc_ClassInfo,
        SVC_Messages::svc_SetPause,
        SVC_Messages::svc_CreateStringTable,
        SVC_Messages::svc_UpdateStringTable,
        SVC_Messages::svc_VoiceInit,
        SVC_Messages::svc_VoiceData,
        SVC_Messages::svc_Print,
        SVC_Messages::svc_Sounds,
        SVC_Messages::svc_SetView,
        SVC_Messages::svc_FixAngle,
        SVC_Messages::svc_CrosshairAngle,
        SVC_Messages::svc_BSPDecal,
        SVC_Messages::svc_SplitScreen,
        SVC_Messages::svc_UserMessage,
        SVC_Messages::svc_EntityMessage,
        SVC_Messages::svc_GameEvent,
        SVC_Messages::svc_PacketEntities,
        SVC_Messages::svc_TempEntities,
        SVC_Messages::svc_Prefetch,
        SVC_Messages::svc_Menu,
        SVC_Messages::svc_GameEventList,
        SVC_Messages::svc_GetCvarValue,
        SVC_Messages::svc_PaintmapData,
        SVC_Messages::svc_CmdKeyValues,
        SVC_Messages::svc_EncryptedData,
        SVC_Messages::svc_HltvReplay,
        SVC_Messages::svc_BroadcastCommand,
    ];
}

impl ::protobuf::EnumFull for SVC_Messages {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SVC_Messages").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            SVC_Messages::svc_ServerInfo => 0,
            SVC_Messages::svc_SendTable => 1,
            SVC_Messages::svc_ClassInfo => 2,
            SVC_Messages::svc_SetPause => 3,
            SVC_Messages::svc_CreateStringTable => 4,
            SVC_Messages::svc_UpdateStringTable => 5,
            SVC_Messages::svc_VoiceInit => 6,
            SVC_Messages::svc_VoiceData => 7,
            SVC_Messages::svc_Print => 8,
            SVC_Messages::svc_Sounds => 9,
            SVC_Messages::svc_SetView => 10,
            SVC_Messages::svc_FixAngle => 11,
            SVC_Messages::svc_CrosshairAngle => 12,
            SVC_Messages::svc_BSPDecal => 13,
            SVC_Messages::svc_SplitScreen => 14,
            SVC_Messages::svc_UserMessage => 15,
            SVC_Messages::svc_EntityMessage => 16,
            SVC_Messages::svc_GameEvent => 17,
            SVC_Messages::svc_PacketEntities => 18,
            SVC_Messages::svc_TempEntities => 19,
            SVC_Messages::svc_Prefetch => 20,
            SVC_Messages::svc_Menu => 21,
            SVC_Messages::svc_GameEventList => 22,
            SVC_Messages::svc_GetCvarValue => 23,
            SVC_Messages::svc_PaintmapData => 24,
            SVC_Messages::svc_CmdKeyValues => 25,
            SVC_Messages::svc_EncryptedData => 26,
            SVC_Messages::svc_HltvReplay => 27,
            SVC_Messages::svc_BroadcastCommand => 28,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for SVC_Messages {
    fn default() -> Self {
        SVC_Messages::svc_ServerInfo
    }
}

impl SVC_Messages {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SVC_Messages>("SVC_Messages")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ReplayEventType_t)
pub enum ReplayEventType_t {
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_CANCEL)
    REPLAY_EVENT_CANCEL = 0,
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_DEATH)
    REPLAY_EVENT_DEATH = 1,
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_GENERIC)
    REPLAY_EVENT_GENERIC = 2,
    // @@protoc_insertion_point(enum_value:ReplayEventType_t.REPLAY_EVENT_STUCK_NEED_FULL_UPDATE)
    REPLAY_EVENT_STUCK_NEED_FULL_UPDATE = 3,
}

impl ::protobuf::Enum for ReplayEventType_t {
    const NAME: &'static str = "ReplayEventType_t";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ReplayEventType_t> {
        match value {
            0 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_CANCEL),
            1 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_DEATH),
            2 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_GENERIC),
            3 => ::std::option::Option::Some(ReplayEventType_t::REPLAY_EVENT_STUCK_NEED_FULL_UPDATE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ReplayEventType_t] = &[
        ReplayEventType_t::REPLAY_EVENT_CANCEL,
        ReplayEventType_t::REPLAY_EVENT_DEATH,
        ReplayEventType_t::REPLAY_EVENT_GENERIC,
        ReplayEventType_t::REPLAY_EVENT_STUCK_NEED_FULL_UPDATE,
    ];
}

impl ::protobuf::EnumFull for ReplayEventType_t {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ReplayEventType_t").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ReplayEventType_t {
    fn default() -> Self {
        ReplayEventType_t::REPLAY_EVENT_CANCEL
    }
}

impl ReplayEventType_t {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ReplayEventType_t>("ReplayEventType_t")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x11netmessages.proto\x1a\x20google/protobuf/descriptor.proto\"6\n\nCM\
    sgVector\x12\x0c\n\x01x\x18\x01\x20\x01(\x02R\x01x\x12\x0c\n\x01y\x18\
    \x02\x20\x01(\x02R\x01y\x12\x0c\n\x01z\x18\x03\x20\x01(\x02R\x01z\"*\n\
    \x0cCMsgVector2D\x12\x0c\n\x01x\x18\x01\x20\x01(\x02R\x01x\x12\x0c\n\x01\
    y\x18\x02\x20\x01(\x02R\x01y\"6\n\nCMsgQAngle\x12\x0c\n\x01x\x18\x01\x20\
    \x01(\x02R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x02R\x01y\x12\x0c\n\x01z\
    \x18\x03\x20\x01(\x02R\x01z\"B\n\x08CMsgRGBA\x12\x0c\n\x01r\x18\x01\x20\
    \x01(\x05R\x01r\x12\x0c\n\x01g\x18\x02\x20\x01(\x05R\x01g\x12\x0c\n\x01b\
    \x18\x03\x20\x01(\x05R\x01b\x12\x0c\n\x01a\x18\x04\x20\x01(\x05R\x01a\"\
    \x99\x02\n\x0cCNETMsg_Tick\x12\x12\n\x04tick\x18\x01\x20\x01(\rR\x04tick\
    \x121\n\x14host_computationtime\x18\x04\x20\x01(\rR\x13hostComputationti\
    me\x12K\n\"host_computationtime_std_deviation\x18\x05\x20\x01(\rR\x1fhos\
    tComputationtimeStdDeviation\x12I\n!host_framestarttime_std_deviation\
    \x18\x06\x20\x01(\rR\x1ehostFramestarttimeStdDeviation\x12*\n\x11hltv_re\
    play_flags\x18\x07\x20\x01(\rR\x0fhltvReplayFlags\"-\n\x11CNETMsg_String\
    Cmd\x12\x18\n\x07command\x18\x01\x20\x01(\tR\x07command\"\xd1\x01\n\x13C\
    NETMsg_SignonState\x12!\n\x0csignon_state\x18\x01\x20\x01(\rR\x0bsignonS\
    tate\x12\x1f\n\x0bspawn_count\x18\x02\x20\x01(\rR\nspawnCount\x12,\n\x12\
    num_server_players\x18\x03\x20\x01(\rR\x10numServerPlayers\x12-\n\x12pla\
    yers_networkids\x18\x04\x20\x03(\tR\x11playersNetworkids\x12\x19\n\x08ma\
    p_name\x18\x05\x20\x01(\tR\x07mapName\"\x8f\x01\n\nCMsg_CVars\x12&\n\x05\
    cvars\x18\x01\x20\x03(\x0b2\x10.CMsg_CVars.CVarR\x05cvars\x1aY\n\x04CVar\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value\x12'\n\x0fdictionary_name\x18\x03\x20\x01(\rR\
    \x0edictionaryName\":\n\x11CNETMsg_SetConVar\x12%\n\x07convars\x18\x01\
    \x20\x01(\x0b2\x0b.CMsg_CVarsR\x07convars\"\r\n\x0bCNETMsg_NOP\"(\n\x12C\
    NETMsg_Disconnect\x12\x12\n\x04text\x18\x01\x20\x01(\tR\x04text\"\x8f\
    \x01\n\x0cCNETMsg_File\x12\x1f\n\x0btransfer_id\x18\x01\x20\x01(\x05R\nt\
    ransferId\x12\x1b\n\tfile_name\x18\x02\x20\x01(\tR\x08fileName\x12-\n\
    \x13is_replay_demo_file\x18\x03\x20\x01(\x08R\x10isReplayDemoFile\x12\
    \x12\n\x04deny\x18\x04\x20\x01(\x08R\x04deny\"-\n\x17CNETMsg_SplitScreen\
    User\x12\x12\n\x04slot\x18\x01\x20\x01(\x05R\x04slot\"J\n\x18CNETMsg_Pla\
    yerAvatarData\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\x12\
    \x10\n\x03rgb\x18\x02\x20\x01(\x0cR\x03rgb\"\xf8\x01\n\x12CCLCMsg_Client\
    Info\x12$\n\x0esend_table_crc\x18\x01\x20\x01(\x07R\x0csendTableCrc\x12!\
    \n\x0cserver_count\x18\x02\x20\x01(\rR\x0bserverCount\x12\x17\n\x07is_hl\
    tv\x18\x03\x20\x01(\x08R\x06isHltv\x12\x1b\n\tis_replay\x18\x04\x20\x01(\
    \x08R\x08isReplay\x12\x1d\n\nfriends_id\x18\x05\x20\x01(\rR\tfriendsId\
    \x12!\n\x0cfriends_name\x18\x06\x20\x01(\tR\x0bfriendsName\x12!\n\x0ccus\
    tom_files\x18\x07\x20\x03(\x07R\x0bcustomFiles\"|\n\x0cCCLCMsg_Move\x12.\
    \n\x13num_backup_commands\x18\x01\x20\x01(\rR\x11numBackupCommands\x12(\
    \n\x10num_new_commands\x18\x02\x20\x01(\rR\x0enumNewCommands\x12\x12\n\
    \x04data\x18\x03\x20\x01(\x0cR\x04data\"\x8c\x02\n\x11CCLCMsg_VoiceData\
    \x12\x12\n\x04data\x18\x01\x20\x01(\x0cR\x04data\x12\x12\n\x04xuid\x18\
    \x02\x20\x01(\x06R\x04xuid\x12C\n\x06format\x18\x03\x20\x01(\x0e2\x12.Vo\
    iceDataFormat_t:\x17VOICEDATA_FORMAT_ENGINER\x06format\x12%\n\x0esequenc\
    e_bytes\x18\x04\x20\x01(\x05R\rsequenceBytes\x12%\n\x0esection_number\
    \x18\x05\x20\x01(\rR\rsectionNumber\x12<\n\x1auncompressed_sample_offset\
    \x18\x06\x20\x01(\rR\x18uncompressedSampleOffset\"[\n\x13CCLCMsg_Baselin\
    eAck\x12#\n\rbaseline_tick\x18\x01\x20\x01(\x05R\x0cbaselineTick\x12\x1f\
    \n\x0bbaseline_nr\x18\x02\x20\x01(\x05R\nbaselineNr\"5\n\x14CCLCMsg_List\
    enEvents\x12\x1d\n\nevent_mask\x18\x01\x20\x03(\x07R\teventMask\"}\n\x18\
    CCLCMsg_RespondCvarValue\x12\x16\n\x06cookie\x18\x01\x20\x01(\x05R\x06co\
    okie\x12\x1f\n\x0bstatus_code\x18\x02\x20\x01(\x05R\nstatusCode\x12\x12\
    \n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\x04\x20\
    \x01(\tR\x05value\"\xde\x02\n\x14CCLCMsg_FileCRCCheck\x12\x1b\n\tcode_pa\
    th\x18\x01\x20\x01(\x05R\x08codePath\x12\x12\n\x04path\x18\x02\x20\x01(\
    \tR\x04path\x12#\n\rcode_filename\x18\x03\x20\x01(\x05R\x0ccodeFilename\
    \x12\x1a\n\x08filename\x18\x04\x20\x01(\tR\x08filename\x12#\n\rfile_frac\
    tion\x18\x05\x20\x01(\x05R\x0cfileFraction\x12\x10\n\x03md5\x18\x06\x20\
    \x01(\x0cR\x03md5\x12\x10\n\x03crc\x18\x07\x20\x01(\rR\x03crc\x12$\n\x0e\
    file_hash_type\x18\x08\x20\x01(\x05R\x0cfileHashType\x12\x19\n\x08file_l\
    en\x18\t\x20\x01(\x05R\x07fileLen\x12\x20\n\x0cpack_file_id\x18\n\x20\
    \x01(\x05R\npackFileId\x12(\n\x10pack_file_number\x18\x0b\x20\x01(\x05R\
    \x0epackFileNumber\"5\n\x17CCLCMsg_LoadingProgress\x12\x1a\n\x08progress\
    \x18\x01\x20\x01(\x05R\x08progress\"C\n\x1aCCLCMsg_SplitPlayerConnect\
    \x12%\n\x07convars\x18\x01\x20\x01(\x0b2\x0b.CMsg_CVarsR\x07convars\"4\n\
    \x14CCLCMsg_CmdKeyValues\x12\x1c\n\tkeyvalues\x18\x01\x20\x01(\x0cR\tkey\
    values\"\xf3\x05\n\x12CSVCMsg_ServerInfo\x12\x1a\n\x08protocol\x18\x01\
    \x20\x01(\x05R\x08protocol\x12!\n\x0cserver_count\x18\x02\x20\x01(\x05R\
    \x0bserverCount\x12!\n\x0cis_dedicated\x18\x03\x20\x01(\x08R\x0bisDedica\
    ted\x127\n\x18is_official_valve_server\x18\x04\x20\x01(\x08R\x15isOffici\
    alValveServer\x12\x17\n\x07is_hltv\x18\x05\x20\x01(\x08R\x06isHltv\x12\
    \x1b\n\tis_replay\x18\x06\x20\x01(\x08R\x08isReplay\x12@\n\x1dis_redirec\
    ting_to_proxy_relay\x18\x15\x20\x01(\x08R\x19isRedirectingToProxyRelay\
    \x12\x11\n\x04c_os\x18\x07\x20\x01(\x05R\x03cOs\x12\x17\n\x07map_crc\x18\
    \x08\x20\x01(\x07R\x06mapCrc\x12\x1d\n\nclient_crc\x18\t\x20\x01(\x07R\t\
    clientCrc\x12(\n\x10string_table_crc\x18\n\x20\x01(\x07R\x0estringTableC\
    rc\x12\x1f\n\x0bmax_clients\x18\x0b\x20\x01(\x05R\nmaxClients\x12\x1f\n\
    \x0bmax_classes\x18\x0c\x20\x01(\x05R\nmaxClasses\x12\x1f\n\x0bplayer_sl\
    ot\x18\r\x20\x01(\x05R\nplayerSlot\x12#\n\rtick_interval\x18\x0e\x20\x01\
    (\x02R\x0ctickInterval\x12\x19\n\x08game_dir\x18\x0f\x20\x01(\tR\x07game\
    Dir\x12\x19\n\x08map_name\x18\x10\x20\x01(\tR\x07mapName\x12$\n\x0emap_g\
    roup_name\x18\x11\x20\x01(\tR\x0cmapGroupName\x12\x19\n\x08sky_name\x18\
    \x12\x20\x01(\tR\x07skyName\x12\x1b\n\thost_name\x18\x13\x20\x01(\tR\x08\
    hostName\x12\x1b\n\tpublic_ip\x18\x14\x20\x01(\rR\x08publicIp\x12\x1c\n\
    \nugc_map_id\x18\x16\x20\x01(\x04R\x08ugcMapId\"\xe0\x01\n\x11CSVCMsg_Cl\
    assInfo\x12(\n\x10create_on_client\x18\x01\x20\x01(\x08R\x0ecreateOnClie\
    nt\x124\n\x07classes\x18\x02\x20\x03(\x0b2\x1a.CSVCMsg_ClassInfo.class_t\
    R\x07classes\x1ak\n\x07class_t\x12\x19\n\x08class_id\x18\x01\x20\x01(\
    \x05R\x07classId\x12&\n\x0fdata_table_name\x18\x02\x20\x01(\tR\rdataTabl\
    eName\x12\x1d\n\nclass_name\x18\x03\x20\x01(\tR\tclassName\"\xad\x03\n\
    \x11CSVCMsg_SendTable\x12\x15\n\x06is_end\x18\x01\x20\x01(\x08R\x05isEnd\
    \x12$\n\x0enet_table_name\x18\x02\x20\x01(\tR\x0cnetTableName\x12#\n\rne\
    eds_decoder\x18\x03\x20\x01(\x08R\x0cneedsDecoder\x123\n\x05props\x18\
    \x04\x20\x03(\x0b2\x1d.CSVCMsg_SendTable.sendprop_tR\x05props\x1a\x80\
    \x02\n\nsendprop_t\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\x04type\x12\
    \x19\n\x08var_name\x18\x02\x20\x01(\tR\x07varName\x12\x14\n\x05flags\x18\
    \x03\x20\x01(\x05R\x05flags\x12\x1a\n\x08priority\x18\x04\x20\x01(\x05R\
    \x08priority\x12\x17\n\x07dt_name\x18\x05\x20\x01(\tR\x06dtName\x12!\n\
    \x0cnum_elements\x18\x06\x20\x01(\x05R\x0bnumElements\x12\x1b\n\tlow_val\
    ue\x18\x07\x20\x01(\x02R\x08lowValue\x12\x1d\n\nhigh_value\x18\x08\x20\
    \x01(\x02R\thighValue\x12\x19\n\x08num_bits\x18\t\x20\x01(\x05R\x07numBi\
    ts\"#\n\rCSVCMsg_Print\x12\x12\n\x04text\x18\x01\x20\x01(\tR\x04text\"*\
    \n\x10CSVCMsg_SetPause\x12\x16\n\x06paused\x18\x01\x20\x01(\x08R\x06paus\
    ed\"4\n\x0fCSVCMsg_SetView\x12!\n\x0centity_index\x18\x01\x20\x01(\x05R\
    \x0bentityIndex\"\xae\x02\n\x19CSVCMsg_CreateStringTable\x12\x12\n\x04na\
    me\x18\x01\x20\x01(\tR\x04name\x12\x1f\n\x0bmax_entries\x18\x02\x20\x01(\
    \x05R\nmaxEntries\x12\x1f\n\x0bnum_entries\x18\x03\x20\x01(\x05R\nnumEnt\
    ries\x12/\n\x14user_data_fixed_size\x18\x04\x20\x01(\x08R\x11userDataFix\
    edSize\x12$\n\x0euser_data_size\x18\x05\x20\x01(\x05R\x0cuserDataSize\
    \x12-\n\x13user_data_size_bits\x18\x06\x20\x01(\x05R\x10userDataSizeBits\
    \x12\x14\n\x05flags\x18\x07\x20\x01(\x05R\x05flags\x12\x1f\n\x0bstring_d\
    ata\x18\x08\x20\x01(\x0cR\nstringData\"\x87\x01\n\x19CSVCMsg_UpdateStrin\
    gTable\x12\x19\n\x08table_id\x18\x01\x20\x01(\x05R\x07tableId\x12.\n\x13\
    num_changed_entries\x18\x02\x20\x01(\x05R\x11numChangedEntries\x12\x1f\n\
    \x0bstring_data\x18\x03\x20\x01(\x0cR\nstringData\"`\n\x11CSVCMsg_VoiceI\
    nit\x12\x18\n\x07quality\x18\x01\x20\x01(\x05R\x07quality\x12\x14\n\x05c\
    odec\x18\x02\x20\x01(\tR\x05codec\x12\x1b\n\x07version\x18\x03\x20\x01(\
    \x05:\x010R\x07version\"\x88\x03\n\x11CSVCMsg_VoiceData\x12\x16\n\x06cli\
    ent\x18\x01\x20\x01(\x05R\x06client\x12\x1c\n\tproximity\x18\x02\x20\x01\
    (\x08R\tproximity\x12\x12\n\x04xuid\x18\x03\x20\x01(\x06R\x04xuid\x12!\n\
    \x0caudible_mask\x18\x04\x20\x01(\x05R\x0baudibleMask\x12\x1d\n\nvoice_d\
    ata\x18\x05\x20\x01(\x0cR\tvoiceData\x12\x16\n\x06caster\x18\x06\x20\x01\
    (\x08R\x06caster\x12C\n\x06format\x18\x07\x20\x01(\x0e2\x12.VoiceDataFor\
    mat_t:\x17VOICEDATA_FORMAT_ENGINER\x06format\x12%\n\x0esequence_bytes\
    \x18\x08\x20\x01(\x05R\rsequenceBytes\x12%\n\x0esection_number\x18\t\x20\
    \x01(\rR\rsectionNumber\x12<\n\x1auncompressed_sample_offset\x18\n\x20\
    \x01(\rR\x18uncompressedSampleOffset\"Q\n\x10CSVCMsg_FixAngle\x12\x1a\n\
    \x08relative\x18\x01\x20\x01(\x08R\x08relative\x12!\n\x05angle\x18\x02\
    \x20\x01(\x0b2\x0b.CMsgQAngleR\x05angle\";\n\x16CSVCMsg_CrosshairAngle\
    \x12!\n\x05angle\x18\x01\x20\x01(\x0b2\x0b.CMsgQAngleR\x05angle\"3\n\x10\
    CSVCMsg_Prefetch\x12\x1f\n\x0bsound_index\x18\x01\x20\x01(\x05R\nsoundIn\
    dex\"\xc8\x01\n\x10CSVCMsg_BSPDecal\x12\x1d\n\x03pos\x18\x01\x20\x01(\
    \x0b2\x0b.CMsgVectorR\x03pos\x12.\n\x13decal_texture_index\x18\x02\x20\
    \x01(\x05R\x11decalTextureIndex\x12!\n\x0centity_index\x18\x03\x20\x01(\
    \x05R\x0bentityIndex\x12\x1f\n\x0bmodel_index\x18\x04\x20\x01(\x05R\nmod\
    elIndex\x12!\n\x0clow_priority\x18\x05\x20\x01(\x08R\x0blowPriority\"\
    \x93\x01\n\x13CSVCMsg_SplitScreen\x12E\n\x04type\x18\x01\x20\x01(\x0e2\
    \x18.ESplitScreenMessageType:\x17MSG_SPLITSCREEN_ADDUSERR\x04type\x12\
    \x12\n\x04slot\x18\x02\x20\x01(\x05R\x04slot\x12!\n\x0cplayer_index\x18\
    \x03\x20\x01(\x05R\x0bplayerIndex\"K\n\x14CSVCMsg_GetCvarValue\x12\x16\n\
    \x06cookie\x18\x01\x20\x01(\x05R\x06cookie\x12\x1b\n\tcvar_name\x18\x02\
    \x20\x01(\tR\x08cvarName\"W\n\x0cCSVCMsg_Menu\x12\x1f\n\x0bdialog_type\
    \x18\x01\x20\x01(\x05R\ndialogType\x12&\n\x0fmenu_key_values\x18\x02\x20\
    \x01(\x0cR\rmenuKeyValues\"m\n\x13CSVCMsg_UserMessage\x12\x19\n\x08msg_t\
    ype\x18\x01\x20\x01(\x05R\x07msgType\x12\x19\n\x08msg_data\x18\x02\x20\
    \x01(\x0cR\x07msgData\x12\x20\n\x0bpassthrough\x18\x03\x20\x01(\x05R\x0b\
    passthrough\"2\n\x14CSVCMsg_PaintmapData\x12\x1a\n\x08paintmap\x18\x01\
    \x20\x01(\x0cR\x08paintmap\"\xa4\x03\n\x11CSVCMsg_GameEvent\x12\x1d\n\ne\
    vent_name\x18\x01\x20\x01(\tR\teventName\x12\x18\n\x07eventid\x18\x02\
    \x20\x01(\x05R\x07eventid\x12,\n\x04keys\x18\x03\x20\x03(\x0b2\x18.CSVCM\
    sg_GameEvent.key_tR\x04keys\x12\x20\n\x0bpassthrough\x18\x04\x20\x01(\
    \x05R\x0bpassthrough\x1a\x85\x02\n\x05key_t\x12\x12\n\x04type\x18\x01\
    \x20\x01(\x05R\x04type\x12\x1d\n\nval_string\x18\x02\x20\x01(\tR\tvalStr\
    ing\x12\x1b\n\tval_float\x18\x03\x20\x01(\x02R\x08valFloat\x12\x19\n\x08\
    val_long\x18\x04\x20\x01(\x05R\x07valLong\x12\x1b\n\tval_short\x18\x05\
    \x20\x01(\x05R\x08valShort\x12\x19\n\x08val_byte\x18\x06\x20\x01(\x05R\
    \x07valByte\x12\x19\n\x08val_bool\x18\x07\x20\x01(\x08R\x07valBool\x12\
    \x1d\n\nval_uint64\x18\x08\x20\x01(\x04R\tvalUint64\x12\x1f\n\x0bval_wst\
    ring\x18\t\x20\x01(\x0cR\nvalWstring\"\xff\x01\n\x15CSVCMsg_GameEventLis\
    t\x12E\n\x0bdescriptors\x18\x01\x20\x03(\x0b2#.CSVCMsg_GameEventList.des\
    criptor_tR\x0bdescriptors\x1a/\n\x05key_t\x12\x12\n\x04type\x18\x01\x20\
    \x01(\x05R\x04type\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x1an\n\
    \x0cdescriptor_t\x12\x18\n\x07eventid\x18\x01\x20\x01(\x05R\x07eventid\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x120\n\x04keys\x18\x03\
    \x20\x03(\x0b2\x1c.CSVCMsg_GameEventList.key_tR\x04keys\"t\n\x14CSVCMsg_\
    TempEntities\x12\x1a\n\x08reliable\x18\x01\x20\x01(\x08R\x08reliable\x12\
    \x1f\n\x0bnum_entries\x18\x02\x20\x01(\x05R\nnumEntries\x12\x1f\n\x0bent\
    ity_data\x18\x03\x20\x01(\x0cR\nentityData\"\x82\x02\n\x16CSVCMsg_Packet\
    Entities\x12\x1f\n\x0bmax_entries\x18\x01\x20\x01(\x05R\nmaxEntries\x12'\
    \n\x0fupdated_entries\x18\x02\x20\x01(\x05R\x0eupdatedEntries\x12\x19\n\
    \x08is_delta\x18\x03\x20\x01(\x08R\x07isDelta\x12'\n\x0fupdate_baseline\
    \x18\x04\x20\x01(\x08R\x0eupdateBaseline\x12\x1a\n\x08baseline\x18\x05\
    \x20\x01(\x05R\x08baseline\x12\x1d\n\ndelta_from\x18\x06\x20\x01(\x05R\t\
    deltaFrom\x12\x1f\n\x0bentity_data\x18\x07\x20\x01(\x0cR\nentityData\"\
    \x88\x05\n\x0eCSVCMsg_Sounds\x12%\n\x0ereliable_sound\x18\x01\x20\x01(\
    \x08R\rreliableSound\x123\n\x06sounds\x18\x02\x20\x03(\x0b2\x1b.CSVCMsg_\
    Sounds.sounddata_tR\x06sounds\x1a\x99\x04\n\x0bsounddata_t\x12\x19\n\x08\
    origin_x\x18\x01\x20\x01(\x11R\x07originX\x12\x19\n\x08origin_y\x18\x02\
    \x20\x01(\x11R\x07originY\x12\x19\n\x08origin_z\x18\x03\x20\x01(\x11R\
    \x07originZ\x12\x16\n\x06volume\x18\x04\x20\x01(\rR\x06volume\x12\x1f\n\
    \x0bdelay_value\x18\x05\x20\x01(\x02R\ndelayValue\x12'\n\x0fsequence_num\
    ber\x18\x06\x20\x01(\x05R\x0esequenceNumber\x12!\n\x0centity_index\x18\
    \x07\x20\x01(\x05R\x0bentityIndex\x12\x18\n\x07channel\x18\x08\x20\x01(\
    \x05R\x07channel\x12\x14\n\x05pitch\x18\t\x20\x01(\x05R\x05pitch\x12\x14\
    \n\x05flags\x18\n\x20\x01(\x05R\x05flags\x12\x1b\n\tsound_num\x18\x0b\
    \x20\x01(\rR\x08soundNum\x12(\n\x10sound_num_handle\x18\x0c\x20\x01(\x07\
    R\x0esoundNumHandle\x12%\n\x0espeaker_entity\x18\r\x20\x01(\x05R\rspeake\
    rEntity\x12\x1f\n\x0brandom_seed\x18\x0e\x20\x01(\x05R\nrandomSeed\x12\
    \x1f\n\x0bsound_level\x18\x0f\x20\x01(\x05R\nsoundLevel\x12\x1f\n\x0bis_\
    sentence\x18\x10\x20\x01(\x08R\nisSentence\x12\x1d\n\nis_ambient\x18\x11\
    \x20\x01(\x08R\tisAmbient\"j\n\x15CSVCMsg_EntityMessage\x12\x1b\n\tent_i\
    ndex\x18\x01\x20\x01(\x05R\x08entIndex\x12\x19\n\x08class_id\x18\x02\x20\
    \x01(\x05R\x07classId\x12\x19\n\x08ent_data\x18\x03\x20\x01(\x0cR\x07ent\
    Data\"4\n\x14CSVCMsg_CmdKeyValues\x12\x1c\n\tkeyvalues\x18\x01\x20\x01(\
    \x0cR\tkeyvalues\"P\n\x15CSVCMsg_EncryptedData\x12\x1c\n\tencrypted\x18\
    \x01\x20\x01(\x0cR\tencrypted\x12\x19\n\x08key_type\x18\x02\x20\x01(\x05\
    R\x07keyType\"\xb5\x02\n\x12CSVCMsg_HltvReplay\x12\x14\n\x05delay\x18\
    \x01\x20\x01(\x05R\x05delay\x12%\n\x0eprimary_target\x18\x02\x20\x01(\
    \x05R\rprimaryTarget\x12$\n\x0ereplay_stop_at\x18\x03\x20\x01(\x05R\x0cr\
    eplayStopAt\x12&\n\x0freplay_start_at\x18\x04\x20\x01(\x05R\rreplayStart\
    At\x122\n\x15replay_slowdown_begin\x18\x05\x20\x01(\x05R\x13replaySlowdo\
    wnBegin\x12.\n\x13replay_slowdown_end\x18\x06\x20\x01(\x05R\x11replaySlo\
    wdownEnd\x120\n\x14replay_slowdown_rate\x18\x07\x20\x01(\x02R\x12replayS\
    lowdownRate\"\xd4\x01\n\x12CCLCMsg_HltvReplay\x12\x18\n\x07request\x18\
    \x01\x20\x01(\x05R\x07request\x12'\n\x0fslowdown_length\x18\x02\x20\x01(\
    \x02R\x0eslowdownLength\x12#\n\rslowdown_rate\x18\x03\x20\x01(\x02R\x0cs\
    lowdownRate\x127\n\x18primary_target_ent_index\x18\x04\x20\x01(\x05R\x15\
    primaryTargetEntIndex\x12\x1d\n\nevent_time\x18\x05\x20\x01(\x02R\tevent\
    Time\",\n\x18CSVCMsg_BroadcastCommand\x12\x10\n\x03cmd\x18\x01\x20\x01(\
    \tR\x03cmd*\xb9\x01\n\x0cNET_Messages\x12\x0b\n\x07net_NOP\x10\0\x12\x12\
    \n\x0enet_Disconnect\x10\x01\x12\x0c\n\x08net_File\x10\x02\x12\x17\n\x13\
    net_SplitScreenUser\x10\x03\x12\x0c\n\x08net_Tick\x10\x04\x12\x11\n\rnet\
    _StringCmd\x10\x05\x12\x11\n\rnet_SetConVar\x10\x06\x12\x13\n\x0fnet_Sig\
    nonState\x10\x07\x12\x18\n\x14net_PlayerAvatarData\x10d*\x94\x02\n\x0cCL\
    C_Messages\x12\x12\n\x0eclc_ClientInfo\x10\x08\x12\x0c\n\x08clc_Move\x10\
    \t\x12\x11\n\rclc_VoiceData\x10\n\x12\x13\n\x0fclc_BaselineAck\x10\x0b\
    \x12\x14\n\x10clc_ListenEvents\x10\x0c\x12\x18\n\x14clc_RespondCvarValue\
    \x10\r\x12\x14\n\x10clc_FileCRCCheck\x10\x0e\x12\x17\n\x13clc_LoadingPro\
    gress\x10\x0f\x12\x1a\n\x16clc_SplitPlayerConnect\x10\x10\x12\x15\n\x11c\
    lc_ClientMessage\x10\x11\x12\x14\n\x10clc_CmdKeyValues\x10\x12\x12\x12\n\
    \x0eclc_HltvReplay\x10\x14*L\n\x11VoiceDataFormat_t\x12\x1a\n\x16VOICEDA\
    TA_FORMAT_STEAM\x10\0\x12\x1b\n\x17VOICEDATA_FORMAT_ENGINE\x10\x01*y\n\
    \x17ESplitScreenMessageType\x12\x1b\n\x17MSG_SPLITSCREEN_ADDUSER\x10\0\
    \x12\x1e\n\x1aMSG_SPLITSCREEN_REMOVEUSER\x10\x01\x12\x1d\n\x19MSG_SPLITS\
    CREEN_TYPE_BITS\x10\x01\x1a\x02\x10\x01*\xe2\x04\n\x0cSVC_Messages\x12\
    \x12\n\x0esvc_ServerInfo\x10\x08\x12\x11\n\rsvc_SendTable\x10\t\x12\x11\
    \n\rsvc_ClassInfo\x10\n\x12\x10\n\x0csvc_SetPause\x10\x0b\x12\x19\n\x15s\
    vc_CreateStringTable\x10\x0c\x12\x19\n\x15svc_UpdateStringTable\x10\r\
    \x12\x11\n\rsvc_VoiceInit\x10\x0e\x12\x11\n\rsvc_VoiceData\x10\x0f\x12\r\
    \n\tsvc_Print\x10\x10\x12\x0e\n\nsvc_Sounds\x10\x11\x12\x0f\n\x0bsvc_Set\
    View\x10\x12\x12\x10\n\x0csvc_FixAngle\x10\x13\x12\x16\n\x12svc_Crosshai\
    rAngle\x10\x14\x12\x10\n\x0csvc_BSPDecal\x10\x15\x12\x13\n\x0fsvc_SplitS\
    creen\x10\x16\x12\x13\n\x0fsvc_UserMessage\x10\x17\x12\x15\n\x11svc_Enti\
    tyMessage\x10\x18\x12\x11\n\rsvc_GameEvent\x10\x19\x12\x16\n\x12svc_Pack\
    etEntities\x10\x1a\x12\x14\n\x10svc_TempEntities\x10\x1b\x12\x10\n\x0csv\
    c_Prefetch\x10\x1c\x12\x0c\n\x08svc_Menu\x10\x1d\x12\x15\n\x11svc_GameEv\
    entList\x10\x1e\x12\x14\n\x10svc_GetCvarValue\x10\x1f\x12\x14\n\x10svc_P\
    aintmapData\x10!\x12\x14\n\x10svc_CmdKeyValues\x10\"\x12\x15\n\x11svc_En\
    cryptedData\x10#\x12\x12\n\x0esvc_HltvReplay\x10$\x12\x18\n\x14svc_Broad\
    castCommand\x10&*\x87\x01\n\x11ReplayEventType_t\x12\x17\n\x13REPLAY_EVE\
    NT_CANCEL\x10\0\x12\x16\n\x12REPLAY_EVENT_DEATH\x10\x01\x12\x18\n\x14REP\
    LAY_EVENT_GENERIC\x10\x02\x12'\n#REPLAY_EVENT_STUCK_NEED_FULL_UPDATE\x10\
    \x03B\x03\x80\x01\0\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(::protobuf::descriptor::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(61);
            messages.push(CMsgVector::generated_message_descriptor_data());
            messages.push(CMsgVector2D::generated_message_descriptor_data());
            messages.push(CMsgQAngle::generated_message_descriptor_data());
            messages.push(CMsgRGBA::generated_message_descriptor_data());
            messages.push(CNETMsg_Tick::generated_message_descriptor_data());
            messages.push(CNETMsg_StringCmd::generated_message_descriptor_data());
            messages.push(CNETMsg_SignonState::generated_message_descriptor_data());
            messages.push(CMsg_CVars::generated_message_descriptor_data());
            messages.push(CNETMsg_SetConVar::generated_message_descriptor_data());
            messages.push(CNETMsg_NOP::generated_message_descriptor_data());
            messages.push(CNETMsg_Disconnect::generated_message_descriptor_data());
            messages.push(CNETMsg_File::generated_message_descriptor_data());
            messages.push(CNETMsg_SplitScreenUser::generated_message_descriptor_data());
            messages.push(CNETMsg_PlayerAvatarData::generated_message_descriptor_data());
            messages.push(CCLCMsg_ClientInfo::generated_message_descriptor_data());
            messages.push(CCLCMsg_Move::generated_message_descriptor_data());
            messages.push(CCLCMsg_VoiceData::generated_message_descriptor_data());
            messages.push(CCLCMsg_BaselineAck::generated_message_descriptor_data());
            messages.push(CCLCMsg_ListenEvents::generated_message_descriptor_data());
            messages.push(CCLCMsg_RespondCvarValue::generated_message_descriptor_data());
            messages.push(CCLCMsg_FileCRCCheck::generated_message_descriptor_data());
            messages.push(CCLCMsg_LoadingProgress::generated_message_descriptor_data());
            messages.push(CCLCMsg_SplitPlayerConnect::generated_message_descriptor_data());
            messages.push(CCLCMsg_CmdKeyValues::generated_message_descriptor_data());
            messages.push(CSVCMsg_ServerInfo::generated_message_descriptor_data());
            messages.push(CSVCMsg_ClassInfo::generated_message_descriptor_data());
            messages.push(CSVCMsg_SendTable::generated_message_descriptor_data());
            messages.push(CSVCMsg_Print::generated_message_descriptor_data());
            messages.push(CSVCMsg_SetPause::generated_message_descriptor_data());
            messages.push(CSVCMsg_SetView::generated_message_descriptor_data());
            messages.push(CSVCMsg_CreateStringTable::generated_message_descriptor_data());
            messages.push(CSVCMsg_UpdateStringTable::generated_message_descriptor_data());
            messages.push(CSVCMsg_VoiceInit::generated_message_descriptor_data());
            messages.push(CSVCMsg_VoiceData::generated_message_descriptor_data());
            messages.push(CSVCMsg_FixAngle::generated_message_descriptor_data());
            messages.push(CSVCMsg_CrosshairAngle::generated_message_descriptor_data());
            messages.push(CSVCMsg_Prefetch::generated_message_descriptor_data());
            messages.push(CSVCMsg_BSPDecal::generated_message_descriptor_data());
            messages.push(CSVCMsg_SplitScreen::generated_message_descriptor_data());
            messages.push(CSVCMsg_GetCvarValue::generated_message_descriptor_data());
            messages.push(CSVCMsg_Menu::generated_message_descriptor_data());
            messages.push(CSVCMsg_UserMessage::generated_message_descriptor_data());
            messages.push(CSVCMsg_PaintmapData::generated_message_descriptor_data());
            messages.push(CSVCMsg_GameEvent::generated_message_descriptor_data());
            messages.push(CSVCMsg_GameEventList::generated_message_descriptor_data());
            messages.push(CSVCMsg_TempEntities::generated_message_descriptor_data());
            messages.push(CSVCMsg_PacketEntities::generated_message_descriptor_data());
            messages.push(CSVCMsg_Sounds::generated_message_descriptor_data());
            messages.push(CSVCMsg_EntityMessage::generated_message_descriptor_data());
            messages.push(CSVCMsg_CmdKeyValues::generated_message_descriptor_data());
            messages.push(CSVCMsg_EncryptedData::generated_message_descriptor_data());
            messages.push(CSVCMsg_HltvReplay::generated_message_descriptor_data());
            messages.push(CCLCMsg_HltvReplay::generated_message_descriptor_data());
            messages.push(CSVCMsg_BroadcastCommand::generated_message_descriptor_data());
            messages.push(cmsg_cvars::CVar::generated_message_descriptor_data());
            messages.push(csvcmsg_class_info::Class_t::generated_message_descriptor_data());
            messages.push(csvcmsg_send_table::Sendprop_t::generated_message_descriptor_data());
            messages.push(csvcmsg_game_event::Key_t::generated_message_descriptor_data());
            messages.push(csvcmsg_game_event_list::Key_t::generated_message_descriptor_data());
            messages.push(csvcmsg_game_event_list::Descriptor_t::generated_message_descriptor_data());
            messages.push(csvcmsg_sounds::Sounddata_t::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(6);
            enums.push(NET_Messages::generated_enum_descriptor_data());
            enums.push(CLC_Messages::generated_enum_descriptor_data());
            enums.push(VoiceDataFormat_t::generated_enum_descriptor_data());
            enums.push(ESplitScreenMessageType::generated_enum_descriptor_data());
            enums.push(SVC_Messages::generated_enum_descriptor_data());
            enums.push(ReplayEventType_t::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
