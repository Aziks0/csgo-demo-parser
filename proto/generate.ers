#!/usr/bin/env rust-script
// cargo-deps: protobuf-codegen="3.2.0"

use std::fs;
use std::io;
use std::path::{Path, PathBuf};

const OUTPUT_DIR_RELATIVE: &'static str = "../src/messages";
const INPUT_DIR_RELATIVE: &'static str = "./messages";

struct ScriptDirPath {
    path: PathBuf,
}

impl ScriptDirPath {
    fn new() -> Self {
        // Get the path to `generate.ers`
        let script_file_path = env!("RUST_SCRIPT_PATH");

        // Get the path to the dir of `generate.ers`
        let mut path = PathBuf::from(script_file_path);
        path.pop();

        Self { path }
    }

    fn push_return<P: AsRef<Path>>(&self, path: P) -> PathBuf {
        let mut path_returned = self.path.clone();
        path_returned.push(path);
        path_returned
    }
}

fn main() {
    let script_dir_path = ScriptDirPath::new();
    let mut output_dir = script_dir_path.push_return(OUTPUT_DIR_RELATIVE);
    let input_dir = script_dir_path.push_return(INPUT_DIR_RELATIVE);

    // Create output dir if not already present
    fs::create_dir_all(output_dir.as_path()).unwrap();

    // Get proto files
    let input_files = fs::read_dir(input_dir.as_path())
        .unwrap()
        .map(|res| res.map(|e| e.path()))
        .collect::<Result<Vec<_>, io::Error>>()
        .unwrap();
    // Get proto filenames without `.proto` extension
    let input_filenames = input_files
        .iter()
        .map(|file| file.file_stem().unwrap().to_str().unwrap())
        .collect::<Vec<_>>();
    println!("Proto files that will be generated: {:#?}", input_filenames);

    // Ask not to generate `mod.rs` file, we will do it ourselves
    // We also want `Bytes` and `Chars` instead of `Vec<u8>` and `String`
    let customized = protobuf_codegen::Customize::default()
        .gen_mod_rs(false)
        .tokio_bytes(true)
        .tokio_bytes_for_string(true);
    // Compile proto files
    protobuf_codegen::Codegen::new()
        .customize(customized)
        .out_dir(output_dir.as_path())
        .include(input_dir)
        .inputs(input_files.as_slice())
        .run_from_script();
    println!("✔ - Proto files compiled");

    // Generate a mod file with every message module re-exported
    // Should be like this:
    // ```
    // mod netmessages;
    // mod cstrike15_usermessages;
    //
    // pub use netmessages::*;
    // pub use cstrike15_usermessages::*;
    // ```
    //
    // Generate `mod x_messages;` lines
    let module_lines = input_filenames
        .iter()
        .map(|file| format!("mod {};\n", file))
        .collect::<Vec<String>>();
    // Generate `pub use x_messages::*;` lines
    let re_export_module_lines = input_filenames
        .iter()
        .map(|file| format!("pub use {}::*;\n", file))
        .collect::<Vec<String>>();
    // Concatenate all this shit
    let mut mod_file =
        String::from("// This file is generated by `../proto/generate.ers`. Do not edit.\n\n");
    for line in module_lines {
        mod_file.push_str(line.as_str());
    }
    mod_file.push('\n');
    for line in re_export_module_lines {
        mod_file.push_str(line.as_str());
    }
    // Write generated `mod.rs` file
    output_dir.push("/mod.rs");
    fs::write(output_dir, mod_file).unwrap();
    println!("✔ - Mod file generated");
}
